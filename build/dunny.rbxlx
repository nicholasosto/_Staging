<roblox version="4">
  <Item class="HttpService" referent="0">
    <Properties>
      <string name="Name">HttpService</string>
      <bool name="HttpEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="ReplicatedStorage" referent="1">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="ModuleScript" referent="2">
      <Properties>
        <string name="Name">Constants</string>
        <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        index.ts
	 * @module      ConstantsIndex
	 * @layer       Shared
	 * @description Barrel file exporting shared constants.
	 
]]
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "Constants", "Sizes") or {} do
	exports[_k] = _v
end
return exports
]]></string>
      </Properties>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">Sizes</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        Sizes.ts
	 * @module      Sizes
	 * @layer       Shared
	 * @description Cross-theme numeric constants.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
local Sizes = {
	Avatar = {
		Width = 100,
		Height = 100,
	},
	Badge = {
		Width = 35,
		Height = 35,
	},
	ImageButtonDefault = {
		Width = 50,
		Height = 50,
	},
	ResourceBar = {
		Width = 200,
		Height = 30,
	},
	MenuButtonBar = {
		Width = 300,
		Height = 80,
	},
	ActionBar = {
		Width = 600,
		Height = 100,
	},
	CharacterInfoCard = {
		Width = 300,
		Height = 200,
	},
	HUDPanel = {
		Width = 600,
		Height = 450,
	},
}
local function createUDim2(sizeType)
	local size = Sizes[sizeType]
	return UDim2.fromOffset(size.Width, size.Height)
end
local ComponentSizes = {
	Avatar = createUDim2("Avatar"),
	Badge = createUDim2("Badge"),
	ImageButtonDefault = createUDim2("ImageButtonDefault"),
	ActionBar = createUDim2("ActionBar"),
	MenuButtonBar = createUDim2("MenuButtonBar"),
	CharacterInfoCard = createUDim2("CharacterInfoCard"),
	HUDPanel = createUDim2("HUDPanel"),
	ResourceBar = createUDim2("ResourceBar"),
}
return {
	Sizes = Sizes,
	ComponentSizes = ComponentSizes,
}
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="ModuleScript" referent="4">
      <Properties>
        <string name="Name">TS</string>
        <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--[[
	*
	 * @file src/shared/index.ts
	 * @module shared
	 * @layer Shared
	 * @description Barrel export for shared modules.
	 
]]
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "classes") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "constants") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "network") or {} do
	exports[_k] = _v
end
return exports
]]></string>
      </Properties>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">assets</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/shared/assets/index.ts
	 * @module      SharedAssetsIndex
	 * @layer       Shared/Assets
	 * @description Barrel export for asset constants.
	 
]]
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "Animation") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets", "audio") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets", "image") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets", "gradients") or {} do
	exports[_k] = _v
end
return exports
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="6">
          <Properties>
            <string name="Name">audio</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        audio.ts
	 * @module      GameAudio
	 * @layer       shared/assets
	 * @description List of audio asset IDs used in the game.
	 *
	 * ╭──────────────────────────────╮
	 * │  Soul Steel · Coding Guide   │
	 * │  Fusion v4 · Strict TS · ECS │
	 * ╰──────────────────────────────╯
	 *
	 * @since        0.1.0
	 * @lastUpdated  2025-06-10 by Trembus
	 
]]
local GameAudio = {
	RobotTheme = {
		BackgroundMusic = "rbxassetid://1234567890",
		SuccessClick = "rbxassetid://1234567891",
		ErrorClick = "rbxassetid://1234567892",
		Damaged = "rbxassetid://1234567893",
		CastSpell = "rbxassetid://1234567894",
		MeleeAttack = "rbxassetid://1234567895",
		Death = "rbxassetid://1234567896",
		LevelUp = "rbxassetid://1234567897",
	},
	ZombieTheme = {
		BackgroundMusic = "rbxassetid://1234567898",
		SuccessClick = "rbxassetid://1234567899",
		ErrorClick = "rbxassetid://1234567900",
		Damaged = "rbxassetid://1234567901",
		CastSpell = "rbxassetid://1234567902",
		MeleeAttack = "rbxassetid://1234567903",
		Death = "rbxassetid://1234567904",
		LevelUp = "rbxassetid://1234567905",
	},
}
local createAudio = function(theme, soundName)
	local soundId = GameAudio[theme][soundName]
	local sound = Instance.new("Sound")
	sound.SoundId = soundId
	sound.Volume = 0.5
	sound.Looped = false
	return sound
end
return {
	GameAudio = GameAudio,
	createAudio = createAudio,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="7">
          <Properties>
            <string name="Name">gradients</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/ui/gradients.ts
	 * @module      Gradient Exports
	 * @layer       Client/Style
	 * @description  Collection of reusable UI gradients for various styles.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-23 by Trembus – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local New = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").New
local ShadowGradient = function()
	return New("UIGradient")({
		Name = "ShadowGradient",
		Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(0.5, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0)) }),
		Transparency = NumberSequence.new({ NumberSequenceKeypoint.new(0, 0.5), NumberSequenceKeypoint.new(0.5, 0.5), NumberSequenceKeypoint.new(1, 0.5) }),
		Rotation = 90,
		Offset = Vector2.new(0, 0.5),
	})
end
local OldShadowGradient = function()
	return New("UIGradient")({
		Name = "ContainerGradientTransparent",
		Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.new()), ColorSequenceKeypoint.new(0.0813149, Color3.fromRGB(21, 21, 21)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1)) }),
		Transparency = NumberSequence.new({ NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0.625, 0.1875) }),
	})
end
--[[
	*
	 * Warm sunrise style gradient.
	 
]]
local SunriseGradient = function()
	return New("UIGradient")({
		Name = "SunriseGradient",
		Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 170, 0)), ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 85, 0)), ColorSequenceKeypoint.new(1, Color3.fromRGB(128, 0, 128)) }),
		Transparency = NumberSequence.new(0),
		Rotation = 90,
	})
end
--[[
	*
	 * Simple blue gradient useful for backgrounds.
	 
]]
local OceanGradient = function()
	return New("UIGradient")({
		Name = "OceanGradient",
		Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 170, 255)), ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 85, 170)) }),
		Transparency = NumberSequence.new(0),
	})
end
--[[
	*
	 * Glass-like glow with transparent center.
	 
]]
local GlassGradient = function()
	return New("UIGradient")({
		Name = "GlassGradient",
		Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(0.5, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1)) }),
		Transparency = NumberSequence.new({ NumberSequenceKeypoint.new(0, 0.8), NumberSequenceKeypoint.new(0.5, 0.3), NumberSequenceKeypoint.new(1, 0.8) }),
	})
end
--[[
	*
	 * Lava-like gradient with fiery colors.
	 *
	 * @returns {UIGradient} The lava gradient.
	 * @since 0.2.0
	 * 	
]]
local LavaGradient = function()
	return New("UIGradient")({
		Name = "LavaGradient",
		Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 85, 0)), ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 122, 0)), ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0)) }),
		Transparency = NumberSequence.new(0),
		Rotation = 90,
	})
end
return {
	ShadowGradient = ShadowGradient,
	OldShadowGradient = OldShadowGradient,
	SunriseGradient = SunriseGradient,
	OceanGradient = OceanGradient,
	GlassGradient = GlassGradient,
	LavaGradient = LavaGradient,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="8">
          <Properties>
            <string name="Name">image</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        image.ts
	 * @module      GameImages
	 * @layer       shared/assets
	 * @description List of image asset IDs used in the game.
	 *
	 * ╭──────────────────────────────╮
	 * │  Soul Steel · Coding Guide   │
	 * │  Fusion v4 · Strict TS · ECS │
	 * ╰──────────────────────────────╯
	 *
	 * @since        0.1.0
	 * @lastUpdated  2025-06-10 by Trembus
	 
]]
-- =============================================== Image Constants =============================================== 
local MenuButtonImageMap = {
	Settings = "rbxassetid://122289639886993",
	Inventory = "rbxassetid://132702292243603",
	Character = "rbxassetid://100274464430589",
	Quests = "rbxassetid://129030346503415",
	Shop = "rbxassetid://101998590177560",
	Teleport = "rbxassetid://127118741571164",
	GemForge = "rbxassetid://116506062642047",
}
local GameImages = {
	MenuButtonImage = "rbxassetid://79163709624038",
	DefaultUnassigned = "rbxassetid://117838504772569",
	Ability = {
		Background = "rbxassetid://91419725020401",
		Unassigned = "rbxassetid://98384046526938",
		Flame_Sythe = "rbxassetid://108246514585300",
		HallowHold = "rbxassetid://79001631229851",
		Fireball = "rbxassetid://108246514585301",
		Ice_Shard = "rbxassetid://77085115837905",
		Lightning_Bolt = "rbxassetid://84562572112570",
		Earthquake = "rbxassetid://72703784685790",
		Melee = "rbxassetid://114327486101696",
		Blood_Siphon = "rbxassetid://135950973087916",
		Blood_Horror = "rbxassetid://82257212198629",
		Blood_Elemental = "rbxassetid://122556254156811",
		Spirit_Circles = "rbxassetid://78703065651895",
	},
	Attributes = {
		Strength = "rbxassetid://127745571044516",
		Dexterity = "rbxassetid://73893872719367",
		Intelligence = "rbxassetid://107600003376684",
		Vitality = "rbxassetid://121291227474039",
		Luck = "rbxassetid://114767496083209",
	},
	Borders = {
		GothicMetal = "rbxassetid://80375133768026",
		RedThick = "rbxassetid://134322739825066",
		CommonSet = "rbxassetid://85778039199330",
		RareSet = "rbxassetid://82228066842612",
		EpicSet = "rbxassetid://135166624307221",
		LegendarySet = "rbxassetid://85570068018789",
	},
	Control = {
		Increment = "rbxassetid://102421835119714",
		Decrement = "rbxassetid://78091115085992",
		Close = "rbxassetid://91437543746962",
		TripleArrow = "rbxassetid://136693752293641",
	},
	Currency = {
		Coins = "rbxassetid://127745571044516",
		Shards = "rbxassetid://73893872719367",
		Tombs = "rbxassetid://121291227474039",
	},
	Gems = {
		Colorable = "rbxassetid://71842732472075",
		Common = "rbxassetid://71842732472075",
		Uncommon = "rbxassetid://71842732472075",
		Rare = "rbxassetid://71842732472075",
		Epic = "rbxassetid://119000054151103",
		Legendary = "rbxassetid://71842732472075",
	},
	SlotImage = {
		Unassigned = "rbxassetid://98384046526938",
		Helmet = "rbxassetid://98384046526938",
		Armor = "rbxassetid://98384046526938",
		Weapon = "rbxassetid://98384046526938",
		Accessory = "rbxassetid://98384046526938",
	},
	TextureImage = {
		BoneDoily = "rbxassetid://108018297611555",
		Mystical = "rbxassetid://108018297611556",
		WavyMetal = "rbxassetid://99123505462124",
	},
}
return {
	MenuButtonImageMap = MenuButtonImageMap,
	GameImages = GameImages,
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="9">
        <Properties>
          <string name="Name">calculations</string>
        </Properties>
        <Item class="ModuleScript" referent="10">
          <Properties>
            <string name="Name">ResourceCalculator</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--[[
	*
	 * @file ResourceCalculator.ts
	 * @module ResourceCalculator
	 * @author Trembus
	 * @layer Shared/Calculations
	 * @description Contains utility functions for calculating resource values like health, mana, and stamina based on attributes.
	 
]]
-- formulas/ResourceFormula.ts
local ResourceFormula = {
	Health = function(a, lvl)
		return 50 + a.str * 10 + lvl * 5
	end,
	Mana = function(a, lvl)
		return 30 + a.int * 12
	end,
	Stamina = function(a, lvl)
		return 40 + a.agi * 8 + lvl * 2
	end,
}
return {
	ResourceFormula = ResourceFormula,
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="11">
        <Properties>
          <string name="Name">classes</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "classes", "CooldownTimer") or {} do
	exports[_k] = _v
end
return exports
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="12">
          <Properties>
            <string name="Name">CooldownTimer</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        CooldownTimer.ts
	 * @module      CooldownTimer
	 * @layer       Shared/Util
	 * @description Simple, self-contained stop-watch for ability cool-downs.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.2
	 * @lastUpdated  2025-06-27 by Luminesa – Fix Signal import, tidy types
	 *
	 * @dependencies
	 *   @rbxts/fusion  ^0.4.0
	 *   @rbxts/maid    ^1.3.0
	 *   @rbxts/signal  ^1.1.0
	 
]]
local RunService = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").RunService
local Maid = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "maid", "Maid")
local Signal = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "signal")
local Value = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").Value
--* Fraction 1 → 0 while cooling, 0 when ready 
local CooldownTimer
do
	CooldownTimer = setmetatable({}, {
		__tostring = function()
			return "CooldownTimer"
		end,
	})
	CooldownTimer.__index = CooldownTimer
	function CooldownTimer.new(...)
		local self = setmetatable({}, CooldownTimer)
		return self:constructor(...) or self
	end
	function CooldownTimer:constructor(durationSeconds)
		self.Progress = Value(0)
		self.maid = Maid.new()
		self.done = Signal.new()
		self.startTs = 0
		self.duration = math.max(durationSeconds, 0)
	end
	function CooldownTimer:start()
		print(`Starting cooldown for {self.duration} seconds`)
		self:cancel()
		self.startTs = os.clock()
		self.Progress:set(1)
		local update = function()
			local elapsed = os.clock() - self.startTs
			local remaining = math.max(self.duration - elapsed, 0)
			self.Progress:set(remaining / self.duration)
			if remaining == 0 then
				self.done:Fire()
				self:cancel()
			end
		end
		if RunService:IsClient() then
			self.maid:GiveTask(RunService.Heartbeat:Connect(update))
		else
			-- Server: ~30 fps polling is sufficient and cheaper
			self.maid:GiveTask(task.spawn(function()
				while not self:isReady() do
					update()
					task.wait()
				end
			end))
		end
	end
	function CooldownTimer:cancel()
		self.maid:DoCleaning()
		self.Progress:set(0)
	end
	function CooldownTimer:isReady()
		return self.Progress:get() == 0
	end
	function CooldownTimer:onComplete(cb)
		print("Connecting cooldown completion callback")
		return self.done:Connect(cb)
	end
	function CooldownTimer:destroy()
		self:cancel()
		self.done:Destroy()
	end
end
return {
	CooldownTimer = CooldownTimer,
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="13">
        <Properties>
          <string name="Name">constants</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "constants", "sizes") or {} do
	exports[_k] = _v
end
return exports
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="14">
          <Properties>
            <string name="Name">CodeSettings</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local CodeSettings = {
	DEBUG_SERVER = true,
	DEBUG_CLIENT = false,
	DEBUG_NPC = false,
	DEBUG_DATASERVICE = true,
	DEBUG_PLAYER = true,
}
return {
	CodeSettings = CodeSettings,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="15">
          <Properties>
            <string name="Name">sizes</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        sizes.ts
	 * @module      Sizes
	 * @layer       Client/Style
	 * @description Utility functions for common UI sizes.
	 
]]
-- =============================================== Imports =============================================== 
-- =============================================== Text Sizes =============================================== 
local TextSizes = {
	Default = 24,
	Title = 32,
	Subtitle = 28,
	Button = 20,
	BigBar = 18,
	SmallBar = 16,
}
-- =============================================== Button Sizes =============================================== 
local ButtonSizes = {
	Default = function()
		return UDim2.fromOffset(150, 50)
	end,
	Icon = function()
		return UDim2.fromOffset(30, 30)
	end,
	GridButton = function()
		return UDim2.fromOffset(90, 90)
	end,
}
-- =============================================== Panel Sizes =============================================== 
local PanelSizes = {
	ModalPanel = function()
		return UDim2.fromOffset(600, 400)
	end,
	ResourceBarContainer = function()
		return UDim2.fromOffset(400, 1)
	end,
	ResourceBar = function()
		return UDim2.fromOffset(1, 0.333)
	end,
}
return {
	TextSizes = TextSizes,
	ButtonSizes = ButtonSizes,
	PanelSizes = PanelSizes,
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="16">
        <Properties>
          <string name="Name">definitions</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/shared/data/index.ts
	 * @module      data
	 * @layer       Shared
	 * @description Barrel export for shared data modules.
	 
]]
-- Folders
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "ProfileDefinitions") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "PanelSlots") or {} do
	exports[_k] = _v
end
-- Modules
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "Animation") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "Codon") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "Loot") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "NPC") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "Rarity") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "Resources") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "StatusEffect") or {} do
	exports[_k] = _v
end
return exports
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="17">
          <Properties>
            <string name="Name">Animation</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        animations.ts
	 * @module      AnimationAssets
	 * @layer       Shared/Assets
	 * @description Helpers for loading and playing animation tracks.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
local ANIMATION_KEY = { "Dodge", "GodLike", "HallowHold", "KickFast", "PowerBeam", "Punch_01", "ScytheAttack", "SpinKick", "TakeDamage", "Taunt" }
local AnimationTrackRegistry = {}
local RegisterTrackMap = function(model, trackMap)
	local _model = model
	if AnimationTrackRegistry[_model] ~= nil then
		warn(`TrackMap for model {model.Name} already exists. Overwriting.`)
	end
	local _model_1 = model
	local _trackMap = trackMap
	AnimationTrackRegistry[_model_1] = _trackMap
end
local DeregisterTrackMap = function(model)
	local _model = model
	if AnimationTrackRegistry[_model] ~= nil then
		local _model_1 = model
		AnimationTrackRegistry[_model_1] = nil
	end
end
local GetTrack = function(model, key)
	local _model = model
	if AnimationTrackRegistry[_model] ~= nil then
		local _model_1 = model
		local _result = AnimationTrackRegistry[_model_1]
		if _result ~= nil then
			_result = _result[key]
		end
		return _result
	end
end
local AnimationAssets = {
	Dodge = "rbxassetid://15487656295",
	GodLike = "rbxassetid://140479956568725",
	HallowHold = "rbxassetid://125099220628366",
	KickFast = "rbxassetid://126544239907410",
	PowerBeam = "rbxassetid://132928610589952",
	Punch_01 = "rbxassetid://15487656295",
	ScytheAttack = "rbxassetid://77799116860007",
	SpinKick = "rbxassetid://100351397638487",
	TakeDamage = "rbxassetid://16144885391",
	Taunt = "rbxassetid://98363948502311",
}
local function getAnimationAsset(key)
	if AnimationAssets[key] ~= nil then
		return AnimationAssets[key]
	else
		warn(`Animation asset for key "{key}" not found.`)
		return ""
	end
end
local function createAnimation(key)
	local animation = Instance.new("Animation")
	animation.AnimationId = getAnimationAsset(key)
	animation.Name = key
	return animation
end
local function loadAnimation(model, key)
	local animation = createAnimation(key)
	local humanoid = model:FindFirstChildOfClass("Humanoid")
	if humanoid then
		local animator = humanoid:FindFirstChildOfClass("Animator")
		if animator then
			local track = animator:LoadAnimation(animation)
			if track then
				local _model = model
				if not (AnimationTrackRegistry[_model] ~= nil) then
					local _model_1 = model
					AnimationTrackRegistry[_model_1] = {}
				end
				local _model_1 = model
				AnimationTrackRegistry[_model_1][key] = track
				return track
			else
				warn(`Failed to load animation track for {key} on model {model.Name}`)
			end
		else
			warn(`Animator not found on model {model.Name}`)
		end
	else
		warn(`Humanoid not found on model {model.Name}`)
	end
	return nil
end
local playAnimation = function(model, key)
	local track = GetTrack(model, key)
	if track then
		track:Play()
	else
		warn(`Animation track for {key} not found on model {model.Name}`)
	end
end
return {
	getAnimationAsset = getAnimationAsset,
	createAnimation = createAnimation,
	loadAnimation = loadAnimation,
	ANIMATION_KEY = ANIMATION_KEY,
	RegisterTrackMap = RegisterTrackMap,
	DeregisterTrackMap = DeregisterTrackMap,
	GetTrack = GetTrack,
	AnimationAssets = AnimationAssets,
	playAnimation = playAnimation,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="18">
          <Properties>
            <string name="Name">Codon</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        CodonData.ts
	 * @module      CodonDefinitions
	 * @layer       Shared/Data
	 * @description Contains constants and types related to codons used in the game.
	 * @author      Trembus
	 * @license     MIT
	 * @since       0.2.0
	 * @lastUpdated 2025-06-25 by Trembus – Initial creation
	 * @dependencies
	 *   @rbxts/types ^0.4.0
	 
]]
-- Codon Key Constants 
local CODONKEY = { "AAA", "AAC", "AAG", "AAT", "ACA", "ACC", "ACG", "ACT", "AGA", "AGC", "AGG", "AGT", "ATA", "ATC", "ATG", "ATT", "CAA", "CAC", "CAG", "CAT", "CCA", "CCC", "CCG", "CCT", "CGA", "CGC", "CGG", "CGT", "CTA", "CTC", "CTG", "CTT", "GAA", "GAC", "GAG", "GAT", "GCA", "GCC", "GCG", "GCT", "GGA", "GGC", "GGG", "GGT", "GTA", "GTC", "GTG", "GTT", "TAA", "TAC", "TAG", "TAT", "TCA", "TCC", "TCG", "TCT", "TGA", "TGC", "TGG", "TGT", "TTA", "TTC", "TTG", "TTT" }
local _set = {}
for _, _v in CODONKEY do
	_set[_v] = true
end
local CODONKEYSET = _set
return {
	CODONKEY = CODONKEY,
	CODONKEYSET = CODONKEYSET,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="19">
          <Properties>
            <string name="Name">Loot</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--[[
	*
	 * @file        LootTableDefinitions.ts
	 * @module      DataDefinitions/LootTables
	 * @layer       Shared
	 * @description Static catalogue of weighted loot tables.
	 
]]
--[[
	───────────────────────────────────────────────────────────────────────────*\
	   1️⃣  Canonical list of loot-table keys
	\*───────────────────────────────────────────────────────────────────────────
]]
local LOOT_TABLE_KEYS = { "ZOMBIE_COMMON", "GOBLIN_ELITE", "SKELETON_COMMON", "CRYSTAL_GOLEM", "WORLD_BOSS" }
--[[
	───────────────────────────────────────────────────────────────────────────*\
	   2️⃣  Metadata interfaces
	\*───────────────────────────────────────────────────────────────────────────
]]
--* Single weighted entry inside a loot table 
--* Compile-time description of an entire loot table 
local LootTableMetaMap = {
	ZOMBIE_COMMON = {
		rolls = { 1, 2 },
		entries = { {
			drop = "COPPER_COIN",
			quantity = { 3, 8 },
			weight = 50,
		}, {
			drop = "TATTERED_CLOTH",
			quantity = { 1, 2 },
			weight = 20,
		}, {
			drop = "SMALL_HEALTH_POTION",
			quantity = 1,
			weight = 10,
		}, {
			drop = "GOBLIN_EAR",
			quantity = 1,
			weight = 20,
		} },
	},
	GOBLIN_ELITE = {
		rolls = { 2, 3 },
		guaranteed = { {
			drop = "COPPER_COIN",
			quantity = { 5, 12 },
		} },
		entries = { {
			drop = "IRON_INGOT",
			quantity = 1,
			weight = 30,
		}, {
			drop = "MEDIUM_HEALTH_POTION",
			quantity = 1,
			weight = 15,
		}, {
			drop = "GOBLIN_RUNE_FRAGMENT",
			quantity = 1,
			weight = 5,
		} },
	},
	SKELETON_COMMON = {
		rolls = { 1, 2 },
		entries = { {
			drop = "BONE_SHARD",
			quantity = { 2, 5 },
			weight = 50,
		}, {
			drop = "NECROTIC_DUST",
			quantity = 1,
			weight = 15,
		}, {
			drop = "SMALL_MANA_POTION",
			quantity = 1,
			weight = 10,
		}, {
			drop = "CRACKED_RIB",
			quantity = 1,
			weight = 25,
		} },
	},
	CRYSTAL_GOLEM = {
		rolls = { 2, 4 },
		guaranteed = { {
			drop = "GOLEM_CORE",
			quantity = 1,
		} },
		entries = { {
			drop = "AZURE_CRYSTAL",
			quantity = { 1, 3 },
			weight = 40,
		}, {
			drop = "MYSTIC_DUST",
			quantity = { 2, 4 },
			weight = 30,
		}, {
			drop = "LARGE_MANA_POTION",
			quantity = 1,
			weight = 20,
		}, {
			drop = "PRISMATIC_SHARD",
			quantity = 1,
			weight = 10,
		} },
	},
	WORLD_BOSS = {
		rolls = { 5, 7 },
		guaranteed = { {
			drop = "GOLD_COIN",
			quantity = { 50, 100 },
		} },
		entries = { {
			drop = "LEGENDARY_WEAPON_TOKEN",
			quantity = 1,
			weight = 2,
			unique = true,
		}, {
			drop = "EPIC_GEM",
			quantity = 1,
			weight = 10,
		}, {
			drop = "RARE_GEM",
			quantity = 1,
			weight = 25,
		}, {
			drop = "AZURE_CRYSTAL",
			quantity = { 3, 6 },
			weight = 30,
		}, {
			drop = "MYTHIC_SCROLL_FRAGMENT",
			quantity = 1,
			weight = 8,
		}, {
			drop = "LARGE_HEALTH_POTION",
			quantity = 2,
			weight = 25,
		} },
	},
}
return {
	LOOT_TABLE_KEYS = LOOT_TABLE_KEYS,
	LootTableMetaMap = LootTableMetaMap,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="20">
          <Properties>
            <string name="Name">NPC</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--[[
	*
	 * @file        NPCDefinitions.ts
	 * @module      DataDefinitions/NPC
	 * @layer       Shared
	 * @description Static NPC template catalogue.
	 
]]
local ReplicatedStorage = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").ReplicatedStorage
-- --------------------------------------------------------- Rig Template Folders --------------------------------------------------------- 
local RigTemplateFolder = ReplicatedStorage:WaitForChild("SS Game Package"):WaitForChild("Models"):WaitForChild("Rigs")
local BloodTemplates = RigTemplateFolder:WaitForChild("Blood")
local DecayTemplates = RigTemplateFolder:WaitForChild("Decay")
local FatelessTemplates = RigTemplateFolder:WaitForChild("Fateless")
local RobotTemplates = RigTemplateFolder:WaitForChild("Robots")
local SpiritTemplates = RigTemplateFolder:WaitForChild("Spirit")
-- --------------------------------------------------------- NPC Keys --------------------------------------------------------- 
local NPC_KEYS = { "BLOOD_TOAD", "ZOMBIE", "FATELESS", "MECHA_MONKEY", "STEAM_BOT", "ELEMENTAL" }
--* Compile-time template metadata 
local NPCMetaMap = {
	BLOOD_TOAD = {
		displayName = "Blood Toad",
		modelTemplate = BloodTemplates:WaitForChild("BloodToad"),
		baseStats = {
			maxHealth = 50,
			attack = 10,
			defense = 5,
			speed = 1.2,
		},
		abilities = { "fireball", "ice_shard" },
		lootTable = "ZOMBIE_COMMON",
		aiProfile = "ranged",
		theme = "goblin",
	},
	ZOMBIE = {
		displayName = "Zombie",
		modelTemplate = DecayTemplates:WaitForChild("Zombie"),
		baseStats = {
			maxHealth = 60,
			attack = 15,
			defense = 7,
			speed = 1.1,
		},
		abilities = { "lightning_bolt" },
		lootTable = "ZOMBIE_COMMON",
		aiProfile = "ranged",
	},
	FATELESS = {
		displayName = "Fateless",
		modelTemplate = FatelessTemplates:WaitForChild("Fateless Master"),
		baseStats = {
			maxHealth = 80,
			attack = 20,
			defense = 10,
			speed = 0.9,
		},
		abilities = { "earthquake" },
		lootTable = "ZOMBIE_COMMON",
	},
	MECHA_MONKEY = {
		displayName = "Mecha Monkey",
		modelTemplate = RobotTemplates:WaitForChild("Mecha Monkey"),
		baseStats = {
			maxHealth = 120,
			attack = 25,
			defense = 15,
			speed = 1.0,
		},
		abilities = { "ice_shard", "fireball" },
		lootTable = "ZOMBIE_COMMON",
	},
	STEAM_BOT = {
		displayName = "Steam Bot",
		modelTemplate = RobotTemplates:WaitForChild("Steam Bot"),
		baseStats = {
			maxHealth = 150,
			attack = 30,
			defense = 20,
			speed = 0.8,
		},
		abilities = { "lightning_bolt", "earthquake" },
		lootTable = "ZOMBIE_COMMON",
		aiProfile = "tank",
		theme = "construct",
	},
	ELEMENTAL = {
		displayName = "Elemental",
		modelTemplate = SpiritTemplates:WaitForChild("Elemental"),
		baseStats = {
			maxHealth = 100,
			attack = 35,
			defense = 25,
			speed = 1.5,
		},
		abilities = { "fireball", "ice_shard", "lightning_bolt" },
		lootTable = "ZOMBIE_COMMON",
		aiProfile = "caster",
		theme = "spirit",
	},
}
-- --------------------------------------------------------- NPC Names --------------------------------------------------------- 
--[[
	──────────────────────────────────────────────────────────────────────*\
	   20 first-names — mix of fantasy-friendly vowels & consonant clusters
	\*──────────────────────────────────────────────────────────────────────
]]
local FIRST_NAMES = { "Thorg", "Mira", "Zug", "Elara", "Grim", "Liora", "Borik", "Sera", "Nok", "Vira", "Drek", "Tara", "Jax", "Nyra", "Kor", "Luna", "Riv", "Xara", "Valen", "Zil" }
--[[
	──────────────────────────────────────────────────────────────────────*\
	   20 last-names — mix of fantasy-friendly endings & consonant clusters
	\*──────────────────────────────────────────────────────────────────────
]]
local LAST_NAMES = { "Darkblade", "Ironfist", "Shadowstep", "Stormfang", "Stonebrow", "Nightbloom", "Frostwhisper", "Bloodthorn", "Dawnspear", "Grimscale", "Everflame", "Swiftclaw", "Deepforge", "Moonsong", "Bonebreaker", "Brightfang", "Blackthorn", "Dreamweaver", "Riftwalker", "Gloomspire" }
local MONIKERS = {
	BLOOD_TOAD = { "the Filcher", "Mudfoot", "Ripfang" },
	ZOMBIE = { "the Rotting", "Flesh Eater", "Gravewalker" },
	FATELESS = { "the Unbound", "Soul Reaver", "Voidcaller" },
	MECHA_MONKEY = { "the Cogmaster", "Iron Fist", "Geargrinder" },
	STEAM_BOT = { "the Boiler", "Rustheart", "Steamwielder" },
	ELEMENTAL = { "the Stormbringer", "Flameheart", "Frostbinder" },
}
return {
	NPC_KEYS = NPC_KEYS,
	NPCMetaMap = NPCMetaMap,
	FIRST_NAMES = FIRST_NAMES,
	LAST_NAMES = LAST_NAMES,
	MONIKERS = MONIKERS,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="21">
          <Properties>
            <string name="Name">PanelSlots</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "PanelSlots", "GemSlots") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "PanelSlots", "Equipment") or {} do
	exports[_k] = _v
end
return exports
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="22">
            <Properties>
              <string name="Name">Equipment</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        Equipment.ts
	 * @module      EquipmentDefinitions
	 * @layer       Shared/Data
	 * @description Enumerates equipment slots and their metadata.
	 
]]
local GameImages = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets").GameImages
local EQUIPMENT_SLOT_KEYS = { "Helmet", "Chest", "Back", "Necklace", "Ring" }
-- Equipment Slot Keys
-- Equipment Slot Map Type
-- Equipment Slot Metadata Interface
-- Equipment Slot Metadata Records
local EquipmentSlotMeta = {
	Helmet = {
		displayName = "Helmet",
		iconId = GameImages.SlotImage.Helmet,
	},
	Chest = {
		displayName = "Chest",
		iconId = GameImages.SlotImage.Armor,
	},
	Back = {
		displayName = "Back",
		iconId = GameImages.SlotImage.Accessory,
	},
	Necklace = {
		displayName = "Necklace",
		iconId = GameImages.SlotImage.Accessory,
	},
	Ring = {
		displayName = "Ring",
		iconId = GameImages.SlotImage.Accessory,
	},
}
return {
	EQUIPMENT_SLOT_KEYS = EQUIPMENT_SLOT_KEYS,
	EquipmentSlotMeta = EquipmentSlotMeta,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="23">
            <Properties>
              <string name="Name">GemSlots</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--[[
	*
	 * @file        src/shared/definitions/PanelSlots/index.ts
	 * @module      PanelSlots
	 * @layer       Shared/Definitions
	 * @description Definitions for panel slots used in the UI.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-07-02 by Codex – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local GEM_SLOT_KEYS = { "FORM", "ABILITY", "PHYSICAL", "SUMMON" }
local GEM_SLOT_META = {
	FORM = {
		displayName = "Form Gem",
		iconId = "rbxassetid://132994920207160",
	},
	ABILITY = {
		displayName = "Ability Gem",
		iconId = "rbxassetid://73537063487999",
	},
	PHYSICAL = {
		displayName = "Physical Gem",
		iconId = "rbxassetid://107324366070907",
	},
	SUMMON = {
		displayName = "Magical Gem",
		iconId = "rbxassetid://104883948460103",
	},
}
return {
	GEM_SLOT_KEYS = GEM_SLOT_KEYS,
	GEM_SLOT_META = GEM_SLOT_META,
}
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="24">
          <Properties>
            <string name="Name">ProfileDefinitions</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--[[
	*
	 * @file        index.ts
	 * @module      ProfileDefinitions
	 * @layer       Shared/Definitions/ProfileDefinitions
	 * @description Barrel export for shared definition modules related to player profiles.
	 
]]
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "ProfileDefinitions", "Ability") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "ProfileDefinitions", "Attributes") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "ProfileDefinitions", "Currency") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "ProfileDefinitions", "Profile") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "ProfileDefinitions", "Settings") or {} do
	exports[_k] = _v
end
return exports
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="25">
            <Properties>
              <string name="Name">Ability</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        AbilityData.ts
	 * @module      AbilityDefinitions
	 * @author      Trembus
	 * @layer       Constants
	 * @description Canonical list of abilities, their metadata, and strongly-typed helpers for default values & validation.
	 *
	 * ╭──────────────────────────────╮
	 * │  Soul Steel · Coding Guide   │
	 * │  Fusion v4 · Strict TS · ECS │
	 * ╰──────────────────────────────╯
	 *
	 * @since        0.1.0
	 * @lastUpdated  2025-06-24 by Trembus
	 
]]
local GameImages = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets").GameImages
-- Ability Keys
local ABILITY_KEYS = { "fireball", "ice_shard", "lightning_bolt", "earthquake", "melee" }
-- Key Type
-- Ability Key Type Guard
local function isAbilityKey(key)
	local _key = key
	return table.find(ABILITY_KEYS, _key) ~= nil
end
-- Ability Metadata Interface
local AbilitiesMeta = {
	fireball = {
		displayName = "Fireball",
		iconId = GameImages.Ability.Flame_Sythe,
		animationKey = "HallowHold",
		description = "Launches a fiery projectile that explodes on impact.",
		cooldown = 5,
		basePower = 50,
		cost = {
			mana = 20,
			stamina = 10,
		},
	},
	ice_shard = {
		displayName = "Ice Shard",
		iconId = GameImages.Ability.Ice_Shard,
		animationKey = "HallowHold",
		description = "Launches a shard of ice that pierces through enemies.",
		cooldown = 6,
		basePower = 40,
		cost = {
			mana = 15,
			stamina = 5,
		},
	},
	lightning_bolt = {
		displayName = "Lightning Bolt",
		iconId = GameImages.Ability.Lightning_Bolt,
		animationKey = "HallowHold",
		description = "Calls down a bolt of lightning to strike enemies.",
		cooldown = 7,
		basePower = 60,
		cost = {
			mana = 25,
			stamina = 15,
		},
	},
	earthquake = {
		displayName = "Earthquake",
		iconId = GameImages.Ability.Earthquake,
		animationKey = "HallowHold",
		description = "Causes the ground to shake, damaging all nearby enemies.",
		cooldown = 10,
		basePower = 80,
		cost = {
			mana = 30,
			stamina = 20,
		},
	},
	melee = {
		displayName = "Melee Attack",
		iconId = GameImages.Ability.Melee,
		animationKey = "Punch_01",
		description = "A basic melee attack that deals physical damage.",
		cooldown = 2,
		basePower = 30,
		cost = {
			mana = 0,
			stamina = 5,
		},
	},
}
-- ▼ ReadonlyArray.reduce ▼
local _result = {}
local _callback = function(obj, key)
	obj[key] = 0
	return obj
end
for _i = 1, #ABILITY_KEYS do
	_result = _callback(_result, ABILITY_KEYS[_i], _i - 1, ABILITY_KEYS)
end
-- ▲ ReadonlyArray.reduce ▲
local DefaultAbilities = _result
return {
	isAbilityKey = isAbilityKey,
	ABILITY_KEYS = ABILITY_KEYS,
	AbilitiesMeta = AbilitiesMeta,
	DefaultAbilities = DefaultAbilities,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="26">
            <Properties>
              <string name="Name">Attributes</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        AttributeData.ts
	 * @module      AttributesDefinitions
	 * @author      Trembus
	 * @layer       Constants
	 * @description Canonical list of character attributes, their metadata,
	 *              and strongly-typed helpers for default values & validation.
	 *
	 * ╭──────────────────────────────╮
	 * │  Soul Steel · Coding Guide   │
	 * │  Fusion v4 · Strict TS · ECS │
	 * ╰──────────────────────────────╯
	 *
	 * @since        0.1.0
	 * @lastUpdated  2025-06-10 by Trembus
	 
]]
-- Attribute Keys
local ATTR_KEYS = { "str", "agi", "vit", "int", "lck" }
-- Key Type
-- Attribute Map Type
-- Data Transfer Object for Attributes
-- Attribute Metadata Interface
-- Attribute Metadata Records
local AttributesMeta = {
	str = {
		displayName = "Strength",
		iconId = "rbxassetid://127745571044516",
		min = 1,
		max = 999,
	},
	agi = {
		displayName = "Agility",
		iconId = "rbxassetid://73893872719367",
		min = 1,
		max = 999,
	},
	vit = {
		displayName = "Vitality",
		iconId = "rbxassetid://121291227474039",
		min = 1,
		max = 999,
	},
	int = {
		displayName = "Intellect",
		iconId = "rbxassetid://107600003376684",
		min = 1,
		max = 999,
	},
	lck = {
		displayName = "Luck",
		iconId = "rbxassetid://114767496083209",
		min = 1,
		max = 999,
	},
}
-- Default attributes with initial values
local _object = {
	AvailablePoints = 5,
	SpentPoints = 0,
}
-- ▼ ReadonlyArray.reduce ▼
local _result = {}
local _callback = function(obj, key)
	obj[key] = 10
	return obj
end
for _i = 1, #ATTR_KEYS do
	_result = _callback(_result, ATTR_KEYS[_i], _i - 1, ATTR_KEYS)
end
-- ▲ ReadonlyArray.reduce ▲
for _k, _v in _result do
	_object[_k] = _v
end
local DefaultAttributes = _object
-- Helper Functions
--* Clamp a single attribute into meta-defined bounds. 
local function clampAttr(key, value)
	local _binding = AttributesMeta[key]
	local min = _binding.min
	local max = _binding.max
	return math.clamp(value, min, max)
end
--* Produce a fresh default map, optionally overriding some keys. 
local function createAttributes(partial)
	local _object_1 = table.clone(DefaultAttributes)
	setmetatable(_object_1, nil)
	if partial then
		for _k, _v in partial do
			_object_1[_k] = _v
		end
	end
	return _object_1
end
return {
	clampAttr = clampAttr,
	createAttributes = createAttributes,
	ATTR_KEYS = ATTR_KEYS,
	AttributesMeta = AttributesMeta,
	DefaultAttributes = DefaultAttributes,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="27">
            <Properties>
              <string name="Name">Currency</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        Currency.ts
	 * @module      CurrencyDefinitions
	 * @layer       Shared/Data
	 * @description Canonical list of in-game currencies and their metadata.
	 
]]
local CURRENCY_KEY = { "GOLD", "SILVER", "BRONZE" }
local CurrencyMetaMap = {
	GOLD = {
		displayName = "Gold",
		iconId = "rbxassetid://1234567890",
	},
	SILVER = {
		displayName = "Silver",
		iconId = "rbxassetid://1234567891",
	},
	BRONZE = {
		displayName = "Bronze",
		iconId = "rbxassetid://1234567892",
	},
}
-- ▼ ReadonlyArray.reduce ▼
local _result = {}
local _callback = function(obj, key)
	obj[key] = 0
	return obj
end
for _i = 1, #CURRENCY_KEY do
	_result = _callback(_result, CURRENCY_KEY[_i], _i - 1, CURRENCY_KEY)
end
-- ▲ ReadonlyArray.reduce ▲
local DefaultCurrency = _result
return {
	CURRENCY_KEY = CURRENCY_KEY,
	CurrencyMetaMap = CurrencyMetaMap,
	DefaultCurrency = DefaultCurrency,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="28">
            <Properties>
              <string name="Name">Profile</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
-- shared/ProfileDataTypes.ts
local ProfileDataKeys = { "Abilities", "Attributes" }
--* Shape of each bucket inside the player’s ProfileService blob 
return {
	ProfileDataKeys = ProfileDataKeys,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="29">
            <Properties>
              <string name="Name">Settings</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        Settings.ts
	 * @module      SettingsDefinitions
	 * @layer       Constants
	 * @description Canonical list of player settings and metadata.
	 *
	 * ╭──────────────────────────────╮
	 * │  Soul Steel · Coding Guide   │
	 * │  Fusion v4 · Strict TS · ECS │
	 * ╰──────────────────────────────╯
	 *
	 * @since        0.2.1
	 * @lastUpdated  2025-07-03 by Codex – Initial creation
	 
]]
local SETTING_KEYS = { "musicEnabled", "showFps", "nickname" }
local SettingsMeta = {
	musicEnabled = {
		displayName = "Music",
		description = "Toggle background music on or off.",
		controlType = "boolean",
	},
	showFps = {
		displayName = "Show FPS",
		description = "Display the current frames per second.",
		controlType = "boolean",
	},
	nickname = {
		displayName = "Nickname",
		description = "Set a custom player nickname.",
		controlType = "string",
	},
}
local DefaultSettings = {
	musicEnabled = true,
	showFps = false,
	nickname = "",
}
return {
	SETTING_KEYS = SETTING_KEYS,
	SettingsMeta = SettingsMeta,
	DefaultSettings = DefaultSettings,
}
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="30">
          <Properties>
            <string name="Name">Rarity</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
local GameImages = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets").GameImages
--[[
	*
	 * @file        RarityData.ts
	 * @module      Rarity
	 * @layer       Shared/Data
	 * @description Enum types for gem rarity levels.
	 
]]
-- =============================================== Rarity Data Setup =============================================== 
-- RARITY KEYS
local RARITY_KEYS = { "Common", "Uncommon", "Rare", "Epic", "Legendary" }
-- Rarity Key Type
-- Rarity Metadata Interface
-- Rarity Metadata Records
local RarityMeta = {
	Common = {
		label = "Common",
		color = Color3.fromRGB(200, 200, 200),
		BorderImage = GameImages.Borders.GothicMetal,
	},
	Uncommon = {
		label = "Uncommon",
		color = Color3.fromRGB(100, 200, 100),
		BorderImage = GameImages.Borders.GothicMetal,
	},
	Rare = {
		label = "Rare",
		color = Color3.fromRGB(50, 100, 200),
		BorderImage = GameImages.Borders.GothicMetal,
	},
	Epic = {
		label = "Epic",
		color = Color3.fromRGB(200, 50, 200),
		BorderImage = GameImages.Borders.GothicMetal,
	},
	Legendary = {
		label = "Legendary",
		color = Color3.fromRGB(255, 215, 0),
		BorderImage = GameImages.Borders.GothicMetal,
	},
}
return {
	RARITY_KEYS = RARITY_KEYS,
	RarityMeta = RarityMeta,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="31">
          <Properties>
            <string name="Name">Resources</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        ResourceData.ts
	 * @module      ResourceData
	 * @author      Trembus
	 * @layer       Constants
	 * @description Canonical list of character Resources, their metadata,
	 *
	 * ╭──────────────────────────────╮
	 * │  Soul Steel · Coding Guide   │
	 * │  Fusion v4 · Strict TS · ECS │
	 * ╰──────────────────────────────╯
	 *
	 * @since        0.1.0
	 * @lastUpdated  2025-06-10 by Trembus
	 
]]
local _assets = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets")
local GameImages = _assets.GameImages
local GlassGradient = _assets.GlassGradient
local LavaGradient = _assets.LavaGradient
local OceanGradient = _assets.OceanGradient
-- Resource Keys
local RESOURCE_KEYS = { "Health", "Mana", "Stamina" }
-- Resource Types
-- Resource Metadata Interface
-- Resource Metadata Records
local ResourceMeta = {
	Health = {
		displayName = "Health",
		iconId = GameImages.Attributes.Vitality,
		gradient = LavaGradient(),
		layoutOrder = 1,
	},
	Mana = {
		displayName = "Mana",
		iconId = GameImages.Attributes.Intelligence,
		gradient = OceanGradient(),
		layoutOrder = 2,
	},
	Stamina = {
		displayName = "Stamina",
		iconId = GameImages.Attributes.Dexterity,
		gradient = GlassGradient(),
		layoutOrder = 3,
	},
}
local DEFAULT_RESOURCES = {
	Health = {
		current = 100,
		max = 100,
	},
	Mana = {
		current = 50,
		max = 50,
		regenPerSecond = 5,
	},
	Stamina = {
		current = 75,
		max = 75,
		regenPerSecond = 10,
	},
}
--* Type-safe lookup: returns meta & dto bundled for convenience 
local function getResourceBundle(key)
	return {
		key = key,
		meta = ResourceMeta[key],
		data = DEFAULT_RESOURCES[key],
	}
end
return {
	getResourceBundle = getResourceBundle,
	RESOURCE_KEYS = RESOURCE_KEYS,
	ResourceMeta = ResourceMeta,
	DEFAULT_RESOURCES = DEFAULT_RESOURCES,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="32">
          <Properties>
            <string name="Name">StatusEffect</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--[[
	*
	 * @file StatusEffect.ts
	 * @module StatusEffectDefinitions
	 * @layer Shared/Definitions
	 * @description Defines the structure and types for status effects in the game.
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 * @author Trembus
	 * @license MIT
	 * @since 0.2.0
	 * @lastUpdated 2025-07-03 by Trembus – Initial creation
	 
]]
local STATUS_EFFECT_KEYS = { "Poisoned", "Burning", "Frozen", "Stunned", "Raged", "Bleeding", "SpeedBoost", "Invulnerable", "PowerBoost", "JumpBoost" }
local StatusEffectMeta = {
	Poisoned = {
		displayName = "Poisoned",
		iconId = "rbxassetid://12345678",
		description = "Takes damage over time.",
		duration = 5,
		tickRate = 1,
		amount = -2,
	},
	Burning = {
		displayName = "Burning",
		iconId = "rbxassetid://23456789",
		description = "Takes fire damage over time.",
		duration = 5,
		tickRate = 1,
		amount = -3,
	},
	Frozen = {
		displayName = "Frozen",
		iconId = "rbxassetid://34567890",
		description = "Cannot move or attack.",
		duration = 3,
		tickRate = 0.5,
		amount = 0,
	},
	Stunned = {
		displayName = "Stunned",
		iconId = "rbxassetid://45678901",
		description = "Cannot perform actions.",
		duration = 2,
		tickRate = 0.5,
		amount = 0,
	},
	Raged = {
		displayName = "Raged",
		iconId = "rbxassetid://56789012",
		description = "Increases attack power.",
		duration = 5,
		tickRate = 1,
		amount = 5,
	},
	Bleeding = {
		displayName = "Bleeding",
		iconId = "rbxassetid://67890123",
		description = "Takes bleeding damage over time.",
		duration = 5,
		tickRate = 1,
		amount = -4,
	},
	SpeedBoost = {
		displayName = "Speed Boost",
		iconId = "rbxassetid://78901234",
		description = "Increases movement speed temporarily.",
		duration = 5,
		tickRate = 0.5,
		amount = 10,
	},
	Invulnerable = {
		displayName = "Invulnerable",
		iconId = "rbxassetid://89012345",
		description = "Cannot take damage.",
		duration = 5,
		tickRate = 0.5,
		amount = 0,
	},
	PowerBoost = {
		displayName = "Power Boost",
		iconId = "rbxassetid://90123456",
		description = "Increases damage dealt temporarily.",
		duration = 5,
		tickRate = 0.5,
		amount = 10,
	},
	JumpBoost = {
		displayName = "Jump Boost",
		iconId = "rbxassetid://01234567",
		description = "Increases jump height temporarily.",
		duration = 5,
		tickRate = 0.5,
		amount = 5,
	},
}
return {
	STATUS_EFFECT_KEYS = STATUS_EFFECT_KEYS,
	StatusEffectMeta = StatusEffectMeta,
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="33">
        <Properties>
          <string name="Name">network</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        index.ts
	 * @module      Network
	 * @layer       Shared
	 * @description Barrel export for network definitions.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.1.0
	 * @lastUpdated  2025-06-10 by Trembus – Initial creation
	 
]]
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "network", "Definitions") or {} do
	exports[_k] = _v
end
return exports
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="34">
          <Properties>
            <string name="Name">Definitions</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        Definitions.ts
	 * @module      NetworkDefinitions
	 * @layer       Shared/Network
	 * @description Typed network event definitions for the project.
	 
]]
-- =============================================== Imports =============================================== 
local Net = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "net", "out")
--[[
	
	 * Generic helpers ────────────────────────────────────────────────
	 *   - K is inferred from the call, e.g. "Stats"
	 *   - Net’s “Function” wrapper enforces argument/return parity
	 
]]
-- =============================================== Network Definitions =============================================== 
local Network = Net.Definitions.Create({
	SpawnManifestation = Net.Definitions.ClientToServerEvent(),
	IncreaseAttribute = Net.Definitions.ClientToServerEvent(),
	AddGem = Net.Definitions.ClientToServerEvent(),
	JoinRoom = Net.Definitions.ClientToServerEvent(),
	SetActiveGem = Net.Definitions.ClientToServerEvent(),
	GetPlayerSettings = Net.Definitions.ServerFunction(),
	UpdatePlayerSetting = Net.Definitions.ClientToServerEvent(),
	CreateRoom = Net.Definitions.ServerFunction(),
	ProfileChanged = Net.Definitions.ServerToClientEvent(),
	RoomCountdown = Net.Definitions.ServerToClientEvent(),
	ActivateAbility = Net.Definitions.ClientToServerEvent(),
})
local TestNetwork = Net.Definitions.Create({
	SPAWN_NPC = Net.Definitions.ClientToServerEvent(),
})
local ClientDispatch = Net.Definitions.Create({
	IncreaseAttribute = Net.Definitions.ClientToServerEvent(),
	ActivateAbility = Net.Definitions.ClientToServerEvent(),
	GetData = Net.Definitions.ServerFunction(),
})
local ServerDispatch = Net.Definitions.Create({
	ResourceUpdated = Net.Definitions.ServerToClientEvent(),
	AbilitiesUpdated = Net.Definitions.ServerToClientEvent(),
})
return {
	Network = Network,
	TestNetwork = TestNetwork,
	ClientDispatch = ClientDispatch,
	ServerDispatch = ServerDispatch,
}
]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
    <Item class="Folder" referent="35">
      <Properties>
        <string name="Name">rbxts_include</string>
      </Properties>
      <Item class="ModuleScript" referent="36">
        <Properties>
          <string name="Name">Promise</string>
          <string name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- The executor thread.
		_thread = nil,

		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	self._thread = coroutine.create(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)

	task.spawn(self._thread)

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	:::caution
	If the Promise is cancelled, the `executor` thread is closed with `coroutine.close` after the cancellation hook is called.

	You must perform any cleanup code in the cancellation hook: any time your executor yields, it **may never resume**.
	:::

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- If we are already cancelled, we return a cancelled Promise
	if self._status == Promise.Status.Cancelled then
		local promise = Promise.new(function() end)
		promise:cancel()

		return promise
	end

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)

			onCancel(function()
				-- These are guaranteed to exist because the cancellation handler is guaranteed to only
				-- be called at most once
				if self._status == Promise.Status.Started then
					table.remove(self._queuedResolve, table.find(self._queuedResolve, successCallback))
					table.remove(self._queuedReject, table.find(self._queuedReject, failureCallback))
				end
			end)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	You can return a Promise from the success or failure handler and it will be chained onto.

	Calling `andThen` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `andThen` is cancelled, `successHandler` and `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Calling `catch` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `catch` is cancelled,  `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	coroutine.close(self._thread)

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled.
]]
function Promise.prototype:_finally(traceback, finallyHandler)
	self._unhandledRejection = false

	local promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local handlerPromise

		onCancel(function()
			-- The finally Promise is not a proper consumer of self. We don't care about the resolved value.
			-- All we care about is running at the end. Therefore, if self has no other consumers, it's safe to
			-- cancel. We don't need to hold out cancelling just because there's a finally handler.
			self:_consumerCancelled(self)

			if handlerPromise then
				handlerPromise:cancel()
			end
		end)

		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = function(...)
				local callbackReturn = finallyHandler(...)

				if Promise.is(callbackReturn) then
					handlerPromise = callbackReturn

					callbackReturn
						:finally(function(status)
							if status ~= Promise.Status.Rejected then
								resolve(self)
							end
						end)
						:catch(function(...)
							reject(...)
						end)
				else
					resolve(self)
				end
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end)

	return promise
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is
	resolved, rejected, *or* cancelled.

	Returns a new Promise that:
	- resolves with the same values that this Promise resolves with.
	- rejects with the same values that this Promise rejects with.
	- is cancelled if this Promise is cancelled.

	If the value you return from the handler is a Promise:
	- We wait for the Promise to resolve, but we ultimately discard the resolved value.
	- If the returned Promise rejects, the Promise returned from `finally` will reject with the rejected value from the
	*returned* promise.
	- If the `finally` Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too.

	Otherwise, the return value from the `finally` handler is entirely discarded.

	:::note Cancellation
	As of Promise v4, `Promise:finally` does not count as a consumer of the parent Promise for cancellation purposes.
	This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers,
	the Promise is cancelled and the finally callbacks run then and there.

	Cancellation still propagates through the `finally` Promise though: if you cancel the `finally` Promise, it can cancel
	its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the `finally` Promise
	will also be cancelled.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local thread = coroutine.running()

		self
			:finally(function()
				task.spawn(thread)
			end)
			-- The finally promise can propagate rejections, so we attach a catch handler to prevent the unhandled
			-- rejection warning from appearing
			:catch(
				function() end
			)

		coroutine.yield()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end

	task.defer(coroutine.close, self._thread)
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="37">
        <Properties>
          <string name="Name">RuntimeLib</string>
          <string name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

local RunService = game:GetService("RunService")

local OUTPUT_PREFIX = "roblox-ts: "
local NODE_MODULES = "node_modules"
local DEFAULT_SCOPE = "@rbxts"

local TS = {}

TS.Promise = Promise

local function isPlugin(context)
	return RunService:IsStudio() and context:FindFirstAncestorWhichIsA("Plugin") ~= nil
end

function TS.getModule(context, scope, moduleName)
	-- legacy call signature
	if moduleName == nil then
		moduleName = scope
		scope = DEFAULT_SCOPE
	end

	-- ensure modules have fully replicated
	if RunService:IsRunning() and RunService:IsClient() and not isPlugin(context) and not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local object = context
	repeat
		local nodeModulesFolder = object:FindFirstChild(NODE_MODULES)
		if nodeModulesFolder then
			local scopeFolder = nodeModulesFolder:FindFirstChild(scope)
			if scopeFolder then
				local module = scopeFolder:FindFirstChild(moduleName)
				if module then
					return module
				end
			end
		end
		object = object.Parent
	until object == nil

	error(OUTPUT_PREFIX .. "Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local currentlyLoading = {}
local registeredLibraries = {}

function TS.import(context, module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName ~= "ModuleScript" then
		error(OUTPUT_PREFIX .. "Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end

	currentlyLoading[context] = module

	-- Check to see if a case like this occurs:
	-- module -> Module1 -> Module2 -> module

	-- WHERE currentlyLoading[module] is Module1
	-- and currentlyLoading[Module1] is Module2
	-- and currentlyLoading[Module2] is module

	local currentModule = module
	local depth = 0

	while currentModule do
		depth = depth + 1
		currentModule = currentlyLoading[currentModule]

		if currentModule == module then
			local str = currentModule.Name -- Get the string traceback

			for _ = 1, depth do
				currentModule = currentlyLoading[currentModule]
				str = str .. "  ⇒ " .. currentModule.Name
			end

			error(OUTPUT_PREFIX .. "Failed to import! Detected a circular dependency chain: " .. str, 2)
		end
	end

	if not registeredLibraries[module] then
		if _G[module] then
			error(
				OUTPUT_PREFIX
				.. "Invalid module access! Do you have multiple TS runtimes trying to import this? "
				.. module:GetFullName(),
				2
			)
		end

		_G[module] = TS
		registeredLibraries[module] = true -- register as already loaded for subsequent calls
	end

	local data = require(module)

	if currentlyLoading[context] == module then -- Thread-safe cleanup!
		currentlyLoading[context] = nil
	end

	return data
end

function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local status, value = promise:awaitStatus()
	if status == Promise.Status.Resolved then
		return value
	elseif status == Promise.Status.Rejected then
		error(value, 2)
	else
		error("The awaited Promise was cancelled", 2)
	end
end

local SIGN = 2 ^ 31
local COMPLEMENT = 2 ^ 32
local function bit_sign(num)
	-- Restores the sign after an unsigned conversion according to 2s complement.
	if bit32.btest(num, SIGN) then
		return num - COMPLEMENT
	else
		return num
	end
end

function TS.bit_lrsh(a, b)
	return bit_sign(bit32.arshift(a, b))
end

TS.TRY_RETURN = 1
TS.TRY_BREAK = 2
TS.TRY_CONTINUE = 3

function TS.try(try, catch, finally)
	-- execute try
	local trySuccess, exitTypeOrTryError, returns = pcall(try)
	local exitType, tryError
	if trySuccess then
		exitType = exitTypeOrTryError
	else
		tryError = exitTypeOrTryError
	end

	local catchSuccess = true
	local catchError

	-- if try block failed, and catch block exists, execute catch
	if not trySuccess and catch then
		local newExitTypeOrCatchError, newReturns
		catchSuccess, newExitTypeOrCatchError, newReturns = pcall(catch, tryError)
		local newExitType
		if catchSuccess then
			newExitType = newExitTypeOrCatchError
		else
			catchError = newExitTypeOrCatchError
		end

		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end

	-- execute finally
	if finally then
		local newExitType, newReturns = finally()
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end

	-- if exit type is a control flow, do not rethrow errors
	if exitType ~= TS.TRY_RETURN and exitType ~= TS.TRY_BREAK and exitType ~= TS.TRY_CONTINUE then
		-- if catch block threw an error, rethrow it
		if not catchSuccess then
			error(catchError, 2)
		end

		-- if try block threw an error and there was no catch block, rethrow it
		if not trySuccess and not catch then
			error(tryError, 2)
		end
	end

	return exitType, returns
end

function TS.generator(callback)
	local co = coroutine.create(callback)
	return {
		next = function(...)
			if coroutine.status(co) == "dead" then
				return { done = true }
			else
				local success, value = coroutine.resume(co, ...)
				if success == false then
					error(value, 2)
				end
				return {
					value = value,
					done = coroutine.status(co) == "dead",
				}
			end
		end,
	}
end

return TS
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="38">
        <Properties>
          <string name="Name">node_modules</string>
        </Properties>
        <Item class="Folder" referent="39">
          <Properties>
            <string name="Name">@rbxts</string>
          </Properties>
          <Item class="Folder" referent="40">
            <Properties>
              <string name="Name">cmdr</string>
            </Properties>
            <Item class="ModuleScript" referent="41">
              <Properties>
                <string name="Name">Cmdr</string>
                <string name="Source">local RunService = game:GetService("RunService")
local Util = require(script.Shared:WaitForChild("Util"))

if RunService:IsServer() == false then
	error("Cmdr server module is somehow running on a client!")
end

local Cmdr do
	Cmdr = setmetatable({
		ReplicatedRoot = nil;
		RemoteFunction = nil;
		RemoteEvent = nil;
		Util = Util;
		DefaultCommandsFolder = script.BuiltInCommands;
	}, {
		__index = function (self, k)
			local r = self.Registry[k]
			if r and type(r) == "function" then
				return function (_, ...)
					return r(self.Registry, ...)
				end
			end
		end
	})

	Cmdr.Registry = require(script.Shared.Registry)(Cmdr)
	Cmdr.Dispatcher = require(script.Shared.Dispatcher)(Cmdr)

	require(script.Initialize)(Cmdr)
end

-- Handle command invocations from the clients.
Cmdr.RemoteFunction.OnServerInvoke = function (player, text, options)
	if #text > 100_000 then
		return "Input too long"
	end

	return Cmdr.Dispatcher:EvaluateAndRun(text, player, options)
end

return Cmdr</string>
              </Properties>
              <Item class="Folder" referent="42">
                <Properties>
                  <string name="Name">BuiltInCommands</string>
                </Properties>
                <Item class="Folder" referent="43">
                  <Properties>
                    <string name="Name">Admin</string>
                  </Properties>
                  <Item class="ModuleScript" referent="44">
                    <Properties>
                      <string name="Name">announce</string>
                      <string name="Source">return {
	Name = "announce";
	Aliases = {"m"};
	Description = "Makes a server-wide announcement.";
	Group = "DefaultAdmin";
	Args = {
		{
			Type = "string";
			Name = "text";
			Description = "The announcement text.";
		},
	};
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="45">
                    <Properties>
                      <string name="Name">announceServer</string>
                      <string name="Source">local TextService = game:GetService("TextService")
local Players = game:GetService("Players")
local Chat = game:GetService("Chat")

return function (context, text)
	local filterResult = TextService:FilterStringAsync(text, context.Executor.UserId, Enum.TextFilterContext.PublicChat)

	for _, player in ipairs(Players:GetPlayers()) do
		if Chat:CanUsersChatAsync(context.Executor.UserId, player.UserId) then
			context:SendEvent(player, "Message", filterResult:GetChatForUserAsync(player.UserId), context.Executor)
		end
	end

	return "Created announcement."
end</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="46">
                    <Properties>
                      <string name="Name">gotoPlace</string>
                      <string name="Source">return {
	Name = "goto-place";
	Aliases = {};
	Description = "Teleport to a Roblox place";
	Group = "DefaultAdmin";
	AutoExec = {
		"alias \"follow-player|Join a player in another server\" goto-place $1{players|Players} ${{get-player-place-instance $2{playerId|Target}}}",
		"alias \"rejoin|Rejoin this place. You might end up in a different server.\" goto-place $1{players|Players} ${get-player-place-instance ${me} PlaceId}"
	};
	Args = {
		{
			Type = "players";
			Name = "Players";
			Description = "The players you want to teleport";
		},
		{
			Type = "integer";
			Name = "Place ID";
			Description = "The Place ID you want to teleport to";
		},
		{
			Type = "string";
			Name = "JobId";
			Description = "The specific JobId you want to teleport to";
			Optional = true;
		}
	};
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="47">
                    <Properties>
                      <string name="Name">gotoPlaceServer</string>
                      <string name="Source"><![CDATA[local TeleportService = game:GetService("TeleportService")

return function(context, players, placeId, jobId)
	players = players or { context.Executor }

	if placeId <= 0 then
		return "Invalid place ID"
	elseif jobId == "-" then
		return "Invalid job ID"
	end

	context:Reply("Commencing teleport...")

	if jobId then
		for _, player in ipairs(players) do
			TeleportService:TeleportToPlaceInstance(placeId, jobId, player)
		end
	else
		TeleportService:TeleportAsync(placeId, players)
	end

	return "Teleported."
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="48">
                    <Properties>
                      <string name="Name">kick</string>
                      <string name="Source">return {
	Name = "kick";
	Aliases = {"boot"};
	Description = "Kicks a player or set of players.";
	Group = "DefaultAdmin";
	Args = {
		{
			Type = "players";
			Name = "players";
			Description = "The players to kick.";
		},
	};
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="49">
                    <Properties>
                      <string name="Name">kickServer</string>
                      <string name="Source">return function (_, players)
	for _, player in pairs(players) do
		player:Kick("Kicked by admin.")
	end

	return ("Kicked %d players."):format(#players)
end</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="50">
                    <Properties>
                      <string name="Name">kill</string>
                      <string name="Source">return {
	Name = "kill";
	Aliases = {"slay"};
	Description = "Kills a player or set of players.";
	Group = "DefaultAdmin";
	Args = {
		{
			Type = "players";
			Name = "victims";
			Description = "The players to kill.";
		},
	};
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="51">
                    <Properties>
                      <string name="Name">killServer</string>
                      <string name="Source">return function (_, players)
	for _, player in pairs(players) do
		if player.Character then
			player.Character:BreakJoints()
		end
	end

	return ("Killed %d players."):format(#players)
end</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="52">
                    <Properties>
                      <string name="Name">respawn</string>
                      <string name="Source"><![CDATA[return {
	Name = "respawn";
	Description = "Respawns a player or a group of players.";
	Group = "DefaultAdmin";
	AutoExec = {
		"alias \"refresh|Respawns the player and returns them to their previous location.\" var= .refresh_pos ${position $1{player|Player}} && respawn $1 && tp $1 @${{var .refresh_pos}}"
	},
	Args = {
		{
			Type = "players";
			Name = "targets";
			Description = "The players to respawn."
		}
	}
}
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="53">
                    <Properties>
                      <string name="Name">respawnServer</string>
                      <string name="Source"><![CDATA[return function(_, players)
	for _, player in pairs(players) do
		if player.Character then
			player:LoadCharacter()
		end
	end
	return ("Respawned %d players."):format(#players)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="54">
                    <Properties>
                      <string name="Name">teleport</string>
                      <string name="Source">return {
	Name = "teleport";
	Aliases = {"tp"};
	Description = "Teleports a player or set of players to one target.";
	Group = "DefaultAdmin";
	AutoExec = {
		"alias \"bring|Brings a player or set of players to you.\" teleport $1{players|players|The players to bring} ${me}";
		"alias \"to|Teleports you to another player or location.\" teleport ${me} $1{player @ vector3|Destination|The player or location to teleport to}";
	};
	Args = {
		{
			Type = "players";
			Name = "From";
			Description = "The players to teleport";
		},
		{
			Type = "player @ vector3";
			Name = "Destination";
			Description = "The player to teleport to"
		}
	};
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="55">
                    <Properties>
                      <string name="Name">teleportServer</string>
                      <string name="Source"><![CDATA[return function (_, fromPlayers, destination)
	local cframe

	if typeof(destination) == "Instance" then
		if destination.Character and destination.Character:FindFirstChild("HumanoidRootPart") then
			cframe = destination.Character.HumanoidRootPart.CFrame
		else
			return "Target player has no character."
		end
	elseif typeof(destination) == "Vector3" then
		cframe = CFrame.new(destination)
	end

	for _, player in ipairs(fromPlayers) do
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			player.Character.HumanoidRootPart.CFrame = cframe
		end
	end

	return ("Teleported %d players."):format(#fromPlayers)
end
]]></string>
                    </Properties>
                  </Item>
                </Item>
                <Item class="Folder" referent="56">
                  <Properties>
                    <string name="Name">Debug</string>
                  </Properties>
                  <Item class="ModuleScript" referent="57">
                    <Properties>
                      <string name="Name">blink</string>
                      <string name="Source">return {
	Name = "blink";
	Aliases = {"b"};
	Description = "Teleports you to where your mouse is hovering.";
	Group = "DefaultDebug";
	Args = {};

	ClientRun = function(context)
		-- We implement this here because player position is owned by the client.
		-- No reason to bother the server for this!

		local mouse = context.Executor:GetMouse()
		local character = context.Executor.Character

		if not character then
			return "You don't have a character."
		end

		character:MoveTo(mouse.Hit.p)

		return "Blinked!"
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="58">
                    <Properties>
                      <string name="Name">fetch</string>
                      <string name="Source">return {
	Name = "fetch";
	Aliases = {};
	Description = "Fetch a value from the Internet";
	Group = "DefaultDebug";
	Args = {
		{
			Type = "url";
			Name = "URL";
			Description = "The URL to fetch.";
		}
	};
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="59">
                    <Properties>
                      <string name="Name">fetchServer</string>
                      <string name="Source">local HttpService = game:GetService("HttpService")

return function (_, url)
	return HttpService:GetAsync(url)
end</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="60">
                    <Properties>
                      <string name="Name">getPlayerPlaceInstance</string>
                      <string name="Source">return {
	Name = "get-player-place-instance";
	Aliases = {};
	Description = "Returns the target player's Place ID and the JobId separated by a space. Returns 0 if the player is offline or something else goes wrong.";
	Group = "DefaultDebug";
	Args = {
		{
			Type = "playerId";
			Name = "Player";
			Description = "Get the place instance of this player";
		},
		function(context)
			return {
				Type = context.Cmdr.Util.MakeEnumType("PlaceInstance Format", {"PlaceIdJobId", "PlaceId", "JobId"}),
				Name = "Format";
				Description = "What data to return. PlaceIdJobId returns both separated by a space.";
				Default = "PlaceIdJobId";
			}
		end
	};
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="61">
                    <Properties>
                      <string name="Name">getPlayerPlaceInstanceServer</string>
                      <string name="Source">local TeleportService = game:GetService("TeleportService")

return function (_, playerId, format)
	format = format or "PlaceIdJobId"

	local ok, _, errorText, placeId, jobId = pcall(function()
		return TeleportService:GetPlayerPlaceInstanceAsync(playerId)
	end)

	if not ok or (errorText and #errorText > 0) then
		if format == "PlaceIdJobId" then
			return "0" .. " -"
		elseif format == "PlaceId" then
			return "0"
		elseif format == "JobId" then
			return "-"
		end
	end

	if format == "PlaceIdJobId" then
		return placeId .. " " .. jobId
	elseif format == "PlaceId" then
		return tostring(placeId)
	elseif format == "JobId" then
		return tostring(jobId)
	end
end</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="62">
                    <Properties>
                      <string name="Name">position</string>
                      <string name="Source">local Players = game:GetService("Players")

return {
	Name = "position";
	Aliases = {"pos"};
	Description = "Returns Vector3 position of you or other players. Empty string is the player has no character.";
	Group = "DefaultDebug";
	Args = {
		{
			Type = "player";
			Name = "Player";
			Description = "The player to report the position of. Omit for your own position.";
			Default = Players.LocalPlayer;
		}
	};

	ClientRun = function(_, player)
		local character = player.Character

		if not character or not character:FindFirstChild("HumanoidRootPart") then
			return ""
		end

		return tostring(character.HumanoidRootPart.Position):gsub("%s", "")
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="63">
                    <Properties>
                      <string name="Name">thru</string>
                      <string name="Source">return {
	Name = "thru";
	Aliases = {"t", "through"};
	Description = "Teleports you through whatever your mouse is hovering over, placing you equidistantly from the wall.";
	Group = "DefaultDebug";
	Args = {
		{
			Type = "number";
			Name = "Extra distance";
			Description = "Go through the wall an additional X studs.";
			Default = 0;
		}
	};

	ClientRun = function(context, extra)
		-- We implement this here because player position is owned by the client.
		-- No reason to bother the server for this!

		local mouse = context.Executor:GetMouse()
		local character = context.Executor.Character

		if not character or not character:FindFirstChild("HumanoidRootPart") then
			return "You don't have a character."
		end

		local pos = character.HumanoidRootPart.Position
		local diff = (mouse.Hit.p - pos)

		character:MoveTo((diff * 2) + (diff.unit * extra) + pos)

		return "Blinked!"
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="64">
                    <Properties>
                      <string name="Name">uptime</string>
                      <string name="Source">return {
	Name = "uptime";
	Aliases = {};
	Description = "Returns the amount of time the server has been running.";
	Group = "DefaultDebug";
	Args = {};
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="65">
                    <Properties>
                      <string name="Name">uptimeServer</string>
                      <string name="Source">local startTime = os.time()

return function ()
	local uptime = os.time() - startTime
	return ("%dd %dh %dm %ds"):format(
		math.floor(uptime / (60 * 60 * 24)),
		math.floor(uptime / (60 * 60)) % 24,
		math.floor(uptime / 60) % 60,
		math.floor(uptime) % 60
	)
end</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="66">
                    <Properties>
                      <string name="Name">version</string>
                      <string name="Source"><![CDATA[local version = "v1.12.0"

return {
	Name = "version",
	Args = {},
	Description = "Shows the current version of Cmdr",
	Group = "DefaultDebug",

	Run = function()
		return ("Cmdr Version %s"):format(version)
	end,
}
]]></string>
                    </Properties>
                  </Item>
                </Item>
                <Item class="Folder" referent="67">
                  <Properties>
                    <string name="Name">Utility</string>
                  </Properties>
                  <Item class="ModuleScript" referent="68">
                    <Properties>
                      <string name="Name">alias</string>
                      <string name="Source">return {
	Name = "alias";
	Aliases = {};
	Description = "Creates a new, single command out of a command and given arguments.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Alias name";
			Description = "The key or input type you'd like to bind the command to."
		},
		{
			Type = "string";
			Name = "Command string";
			Description = "The command text you want to run. Separate multiple commands with \"&amp;&amp;\". Accept arguments with $1, $2, $3, etc."
		},
	};

	ClientRun = function(context, name, commandString)
		context.Cmdr.Registry:RegisterCommandObject(
			context.Cmdr.Util.MakeAliasCommand(name, commandString),
			true
		)

		return ("Created alias %q"):format(name)
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="69">
                    <Properties>
                      <string name="Name">bind</string>
                      <string name="Source">local UserInputService = game:GetService("UserInputService")

return {
	Name = "bind";
	Aliases = {};
	Description = "Binds a command string to a key or mouse input.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "userInput ! bindableResource @ player";
			Name = "Input";
			Description = "The key or input type you'd like to bind the command to."
		},
		{
			Type = "command";
			Name = "Command";
			Description = "The command you want to run on this input"
		},
		{
			Type = "string";
			Name = "Arguments";
			Description = "The arguments for the command";
			Default = "";
		}
	};

	ClientRun = function(context, bind, command, arguments)
		local binds = context:GetStore("CMDR_Binds")

		command = command .. " " .. arguments

		if binds[bind] then
			binds[bind]:Disconnect()
		end

		local bindType = context:GetArgument(1).Type.Name

		if bindType == "userInput" then
			binds[bind] = UserInputService.InputBegan:Connect(function(input, gameProcessed)
				if gameProcessed then
					return
				end

				if input.UserInputType == bind or input.KeyCode == bind then
					context:Reply(context.Dispatcher:EvaluateAndRun(context.Cmdr.Util.RunEmbeddedCommands(context.Dispatcher, command)))
				end
			end)
		elseif bindType == "bindableResource" then
			return "Unimplemented..."
		elseif bindType == "player" then
			binds[bind] = bind.Chatted:Connect(function(message)
				local args = { message }
				local chatCommand = context.Cmdr.Util.RunEmbeddedCommands(context.Dispatcher, context.Cmdr.Util.SubstituteArgs(command, args))
				context:Reply(("%s $ %s : %s"):format(
					bind.Name,
					chatCommand,
					context.Dispatcher:EvaluateAndRun(chatCommand)
				), Color3.fromRGB(244, 92, 66))
			end)
		end


		return "Bound command to input."
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="70">
                    <Properties>
                      <string name="Name">clear</string>
                      <string name="Source"><![CDATA[local Players = game:GetService("Players")

return {
	Name = "clear",
	Aliases = {},
	Description = "Clear all lines above the entry line of the Cmdr window.",
	Group = "DefaultUtil",
	Args = {},
	ClientRun = function()
		local player = Players.LocalPlayer
		local gui = player:WaitForChild("PlayerGui"):WaitForChild("Cmdr")
		local frame = gui:WaitForChild("Frame")

		if gui and frame then
			for _, child in pairs(frame:GetChildren()) do
				if child.Name == "Line" and child:IsA("TextBox") then
					child:Destroy()
				end
			end
		end
		return ""
	end
}
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="71">
                    <Properties>
                      <string name="Name">convertTimestamp</string>
                      <string name="Source"><![CDATA[return {
	Name = "convertTimestamp";
	Aliases = { "date" },
	Description = "Convert a timestamp to a human-readable format.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "number";
			Name = "timestamp";
			Description = "A numerical representation of a specific moment in time.";
			Optional = true
		}
	};
	ClientRun = function(_, timestamp)
		timestamp = timestamp or os.time()
		return `{os.date("%x", timestamp)} {os.date("%X", timestamp)}`
	end
}
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="72">
                    <Properties>
                      <string name="Name">echo</string>
                      <string name="Source">return {
	Name = "echo";
	Aliases = {"="};
	Description = "Echoes your text back to you.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Text";
			Description = "The text."
		},
	};

	Run = function(_, text)
		return text
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="73">
                    <Properties>
                      <string name="Name">edit</string>
                      <string name="Source">local Players = game:GetService("Players")

local TEXT_BOX_PROPERTIES = {
	AnchorPoint = Vector2.new(0.5, 0.5),
	BackgroundColor3 = Color3.fromRGB(17, 17, 17),
	BackgroundTransparency = 0.05,
	BorderColor3 = Color3.fromRGB(17, 17, 17),
	BorderSizePixel = 20,
	ClearTextOnFocus = false,
	MultiLine = true,
	Position = UDim2.new(0.5, 0, 0.5, 0),
	Size = UDim2.new(0.5, 0, 0.4, 0),
	Font = Enum.Font.Code,
	TextColor3 = Color3.fromRGB(241, 241, 241),
	TextWrapped = true,
	TextSize = 18,
	TextXAlignment = "Left",
	TextYAlignment = "Top",
	AutoLocalize = false,
	PlaceholderText = "Right click to exit",
}

local lock

return {
	Name = "edit";
	Aliases = {};
	Description = "Edit text in a TextBox";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Input text";
			Description = "The text you wish to edit";
			Default = "";
		},
		{
			Type = "string";
			Name = "Delimiter";
			Description = "The character that separates each line";
			Default = ",";
		}
	};

	ClientRun = function(context, text, delimeter)
		lock = lock or context.Cmdr.Util.Mutex()

		local unlock = lock()

		context:Reply("Right-click on the text area to exit.", Color3.fromRGB(158, 158, 158))

		local screenGui = Instance.new("ScreenGui")
		screenGui.Name = "CmdrEditBox"
		screenGui.ResetOnSpawn = false

		local textBox = Instance.new("TextBox")

		for key, value in pairs(TEXT_BOX_PROPERTIES) do
			textBox[key] = value
		end

		textBox.Text = text:gsub(delimeter, "\n")
		textBox.Parent = screenGui

		screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")

		local thread = coroutine.running()

		textBox.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton2 then
				coroutine.resume(thread, textBox.Text:gsub("\n", delimeter))
				screenGui:Destroy()
				unlock()
			end
		end)

		return coroutine.yield()
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="74">
                    <Properties>
                      <string name="Name">history</string>
                      <string name="Source">return {
	Name = "history";
	Aliases = {};
	AutoExec = {
		"alias \"!|Displays previous command from history.\" run ${history $1{number|Line Number}}";
		"alias \"^|Runs the previous command, replacing all occurrences of A with B.\" run ${run replace ${history -1} $1{string|A} $2{string|B}}";
		"alias \"!!|Reruns the last command.\" ! -1";
	};
	Description = "Displays previous commands from history.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "integer";
			Name = "Line Number";
			Description = "Command line number (can be negative to go from end)"
		},
	};

	ClientRun = function(context, line)
		local history = context.Dispatcher:GetHistory()

		if line &lt;= 0 then
			line = #history + line
		end

		return history[line] or ""
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="75">
                    <Properties>
                      <string name="Name">hover</string>
                      <string name="Source">local Players = game:GetService("Players")

return {
	Name = "hover";
	Description = "Returns the name of the player you are hovering over.";
	Group = "DefaultUtil";
	Args = {};

	ClientRun = function()
		local mouse = Players.LocalPlayer:GetMouse()
		local target = mouse.Target

		if not target then
			return ""
		end

		local p = Players:GetPlayerFromCharacter(target:FindFirstAncestorOfClass("Model"))

		return p and p.Name or ""
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="76">
                    <Properties>
                      <string name="Name">jsonArrayDecode</string>
                      <string name="Source"><![CDATA[return {
	Name = "json-array-decode";
	Aliases = {};
	Description = "Decodes a JSON Array into a comma-separated list";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "json";
			Name = "JSON";
			Description = "The JSON array."
		},
	};

	ClientRun = function(_, value)
		if type(value) ~= "table" then
			value = { value }
		end

		return table.concat(value, ",")
	end
}
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="77">
                    <Properties>
                      <string name="Name">jsonArrayEncode</string>
                      <string name="Source">local HttpService = game:GetService("HttpService")

return {
	Name = "json-array-encode";
	Aliases = {};
	Description = "Encodes a comma-separated list into a JSON array";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "CSV";
			Description = "The comma-separated list"
		},
	};

	Run = function(_, text)
		return HttpService:JSONEncode(text:split(","))
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="78">
                    <Properties>
                      <string name="Name">len</string>
                      <string name="Source">return {
	Name = "len";
	Aliases = {};
	Description = "Returns the length of a comma-separated list";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "CSV";
			Description = "The comma-separated list"
		}
	};

	Run = function(_, list)
		return #(list:split(","))
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="79">
                    <Properties>
                      <string name="Name">math</string>
                      <string name="Source"><![CDATA[return {
	Name = "math";
	Aliases = {};
	Description = "Perform a math operation on 2 values.";
	Group = "DefaultUtil";
	AutoExec = {
		"alias \"+|Perform an addition.\" math + $1{number|Number} $2{number|Number}";
		"alias \"-|Perform a subtraction.\" math - $1{number|Number} $2{number|Number}";
		"alias \"*|Perform a multiplication.\" math * $1{number|Number} $2{number|Number}";
		"alias \"/|Perform a division.\" math / $1{number|Number} $2{number|Number}";
		"alias \"**|Perform an exponentiation.\" math ** $1{number|Number} $2{number|Number}";
		"alias \"%|Perform a modulus.\" math % $1{number|Number} $2{number|Number}";
	};
	Args = {
		{
			Type = "mathOperator";
			Name = "Operation";
			Description = "A math operation."
		};
		{
			Type = "number";
			Name = "Value";
			Description = "A number value."
		};
		{
			Type = "number";
			Name = "Value";
			Description = "A number value."
		}
	};

	ClientRun = function(_, operation, a, b)
		return operation.Perform(a, b)
	end
}
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="80">
                    <Properties>
                      <string name="Name">pick</string>
                      <string name="Source">return {
	Name = "pick";
	Aliases = {};
	Description = "Picks a value out of a comma-separated list.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "integer";
			Name = "Index to pick";
			Description = "The index of the item you want to pick";
		},
		{
			Type = "string";
			Name = "CSV";
			Description = "The comma-separated list"
		}
	};

	Run = function(_, index, list)
		return list:split(",")[index] or ""
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="81">
                    <Properties>
                      <string name="Name">rand</string>
                      <string name="Source">return {
	Name = "rand";
	Aliases = {};
	Description = "Returns a random number between min and max";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "integer";
			Name = "First number";
			Description = "If second number is nil, random number is between 1 and this value. If second number is provided, number is between this number and the second number."
		},
		{
			Type = "integer";
			Name = "Second number";
			Description = "The upper bound.";
			Optional = true;
		}
	};

	Run = function(_, min, max)
		return tostring(max and math.random(min, max) or math.random(min))
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="82">
                    <Properties>
                      <string name="Name">replace</string>
                      <string name="Source">return {
	Name = "replace";
	Aliases = {"gsub", "//"};
	Description = "Replaces text A with text B";
	Group = "DefaultUtil";
	AutoExec = {
		"alias \"map|Maps a CSV into another CSV\" replace $1{string|CSV} ([^,]+) \"$2{string|mapped value|Use %1 to insert the element}\"",
		"alias \"join|Joins a CSV with a specified delimiter\" replace $1{string|CSV} , $2{string|Delimiter}"
	},
	Args = {
		{
			Type = "string";
			Name = "Haystack";
			Description = "The source string upon which to perform replacement."
		},
		{
			Type = "string";
			Name = "Needle";
			Description = "The string pattern search for."
		},
		{
			Type = "string";
			Name = "Replacement";
			Description = "The string to replace matches (%1 to insert matches).";
			Default = "";
		},
	};

	Run = function(_, haystack, needle, replacement)
		return haystack:gsub(needle, replacement)
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="83">
                    <Properties>
                      <string name="Name">resolve</string>
                      <string name="Source">return {
	Name = "resolve";
	Aliases = {};
	Description = "Resolves Argument Value Operators into lists. E.g., resolve players * gives you a list of all players.";
	Group = "DefaultUtil";
	AutoExec = {
		"alias \"me|Displays your username\" resolve players ."
	};
	Args = {
		{
			Type = "type";
			Name = "Type";
			Description = "The type for which to resolve"
		},
		function (context)
			if context:GetArgument(1):Validate() == false then
				return
			end

			return {
				Type = context:GetArgument(1):GetValue();
				Name = "Argument Value Operator";
				Description = "The value operator to resolve. One of: * ** . ? ?N";
				Optional = true;
			}
		end
	};

	Run = function(context)
		return table.concat(context:GetArgument(2).RawSegments, ",")
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="84">
                    <Properties>
                      <string name="Name">run</string>
                      <string name="Source">return {
	Name = "run";
	Aliases = {">"};
	AutoExec = {
		"alias \"discard|Run a command and discard the output.\" replace ${run $1} .* \\\"\\\""
	};
	Description = "Runs a given command string (replacing embedded commands).";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Command";
			Description = "The command string to run"
		},
	};

	Run = function(context, commandString)
		return context.Cmdr.Util.RunCommandString(context.Dispatcher, commandString)
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="85">
                    <Properties>
                      <string name="Name">runLines</string>
                      <string name="Source"><![CDATA[return {
	Name = "run-lines";
	Aliases = {};
	Description = "Splits input by newlines and runs each line as its own command. This is used by the init-run command.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Script";
			Description = "The script to parse.";
			Default = "";
		}
	};

	ClientRun = function(context, text)
		if #text == 0 then
			return ""
		end

		local shouldPrintOutput = context.Dispatcher:Run("var", "INIT_PRINT_OUTPUT") ~= ""

		local commands = text:gsub("\n+", "\n"):split("\n")

		for _, command in ipairs(commands) do
			if command:sub(1, 1) == "#" then
				continue
			end

			local output = context.Dispatcher:EvaluateAndRun(command)

			if shouldPrintOutput then
				context:Reply(output)
			end
		end

		return ""
	end
}
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="86">
                    <Properties>
                      <string name="Name">runif</string>
                      <string name="Source">local conditions = {
	startsWith = function (text, arg)
		if text:sub(1, #arg) == arg then
			return text:sub(#arg + 1)
		end
	end
}

return {
	Name = "runif";
	Aliases = {};
	Description = "Runs a given command string if a certain condition is met.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "conditionFunction";
			Name = "Condition";
			Description = "The condition function"
		},
		{
			Type = "string";
			Name = "Argument";
			Description = "The argument to the condition function"
		},
		{
			Type = "string";
			Name = "Test against";
			Description = "The text to test against."
		},
		{
			Type = "string";
			Name = "Command";
			Description = "The command string to run if requirements are met. If omitted, return value from condition function is used.";
			Optional = true;
		},
	};

	Run = function(context, condition, arg, testAgainst, command)
		local conditionFunc = conditions[condition]

		if not conditionFunc then
			return ("Condition %q is not valid."):format(condition)
		end

		local text = conditionFunc(testAgainst, arg)

		if text then
			return context.Dispatcher:EvaluateAndRun(context.Cmdr.Util.RunEmbeddedCommands(context.Dispatcher, command or text))
		end

		return ""
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="87">
                    <Properties>
                      <string name="Name">unbind</string>
                      <string name="Source">return {
	Name = "unbind";
	Aliases = {};
	Description = "Unbinds an input previously bound with Bind";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "userInput ! bindableResource @ player";
			Name = "Input/Key";
			Description = "The key or input type you'd like to unbind."
		}
	};

	ClientRun = function(context, inputEnum)
		local binds = context:GetStore("CMDR_Binds")

		if binds[inputEnum] then
			binds[inputEnum]:Disconnect()
			binds[inputEnum] = nil
			return "Unbound command from input."
		else
			return "That input wasn't bound."
		end
	end
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="88">
                    <Properties>
                      <string name="Name">var</string>
                      <string name="Source"><![CDATA[return {
	Name = "var";
	Aliases = {};
	Description = "Gets a stored variable.";
	Group = "DefaultUtil";
	AutoExec = {
		"alias \"init-edit|Edit your initialization script\" edit ${var init} \\\\\n && var= init ||",
		"alias \"init-run|Re-runs the initialization script manually.\" run-lines ${var init}",
		"init-run",
	},
	Args = {
		{
			Type = "storedKey";
			Name = "Key";
			Description = "The key to get, retrieved from your user data store. Keys prefixed with . are not saved. Keys prefixed with $ are game-wide. Keys prefixed with $. are game-wide and non-saved.";
		}
	};

	ClientRun = function(context, key)
		context:GetStore("vars_used")[key] = true
	end
}
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="89">
                    <Properties>
                      <string name="Name">varServer</string>
                      <string name="Source"><![CDATA[local DataStoreService = game:GetService("DataStoreService")

local queue = {}
local DataStoresActive, DataStore
task.spawn(function()
	DataStoresActive, DataStore = pcall(function()
		local DataStore = DataStoreService:GetDataStore("_package/eryn.io/Cmdr")
		DataStore:GetAsync("test_key")
		return DataStore
	end)

	while #queue > 0 do
		coroutine.resume(table.remove(queue, 1))
	end
end)

return function (context, key)
	if DataStoresActive == nil then
		table.insert(queue, coroutine.running())
		coroutine.yield()
	end

	local gameWide = false
	local saved = true

	if key:sub(1, 1) == "$" then
		key = key:sub(2)
		gameWide = true
	end

	if key:sub(1, 1) == "." then
		key = key:sub(2)
		saved = false
	end

	if saved and not DataStoresActive then
		return "# You must publish this place to the web to use saved keys."
	end

	local namespace = "var_" .. (gameWide and "global" or tostring(context.Executor.UserId))

	if saved then
		local keyPath = namespace .. "_" .. key
		local value = DataStore:GetAsync(keyPath) or ""
		if type(value) == "table" then
			return table.concat(value, ",") or ""
		end
		return value
	else
		local store = context:GetStore(namespace)

		local value = store[key] or ""

		if type(value) == "table" then
			return table.concat(value, ",") or ""
		end

		return value
	end
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="90">
                    <Properties>
                      <string name="Name">varSet</string>
                      <string name="Source"><![CDATA[return {
	Name = "var=";
	Aliases = {};
	Description = "Sets a stored value.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "storedKey";
			Name = "Key";
			Description = "The key to set, saved in your user data store. Keys prefixed with . are not saved. Keys prefixed with $ are game-wide. Keys prefixed with $. are game-wide and non-saved.";
		},
		{
			Type = "string";
			Name = "Value";
			Description = "Value or values to set.";
			Default = "";
		}
	};

	ClientRun = function(context, key)
		context:GetStore("vars_used")[key] = true
	end
}
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="91">
                    <Properties>
                      <string name="Name">varSetServer</string>
                      <string name="Source"><![CDATA[local DataStoreService = game:GetService("DataStoreService")

local queue = {}
local DataStoresActive, DataStore
task.spawn(function()
	DataStoresActive, DataStore = pcall(function()
		local DataStore = DataStoreService:GetDataStore("_package/eryn.io/Cmdr")
		DataStore:GetAsync("test_key")
		return DataStore
	end)

	while #queue > 0 do
		coroutine.resume(table.remove(queue, 1))
	end
end)

return function (context, key, value)
	if DataStoresActive == nil then
		table.insert(queue, coroutine.running())
		coroutine.yield()
	end

	local gameWide = false
	local saved = true

	if key:sub(1, 1) == "$" then
		key = key:sub(2)
		gameWide = true
	end

	if key:sub(1, 1) == "." then
		key = key:sub(2)
		saved = false
	end

	if saved and not DataStoresActive then
		return "# You must publish this place to the web to use saved keys."
	end

	local namespace = "var_" .. (gameWide and "global" or tostring(context.Executor.UserId))

	if saved then
		local keyPath = namespace .. "_" .. key

		DataStore:SetAsync(keyPath, value)

		if type(value) == "table" then
			return table.concat(value, ",") or ""
		end

		return value
	else
		local store = context:GetStore(namespace)

		store[key] = value

		if type(value) == "table" then
			return table.concat(value, ",") or ""
		end

		return value
	end
end
]]></string>
                    </Properties>
                  </Item>
                </Item>
                <Item class="ModuleScript" referent="92">
                  <Properties>
                    <string name="Name">help</string>
                    <string name="Source"><![CDATA[local ARGUMENT_SHORTHANDS = [[
Argument Shorthands
-------------------
.   Me/Self
*   All/Everyone
**  Others
?   Random
?N  List of N random values
]]

local TIPS = [[
Tips
----
• Utilize the Tab key to automatically complete commands
• Easily select and copy command output
]]

return {
	Name = "help";
	Description = "Displays a list of all commands, or inspects one command.";
	Group = "Help";
	Args = {
		{
			Type = "command";
			Name = "Command";
			Description = "The command to view information on";
			Optional = true;
		},
	};

	ClientRun = function (context, commandName)
		if commandName then
			local command = context.Cmdr.Registry:GetCommand(commandName)
			context:Reply(`Command: {command.Name}`, Color3.fromRGB(230, 126, 34))
			if command.Aliases and #command.Aliases > 0 then
				context:Reply(`Aliases: {table.concat(command.Aliases, ", ")}`, Color3.fromRGB(230, 230, 230))
			end
			context:Reply(command.Description, Color3.fromRGB(230, 230, 230))
			for i, arg in ipairs(command.Args) do
				context:Reply(
					`#{i} {arg.Name}{if arg.Optional == true then "?" else ""}: {arg.Type} - {arg.Description}`
				)
			end
		else
			context:Reply(ARGUMENT_SHORTHANDS)
			context:Reply(TIPS)

			local commands = context.Cmdr.Registry:GetCommands()
			table.sort(commands, function(a, b)
				return if a.Group and b.Group then a.Group < b.Group else a.Group
			end)
			local lastGroup
			for _, command in ipairs(commands) do
				command.Group = command.Group or "No Group"
				if lastGroup ~= command.Group then
					context:Reply(`\n{command.Group}\n{string.rep("-", #command.Group)}`)
					lastGroup = command.Group
				end
				context:Reply(if command.Description then `{command.Name} - {command.Description}` else command.Name)
			end
		end
		return ""
	end;
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="93">
                <Properties>
                  <string name="Name">BuiltInTypes</string>
                </Properties>
                <Item class="ModuleScript" referent="94">
                  <Properties>
                    <string name="Name">BindableResource</string>
                    <string name="Source"><![CDATA[return function (registry)
	registry:RegisterType("bindableResource", registry.Cmdr.Util.MakeEnumType("BindableResource", {"Chat"}))
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="95">
                  <Properties>
                    <string name="Name">BrickColor</string>
                    <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

local brickColorNames = {
    "White", "Grey", "Light yellow", "Brick yellow", "Light green (Mint)", "Light reddish violet", "Pastel Blue",
    "Light orange brown", "Nougat", "Bright red", "Med. reddish violet", "Bright blue", "Bright yellow", "Earth orange",
    "Black", "Dark grey", "Dark green", "Medium green", "Lig. Yellowich orange", "Bright green", "Dark orange",
    "Light bluish violet", "Transparent", "Tr. Red", "Tr. Lg blue", "Tr. Blue", "Tr. Yellow", "Light blue",
    "Tr. Flu. Reddish orange", "Tr. Green", "Tr. Flu. Green", "Phosph. White", "Light red", "Medium red", "Medium blue",
    "Light grey", "Bright violet", "Br. yellowish orange", "Bright orange", "Bright bluish green", "Earth yellow",
    "Bright bluish violet", "Tr. Brown", "Medium bluish violet", "Tr. Medi. reddish violet", "Med. yellowish green",
    "Med. bluish green", "Light bluish green", "Br. yellowish green", "Lig. yellowish green", "Med. yellowish orange",
    "Br. reddish orange", "Bright reddish violet", "Light orange", "Tr. Bright bluish violet", "Gold", "Dark nougat",
    "Silver", "Neon orange", "Neon green", "Sand blue", "Sand violet", "Medium orange", "Sand yellow", "Earth blue",
    "Earth green", "Tr. Flu. Blue", "Sand blue metallic", "Sand violet metallic", "Sand yellow metallic",
    "Dark grey metallic", "Black metallic", "Light grey metallic", "Sand green", "Sand red", "Dark red",
    "Tr. Flu. Yellow", "Tr. Flu. Red", "Gun metallic", "Red flip/flop", "Yellow flip/flop", "Silver flip/flop", "Curry",
    "Fire Yellow", "Flame yellowish orange", "Reddish brown", "Flame reddish orange", "Medium stone grey", "Royal blue",
    "Dark Royal blue", "Bright reddish lilac", "Dark stone grey", "Lemon metalic", "Light stone grey", "Dark Curry",
    "Faded green", "Turquoise", "Light Royal blue", "Medium Royal blue", "Rust", "Brown", "Reddish lilac", "Lilac",
    "Light lilac", "Bright purple", "Light purple", "Light pink", "Light brick yellow", "Warm yellowish orange",
    "Cool yellow", "Dove blue", "Medium lilac", "Slime green", "Smoky grey", "Dark blue", "Parsley green", "Steel blue",
    "Storm blue", "Lapis", "Dark indigo", "Sea green", "Shamrock", "Fossil", "Mulberry", "Forest green", "Cadet blue",
    "Electric blue", "Eggplant", "Moss", "Artichoke", "Sage green", "Ghost grey", "Lilac", "Plum", "Olivine",
    "Laurel green", "Quill grey", "Crimson", "Mint", "Baby blue", "Carnation pink", "Persimmon", "Maroon", "Gold",
    "Daisy orange", "Pearl", "Fog", "Salmon", "Terra Cotta", "Cocoa", "Wheat", "Buttermilk", "Mauve", "Sunrise",
    "Tawny", "Rust", "Cashmere", "Khaki", "Lily white", "Seashell", "Burgundy", "Cork", "Burlap", "Beige", "Oyster",
    "Pine Cone", "Fawn brown", "Hurricane grey", "Cloudy grey", "Linen", "Copper", "Dirt brown", "Bronze", "Flint",
    "Dark taupe", "Burnt Sienna", "Institutional white", "Mid gray", "Really black", "Really red", "Deep orange",
    "Alder", "Dusty Rose", "Olive", "New Yeller", "Really blue", "Navy blue", "Deep blue", "Cyan", "CGA brown",
    "Magenta", "Pink", "Deep orange", "Teal", "Toothpaste", "Lime green", "Camo", "Grime", "Lavender",
    "Pastel light blue", "Pastel orange", "Pastel violet", "Pastel blue-green", "Pastel green", "Pastel yellow",
    "Pastel brown", "Royal purple", "Hot pink"
}

local brickColorFinder = Util.MakeFuzzyFinder(brickColorNames)

local brickColorType =  {
	Prefixes = "% teamColor";

    Transform = function(text)
        local brickColors = {}
        for i, name in pairs(brickColorFinder(text)) do
            brickColors[i] = BrickColor.new(name)
        end
        return brickColors
    end;

    Validate = function(brickColors)
        return #brickColors > 0, "No valid brick colors with that name could be found."
    end;

    Autocomplete = function(brickColors)
        return Util.GetNames(brickColors)
    end;

    Parse = function(brickColors)
        return brickColors[1]
    end;
}

local brickColor3Type = {
	Transform = brickColorType.Transform;
	Validate = brickColorType.Validate;
	Autocomplete = brickColorType.Autocomplete;

	Parse = function(brickColors)
		return brickColors[1].Color
	end;
}

return function(registry)
    registry:RegisterType("brickColor", brickColorType)
	registry:RegisterType("brickColors", Util.MakeListableType(brickColorType, {
		Prefixes = "% teamColors"
	}))

	registry:RegisterType("brickColor3", brickColor3Type)
    registry:RegisterType("brickColor3s", Util.MakeListableType(brickColor3Type))
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="96">
                  <Properties>
                    <string name="Name">Color3</string>
                    <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local color3Type = Util.MakeSequenceType({
	Prefixes = "# hexColor3 ! brickColor3";
	ValidateEach = function(value, i)
		if value == nil then
			return false, ("Invalid or missing number at position %d in Color3 type."):format(i)
		elseif value < 0 or value > 255 then
			return false, ("Number out of acceptable range 0-255 at position %d in Color3 type."):format(i)
		elseif value % 1 ~= 0 then
			return false, ("Number is not an integer at position %d in Color3 type."):format(i)
		end

		return true
	end;
	TransformEach = tonumber;
	Constructor = Color3.fromRGB;
	Length = 3;
})

local function parseHexDigit(x)
	if #x == 1 then
		x = x .. x
	end

	return tonumber(x, 16)
end

local hexColor3Type = {
	Transform = function(text)
		local r, g, b = text:match("^#?(%x%x?)(%x%x?)(%x%x?)$")
		return Util.Each(parseHexDigit, r, g, b)
	end;

	Validate = function(r, g, b)
		return r ~= nil and g ~= nil and b ~= nil, "Invalid hex color"
	end;

	Parse = function(...)
		return Color3.fromRGB(...)
	end;
}

return function (cmdr)
	cmdr:RegisterType("color3", color3Type)
	cmdr:RegisterType("color3s", Util.MakeListableType(color3Type, {
		Prefixes = "# hexColor3s ! brickColor3s"
	}))

	cmdr:RegisterType("hexColor3", hexColor3Type)
	cmdr:RegisterType("hexColor3s", Util.MakeListableType(hexColor3Type))
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="97">
                  <Properties>
                    <string name="Name">Command</string>
                    <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

return function (cmdr)
	local commandType = {
		Transform = function (text)
			local findCommand = Util.MakeFuzzyFinder(cmdr:GetCommandNames())

			return findCommand(text)
		end;

		Validate = function (commands)
			return #commands > 0, "No command with that name could be found."
		end;

		Autocomplete = function (commands)
			return commands
		end;

		Parse = function (commands)
			return commands[1]
		end;
	}

	cmdr:RegisterType("command", commandType)
	cmdr:RegisterType("commands", Util.MakeListableType(commandType))
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="98">
                  <Properties>
                    <string name="Name">ConditionFunction</string>
                    <string name="Source"><![CDATA[return function (registry)
	registry:RegisterType("conditionFunction", registry.Cmdr.Util.MakeEnumType("ConditionFunction", {"startsWith"}))
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="99">
                  <Properties>
                    <string name="Name">Duration</string>
                    <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local unitTable = {
    Years = 31556926,
    Months = 2629744,
    Weeks = 604800,
    Days = 86400,
    Hours = 3600,
    Minutes = 60,
    Seconds = 1
}

local searchKeyTable = {}
for key, _ in pairs(unitTable) do
    table.insert(searchKeyTable, key)
end
local unitFinder = Util.MakeFuzzyFinder(searchKeyTable)

local function stringToSecondDuration(stringDuration)
    -- The duration cannot be null or an empty string.
    if stringDuration == nil or stringDuration == "" then
        return nil
    end
    -- Allow 0 by itself (without a unit) to indicate 0 seconds
    local durationNum = tonumber(stringDuration)
    if durationNum and durationNum == 0 then
        return 0, 0, true
    end
    -- The duration must end with a unit,
    -- if it doesn't then return true as the fourth value to indicate the need to offer autocomplete for units.
    local endOnlyString = stringDuration:gsub("-?%d+%a+", "")
    local endNumber = endOnlyString:match("-?%d+")
    if endNumber then
        return nil, tonumber(endNumber), true
    end
    local seconds = nil
    local rawNum, rawUnit
    for rawComponent in stringDuration:gmatch("-?%d+%a+") do
        rawNum, rawUnit = rawComponent:match("(-?%d+)(%a+)")
        local unitNames = unitFinder(rawUnit)
        -- There were no matching units, it's invalid. Return the parsed number to be used for autocomplete
        if #unitNames == 0 then
            return nil, tonumber(rawNum)
        end
        if seconds == nil then seconds = 0 end
        -- While it was already defaulting to use minutes when using just "m", this does it without worrying
        -- about any consistency between list ordering.
        seconds = seconds + (rawUnit:lower() == "m" and 60 or unitTable[unitNames[1]]) * tonumber(rawNum)
    end
    -- If no durations were provided, return nil.
    if seconds == nil then
        return nil
    else
        return seconds, tonumber(rawNum)
    end
end

local function mapUnits(units, rawText, lastNumber, subStart)
    subStart = subStart or 1
    local returnTable = {}
    for i, unit in pairs(units) do
        if lastNumber == 1 then
            returnTable[i] = rawText .. unit:sub(subStart, #unit - 1)
        else
            returnTable[i] = rawText .. unit:sub(subStart)
        end
    end
    return returnTable
end

local durationType = {
    Transform = function(text)
        return text, stringToSecondDuration(text)
    end;

    Validate = function(_, duration)
        return duration ~= nil
    end;

    Autocomplete = function(rawText, duration, lastNumber, isUnitMissing, matchedUnits)
        local returnTable = {}
        if isUnitMissing or matchedUnits then
            local unitsTable = isUnitMissing == true and unitFinder("") or matchedUnits
            if isUnitMissing == true then
                -- Concat the entire unit name to existing text.
                returnTable = mapUnits(unitsTable, rawText, lastNumber)
            else
                -- Concat the rest of the unit based on what already exists of the unit name.
                local existingUnitLength = rawText:match("^.*(%a+)$"):len()
                returnTable = mapUnits(unitsTable, rawText, existingUnitLength + 1)
            end
        elseif duration ~= nil then
            local endingUnit = rawText:match("^.*-?%d+(%a+)%s?$")
            -- Assume there is a singular match at this point
            local fuzzyUnits = unitFinder(endingUnit)
            -- List all possible fuzzy matches. This is for the Minutes/Months ambiguity case.
            returnTable = mapUnits(fuzzyUnits, rawText, lastNumber, #endingUnit + 1)
            -- Sort alphabetically in the Minutes/Months case, so Minutes are displayed on top.
            table.sort(returnTable)
        end
        return returnTable
    end;

    Parse = function(_, duration)
        return duration
    end;
}

return function(registry)
    registry:RegisterType("duration", durationType)
    registry:RegisterType("durations", Util.MakeListableType(durationType))
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="100">
                  <Properties>
                    <string name="Name">JSON</string>
                    <string name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

return function(registry)
	registry:RegisterType("json", {
		Validate = function(text)
			return pcall(HttpService.JSONDecode, HttpService, text)
		end;

		Parse = function(text)
			return HttpService:JSONDecode(text)
		end
	})
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="101">
                  <Properties>
                    <string name="Name">MathOperator</string>
                    <string name="Source"><![CDATA[return function(registry)
	registry:RegisterType("mathOperator", registry.Cmdr.Util.MakeEnumType("Math Operator", {
		{
			Name = "+";
			Perform = function(a, b)
				return a + b
			end
		};
		{
			Name = "-";
			Perform = function(a, b)
				return a - b
			end
		};
		{
			Name = "*";
			Perform = function(a, b)
				return a * b
			end
		};
		{
			Name = "/";
			Perform = function(a, b)
				return a / b
			end
		};
		{
			Name = "**";
			Perform = function(a, b)
				return a ^ b
			end
		};
		{
			Name = "%";
			Perform = function(a, b)
				return a % b
			end
		}
	}))
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="102">
                  <Properties>
                    <string name="Name">Player</string>
                    <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)
local Players = game:GetService("Players")

local playerType = {
	Transform = function (text)
		local findPlayer = Util.MakeFuzzyFinder(Players:GetPlayers())

		return findPlayer(text)
	end;

	Validate = function (players)
		return #players > 0, "No player with that name could be found."
	end;

	Autocomplete = function (players)
		return Util.GetNames(players)
	end;

	Parse = function (players)
		return players[1]
	end;

	Default = function(player)
		return player.Name
	end;

	ArgumentOperatorAliases = {
		me = ".";
		all = "*";
		others = "**";
		random = "?";
	};
}

return function (cmdr)
	cmdr:RegisterType("player", playerType)
	cmdr:RegisterType("players", Util.MakeListableType(playerType, {
		Prefixes = "% teamPlayers";
	}))
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="103">
                  <Properties>
                    <string name="Name">PlayerId</string>
                    <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)
local Players = game:GetService("Players")

local nameCache = {}
local function getUserId(name)
	if nameCache[name] then
		return nameCache[name]
	elseif Players:FindFirstChild(name) then
		nameCache[name] = Players[name].UserId
		return Players[name].UserId
	else
		local ok, userid = pcall(Players.GetUserIdFromNameAsync, Players, name)

		if not ok then
			return nil
		end

		nameCache[name] = userid
		return userid
	end
end

local playerIdType = {
	DisplayName = "Full Player Name";
	Prefixes = "# integer";

	Transform = function (text)
		local findPlayer = Util.MakeFuzzyFinder(Players:GetPlayers())

		return text, findPlayer(text)
	end;

	ValidateOnce = function (text)
		return getUserId(text) ~= nil, "No player with that name could be found."
	end;

	Autocomplete = function (_, players)
		return Util.GetNames(players)
	end;

	Parse = function (text)
		return getUserId(text)
	end;

	Default = function(player)
		return player.Name
	end;

	ArgumentOperatorAliases = {
		me = ".";
		all = "*";
		others = "**";
		random = "?";
	};
}

return function (cmdr)
	cmdr:RegisterType("playerId", playerIdType)
	cmdr:RegisterType("playerIds", Util.MakeListableType(playerIdType, {
		Prefixes = "# integers"
	}))
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="104">
                  <Properties>
                    <string name="Name">Primitives</string>
                    <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local stringType = {
	Validate = function (value)
		return value ~= nil
	end;

	Parse = function (value)
		return tostring(value)
	end;
}

local numberType = {
	Transform = function (text)
		return tonumber(text)
	end;

	Validate = function (value)
		return value ~= nil
	end;

	Parse = function (value)
		return value
	end;
}

local intType = {
	Transform = function (text)
		return tonumber(text)
	end;

	Validate = function (value)
		return value ~= nil and value == math.floor(value), "Only whole numbers are valid."
	end;

	Parse = function (value)
		return value
	end
}

local positiveIntType = {
	Transform = function (text)
		return tonumber(text)
	end,

	Validate = function (value)
		return value ~= nil and value == math.floor(value) and value > 0, "Only positive whole numbers are valid."
	end,

	Parse = function (value)
		return value
	end,
}

local nonNegativeIntType = {
	Transform = function (text)
		return tonumber(text)
	end,

	Validate = function (value)
		return value ~= nil and value == math.floor(value) and value >= 0, "Only non-negative whole numbers are valid."
	end,

	Parse = function (value)
		return value
	end,
}

local byteType = {
	Transform = function (text)
		return tonumber(text)
	end,

	Validate = function (value)
		return value ~= nil and value == math.floor(value) and value >= 0 and value <= 255, "Only bytes are valid."
	end,

	Parse = function (value)
		return value
	end,
}

local digitType = {
	Transform = function (text)
		return tonumber(text)
	end,

	Validate = function (value)
		return value ~= nil and value == math.floor(value) and value >= 0 and value <= 9, "Only digits are valid."
	end,

	Parse = function (value)
		return value
	end,
}

local boolType do
	local truthy = Util.MakeDictionary({"true", "t", "yes", "y", "on", "enable", "enabled", "1", "+"});
	local falsy = Util.MakeDictionary({"false"; "f"; "no"; "n"; "off"; "disable"; "disabled"; "0"; "-"});

	boolType = {
		Transform = function (text)
			return text:lower()
		end;

		Validate = function (value)
			return truthy[value] ~= nil or falsy[value] ~= nil, "Please use true/yes/on or false/no/off."
		end;

		Parse = function (value)
			if truthy[value] then
				return true
			elseif falsy[value] then
				return false
			else
				return nil
			end
		end;
	}
end

return function (cmdr)
	cmdr:RegisterType("string", stringType)
	cmdr:RegisterType("number", numberType)
	cmdr:RegisterType("integer", intType)
	cmdr:RegisterType("positiveInteger", positiveIntType)
	cmdr:RegisterType("nonNegativeInteger", nonNegativeIntType)
	cmdr:RegisterType("byte", byteType)
	cmdr:RegisterType("digit", digitType)
	cmdr:RegisterType("boolean", boolType)

	cmdr:RegisterType("strings", Util.MakeListableType(stringType))
	cmdr:RegisterType("numbers", Util.MakeListableType(numberType))
	cmdr:RegisterType("integers", Util.MakeListableType(intType))
	cmdr:RegisterType("positiveIntegers", Util.MakeListableType(positiveIntType))
	cmdr:RegisterType("nonNegativeIntegers", Util.MakeListableType(nonNegativeIntType))
	cmdr:RegisterType("bytes", Util.MakeListableType(byteType))
	cmdr:RegisterType("digits", Util.MakeListableType(digitType))
	cmdr:RegisterType("booleans", Util.MakeListableType(boolType))
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="105">
                  <Properties>
                    <string name="Name">StoredKey</string>
                    <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local VALID_STORED_KEY_NAME_PATTERNS = {
	"^%a[%w_]*$",
	"^%$%a[%w_]*$",
	"^%.%a[%w_]*$",
	"^%$%.%a[%w_]*$",
}

return function (registry)
	local storedKeyType = {
		Autocomplete = function(text)
			local find = registry.Cmdr.Util.MakeFuzzyFinder(registry.Cmdr.Util.DictionaryKeys(registry:GetStore("vars_used") or {}))

			return find(text)
		end;

		Validate = function(text)
			for _, pattern in ipairs(VALID_STORED_KEY_NAME_PATTERNS) do
				if text:match(pattern) then
					return true
				end
			end

			return false, "Key names must start with an optional modifier: . $ or $. and must begin with a letter."
		end;

		Parse = function(text)
			return text
		end;
	}
	registry:RegisterType("storedKey", storedKeyType)
	registry:RegisterType("storedKeys", Util.MakeListableType(storedKeyType))
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="106">
                  <Properties>
                    <string name="Name">Team</string>
                    <string name="Source">local Teams = game:GetService("Teams")
local Util = require(script.Parent.Parent.Shared.Util)

local teamType = {
	Transform = function (text)
		local findTeam = Util.MakeFuzzyFinder(Teams:GetTeams())

		return findTeam(text)
	end;

	Validate = function (teams)
		return #teams > 0, "No team with that name could be found."
	end;

	Autocomplete = function (teams)
		return Util.GetNames(teams)
	end;

	Parse = function (teams)
		return teams[1];
	end;
}

local teamPlayersType = {
	Listable = true;
	Transform = teamType.Transform;
	Validate = teamType.Validate;
	Autocomplete = teamType.Autocomplete;

	Parse = function (teams)
		return teams[1]:GetPlayers()
	end;
}

local teamColorType = {
	Transform = teamType.Transform;
	Validate = teamType.Validate;
	Autocomplete = teamType.Autocomplete;

	Parse = function (teams)
		return teams[1].TeamColor
	end;
}

return function (cmdr)
	cmdr:RegisterType("team", teamType)
	cmdr:RegisterType("teams", Util.MakeListableType(teamType))

	cmdr:RegisterType("teamPlayers", teamPlayersType)

	cmdr:RegisterType("teamColor", teamColorType)
	cmdr:RegisterType("teamColors", Util.MakeListableType(teamColorType))
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="107">
                  <Properties>
                    <string name="Name">Type</string>
                    <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

return function (cmdr)
	local typeType = {
		Transform = function (text)
			local findCommand = Util.MakeFuzzyFinder(cmdr:GetTypeNames())

			return findCommand(text)
		end;

		Validate = function (commands)
			return #commands > 0, "No type with that name could be found."
		end;

		Autocomplete = function (commands)
			return commands
		end;

		Parse = function (commands)
			return commands[1]
		end;
	}

	cmdr:RegisterType("type", typeType)
	cmdr:RegisterType("types", Util.MakeListableType(typeType))
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="108">
                  <Properties>
                    <string name="Name">URL</string>
                    <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local storedKeyType = {
	Validate = function(text)
		if text:match("^https?://.+$") then
			return true
		end

		return false, "URLs must begin with http:// or https://"
	end;

	Parse = function(text)
		return text
	end;
}

return function (cmdr)
	cmdr:RegisterType("url", storedKeyType)
	cmdr:RegisterType("urls", Util.MakeListableType(storedKeyType))
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="109">
                  <Properties>
                    <string name="Name">UserInput</string>
                    <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

local combinedInputEnums = Enum.UserInputType:GetEnumItems()

for _, e in pairs(Enum.KeyCode:GetEnumItems()) do
	combinedInputEnums[#combinedInputEnums + 1] = e
end

local userInputType = {
	Transform = function (text)
		local findEnum = Util.MakeFuzzyFinder(combinedInputEnums)

		return findEnum(text)
	end;

	Validate = function (enums)
		return #enums > 0
	end;

	Autocomplete = function (enums)
		return Util.GetNames(enums)
	end;

	Parse = function (enums)
		return enums[1];
	end;
}

return function (cmdr)
	cmdr:RegisterType("userInput", userInputType)
	cmdr:RegisterType("userInputs", Util.MakeListableType(userInputType))
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="110">
                  <Properties>
                    <string name="Name">Vector</string>
                    <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

local function validateVector(value, i)
	if value == nil then
		return false, ("Invalid or missing number at position %d in Vector type."):format(i)
	end

	return true
end

local vector3Type = Util.MakeSequenceType({
	ValidateEach = validateVector;
	TransformEach = tonumber;
	Constructor = Vector3.new;
	Length = 3;
})

local vector2Type = Util.MakeSequenceType({
	ValidateEach = validateVector;
	TransformEach = tonumber;
	Constructor = Vector2.new;
	Length = 2;
})

return function (cmdr)
	cmdr:RegisterType("vector3", vector3Type)
	cmdr:RegisterType("vector3s", Util.MakeListableType(vector3Type))

	cmdr:RegisterType("vector2", vector2Type)
	cmdr:RegisterType("vector2s", Util.MakeListableType(vector2Type))
end</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="111">
                <Properties>
                  <string name="Name">CmdrClient</string>
                  <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Shared = script:WaitForChild("Shared")
local Util = require(Shared:WaitForChild("Util"))

if RunService:IsClient() == false then
	error("Server scripts cannot require the client library. Please require the server library to use Cmdr in your own code.")
end

local Cmdr do
	Cmdr = setmetatable({
		ReplicatedRoot = script;
		RemoteFunction = script:WaitForChild("CmdrFunction");
		RemoteEvent = script:WaitForChild("CmdrEvent");
		ActivationKeys = {[Enum.KeyCode.F2] = true};
		Enabled = true;
		MashToEnable = false;
		ActivationUnlocksMouse = false;
		HideOnLostFocus = true;
		PlaceName = "Cmdr";
		Util = Util;
		Events = {};
	}, {
		-- This sucks, and may be redone or removed
		-- Proxies dispatch methods on to main Cmdr object
		__index = function (self, k)
			local r = self.Dispatcher[k]
			if r and type(r) == "function" then
				return function (_, ...)
					return r(self.Dispatcher, ...)
				end
			end
		end
	})

	Cmdr.Registry = require(Shared.Registry)(Cmdr)
	Cmdr.Dispatcher = require(Shared.Dispatcher)(Cmdr)
end

if StarterGui:WaitForChild("Cmdr") and wait() and Player:WaitForChild("PlayerGui"):FindFirstChild("Cmdr") == nil then
	StarterGui.Cmdr:Clone().Parent = Player.PlayerGui
end

local Interface = require(script.CmdrInterface)(Cmdr)

--- Sets a list of keyboard keys (Enum.KeyCode) that can be used to open the commands menu
function Cmdr:SetActivationKeys (keysArray)
	self.ActivationKeys = Util.MakeDictionary(keysArray)
end

--- Sets the place name label on the interface
function Cmdr:SetPlaceName (name)
	self.PlaceName = name
	Interface.Window:UpdateLabel()
end

--- Sets whether or not the console is enabled
function Cmdr:SetEnabled (enabled)
	self.Enabled = enabled
end

--- Sets if activation will free the mouse.
function Cmdr:SetActivationUnlocksMouse (enabled)
	self.ActivationUnlocksMouse = enabled
end

--- Shows Cmdr window
function Cmdr:Show ()
	if not self.Enabled then
		return
	end

	Interface.Window:Show()
end

--- Hides Cmdr window
function Cmdr:Hide ()
	Interface.Window:Hide()
end

--- Toggles Cmdr window
function Cmdr:Toggle ()
	if not self.Enabled then
		return self:Hide()
	end

	Interface.Window:SetVisible(not Interface.Window:IsVisible())
end

--- Enables the "Mash to open" feature
function Cmdr:SetMashToEnable(isEnabled)
	self.MashToEnable = isEnabled

	if isEnabled then
		self:SetEnabled(false)
	end
end

--- Sets the hide on 'lost focus' feature.
function Cmdr:SetHideOnLostFocus(enabled)
	self.HideOnLostFocus = enabled
end

--- Sets the handler for a certain event type
function Cmdr:HandleEvent(name, callback)
	self.Events[name] = callback
end

-- Only register when we aren't in studio because don't want to overwrite what the server portion did
if RunService:IsServer() == false then
	Cmdr.Registry:RegisterTypesIn(script:WaitForChild("Types"))
	Cmdr.Registry:RegisterCommandsIn(script:WaitForChild("Commands"))
end

-- Hook up event listener
Cmdr.RemoteEvent.OnClientEvent:Connect(function(name, ...)
	if Cmdr.Events[name] then
		Cmdr.Events[name](...)
	end
end)

require(script.DefaultEventHandlers)(Cmdr)

return Cmdr
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="112">
                  <Properties>
                    <string name="Name">CmdrInterface</string>
                    <string name="Source"><![CDATA[-- Here be dragons

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

return function (Cmdr)
	local Util = Cmdr.Util

	local Window = require(script:WaitForChild("Window"))
	Window.Cmdr = Cmdr

	local AutoComplete = require(script:WaitForChild("AutoComplete"))(Cmdr)
	Window.AutoComplete = AutoComplete


	-- Sets the Window.ProcessEntry callback so that we can dispatch our commands out
	function Window.ProcessEntry(text)
		text = Util.TrimString(text)

		if #text == 0 then return end

		Window:AddLine(Window:GetLabel() .. " " .. text, Color3.fromRGB(255, 223, 93))

		Window:AddLine(Cmdr.Dispatcher:EvaluateAndRun(text, Player, {
			IsHuman = true
		}))
	end

	-- Sets the Window.OnTextChanged callback so we can update the auto complete
	function Window.OnTextChanged (text)
		local command = Cmdr.Dispatcher:Evaluate(text, Player, true)
		local arguments = Util.SplitString(text)
		local commandText = table.remove(arguments, 1)
		local atEnd = false
		if command then
			arguments = Util.MashExcessArguments(arguments, #command.Object.Args)

			atEnd = #arguments == #command.Object.Args
		end

		local entryComplete = commandText and #arguments > 0

		if text:sub(#text, #text):match("%s") and not atEnd then
			entryComplete = true
			arguments[#arguments + 1] = ""
		end

		if command and entryComplete then
			local commandValid, errorText = command:Validate()

			Window:SetIsValidInput(commandValid, ("Validation errors: %s"):format(errorText or ""))

			local acItems = {}

			local lastArgument = command:GetArgument(#arguments)
			if lastArgument then
				local typedText = lastArgument.TextSegmentInProgress

				local isPartial = false
				if lastArgument.RawSegmentsAreAutocomplete then
					for i, segment in ipairs(lastArgument.RawSegments) do
						acItems[i] = {segment, segment}
					end
				else
					local items, options = lastArgument:GetAutocomplete()
					options = options or {}
					isPartial = options.IsPartial or false

					for i, item in pairs(items) do
						acItems[i] = {typedText, item}
					end
				end

				local valid = true

				if #typedText > 0 then
					valid, errorText = lastArgument:Validate()
				end

				if not atEnd and valid then
					Window:HideInvalidState()
				end

				return AutoComplete:Show(acItems, {
					at = atEnd and #text - #typedText + (text:sub(#text, #text):match("%s") and -1 or 0);
					prefix = #lastArgument.RawSegments == 1 and lastArgument.Prefix or "";
					isLast = #command.Arguments == #command.ArgumentDefinitions and #typedText > 0;
					numArgs = #arguments;
					command = command;
					arg = lastArgument;
					name = lastArgument.Name .. (lastArgument.Required and "" or "?");
					type = lastArgument.Type.DisplayName;
					description = (valid == false and errorText) or lastArgument.Object.Description;
					invalid = not valid;
					isPartial = isPartial;
				})
			end
		elseif commandText and #arguments == 0 then
			Window:SetIsValidInput(true)
			local exactCommand = Cmdr.Registry:GetCommand(commandText)
			local exactMatch
			if exactCommand then
				exactMatch = {exactCommand.Name, exactCommand.Name, options = {
					name = exactCommand.Name;
					description = exactCommand.Description;
				}}

				local arg = exactCommand.Args and exactCommand.Args[1]

				if type(arg) == "function" then
					arg = arg(command)
				end

				if
					arg
					and (not arg.Optional
					and arg.Default == nil)
				then
					Window:SetIsValidInput(false, "This command has required arguments.")
					Window:HideInvalidState()
				end
			else
				Window:SetIsValidInput(false, ("%q is not a valid command name. Use the help command to see all available commands."):format(commandText))
			end

			local acItems = {exactMatch}
			for _, cmd in pairs(Cmdr.Registry:GetCommandNames()) do
				if commandText:lower() == cmd:lower():sub(1, #commandText) and (exactMatch == nil or exactMatch[1] ~= commandText) then
					local commandObject = Cmdr.Registry:GetCommand(cmd)
					acItems[#acItems + 1] = {commandText, cmd, options = {
						name = commandObject.Name;
						description = commandObject.Description;
					}}
				end
			end

			return AutoComplete:Show(acItems)
		end

		Window:SetIsValidInput(false, "Use the help command to see all available commands.")
		AutoComplete:Hide()
	end

	Window:UpdateLabel()
	Window:UpdateWindowHeight()

	return {
		Window = Window;
		AutoComplete = AutoComplete;
	}
end
]]></string>
                  </Properties>
                  <Item class="ModuleScript" referent="113">
                    <Properties>
                      <string name="Name">AutoComplete</string>
                      <string name="Source"><![CDATA[-- luacheck: ignore 212
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

return function(Cmdr)
	local AutoComplete = {
		Items = {},
		ItemOptions = {},
		SelectedItem = 0,
	}

	local Util = Cmdr.Util

	local Gui = Player:WaitForChild("PlayerGui"):WaitForChild("Cmdr"):WaitForChild("Autocomplete")
	local AutoItem = Gui:WaitForChild("TextButton")
	local Title = Gui:WaitForChild("Title")
	local Description = Gui:WaitForChild("Description")
	local Entry = Gui.Parent:WaitForChild("Frame"):WaitForChild("Entry")
	AutoItem.Parent = nil

	local defaultBarThickness = Gui.ScrollBarThickness

	-- Helper function that sets text and resizes labels
	local function SetText(obj, textObj, text, sizeFromContents)
		obj.Visible = text ~= nil
		textObj.Text = text or ""

		if sizeFromContents then
			textObj.Size = UDim2.new(
				0,
				Util.GetTextSize(text or "", textObj, Vector2.new(1000, 1000), 1, 0).X,
				obj.Size.Y.Scale,
				obj.Size.Y.Offset
			)
		end
	end

	local function UpdateContainerSize()
		Gui.Size = UDim2.new(
			0,
			math.max(Title.Field.TextBounds.X + Title.Field.Type.TextBounds.X, Gui.Size.X.Offset),
			0,
			math.min(Gui.UIListLayout.AbsoluteContentSize.Y, Gui.Parent.AbsoluteSize.Y - Gui.AbsolutePosition.Y - 10)
		)
	end

	-- Update the info display (Name, type, and description) based on given options.
	local function UpdateInfoDisplay(options)
		-- Update the objects' text and sizes
		SetText(Title, Title.Field, options.name, true)
		SetText(
			Title.Field.Type,
			Title.Field.Type,
			options.type and ": " .. options.type:sub(1, 1):upper() .. options.type:sub(2)
		)
		SetText(Description, Description.Label, options.description)

		Description.Label.TextColor3 = options.invalid and Color3.fromRGB(255, 73, 73) or Color3.fromRGB(255, 255, 255)
		Description.Size = UDim2.new(1, 0, 0, 40)

		-- Flow description text
		while not Description.Label.TextFits do
			Description.Size = Description.Size + UDim2.new(0, 0, 0, 2)

			if Description.Size.Y.Offset > 500 then
				break
			end
		end

		-- Update container
		task.wait()
		Gui.UIListLayout:ApplyLayout()
		UpdateContainerSize()
		Gui.ScrollBarThickness = defaultBarThickness
	end

	--- Shows the auto complete menu with the given list and possible options
	-- item = {typedText, suggestedText, options?=options}
	-- The options table is optional. `at` should only be passed into AutoComplete::Show
	-- name, type, and description may be passed in an options dictionary inside the items as well
	-- options.at?: the character index at which to show the menu
	-- options.name?: The name to display in the info box
	-- options.type?: The type to display in the info box
	-- options.prefix?: The current type prefix (%Team)
	-- options.description?: The description for the currently active info box
	-- options.invalid?: If true, description is shown in red.
	-- options.isLast?: If true, auto complete won't keep going after this argument.
	function AutoComplete:Show(items, options)
		options = options or {}

		-- Remove old options.
		for _, item in pairs(self.Items) do
			if item.gui then
				item.gui:Destroy()
			end
		end

		-- Reset state
		self.SelectedItem = 1
		self.Items = items
		self.Prefix = options.prefix or ""
		self.LastItem = options.isLast or false
		self.Command = options.command
		self.Arg = options.arg
		self.NumArgs = options.numArgs
		self.IsPartial = options.isPartial

		-- Generate the new option labels
		local autocompleteWidth = 200

		Gui.ScrollBarThickness = 0

		for i, item in pairs(self.Items) do
			local leftText = item[1]
			local rightText = item[2]

			local btn = AutoItem:Clone()
			btn.Name = leftText .. rightText
			btn.BackgroundTransparency = i == self.SelectedItem and 0.5 or 1

			local start, stop = string.find(rightText:lower(), leftText:lower(), 1, true)
			btn.Typed.Text = string.rep(" ", start - 1) .. leftText
			btn.Suggest.Text = string.sub(rightText, 0, start - 1)
				.. string.rep(" ", #leftText)
				.. string.sub(rightText, stop + 1)


			btn.Parent = Gui
			btn.LayoutOrder = i

			local maxBounds = math.max(btn.Typed.TextBounds.X, btn.Suggest.TextBounds.X) + 20
			if maxBounds > autocompleteWidth then
				autocompleteWidth = maxBounds
			end

			item.gui = btn
		end

		Gui.UIListLayout:ApplyLayout()

		-- Todo: Use TextService to find accurate position for auto complete box
		local text = Entry.TextBox.Text
		local words = Util.SplitString(text)
		if text:sub(#text, #text) == " " and not options.at then
			words[#words + 1] = "e"
		end
		table.remove(words, #words)
		local extra = (options.at and options.at or (#table.concat(words, " ") + 1)) * 7

		-- Update the auto complete container
		Gui.Position =
			UDim2.new(0, Entry.TextBox.AbsolutePosition.X - 10 + extra, 0, Entry.TextBox.AbsolutePosition.Y + 30)
		Gui.Size = UDim2.new(0, autocompleteWidth, 0, Gui.UIListLayout.AbsoluteContentSize.Y)
		Gui.Visible = true

		-- Finally, update thge info display
		UpdateInfoDisplay(self.Items[1] and self.Items[1].options or options)
	end

	--- Returns the selected item in the auto complete
	function AutoComplete:GetSelectedItem()
		if Gui.Visible == false then
			return nil
		end

		return AutoComplete.Items[AutoComplete.SelectedItem]
	end

	--- Hides the auto complete
	function AutoComplete:Hide()
		Gui.Visible = false
	end

	--- Returns if the menu is visible
	function AutoComplete:IsVisible()
		return Gui.Visible
	end

	--- Changes the user's item selection by the given delta
	function AutoComplete:Select(delta)
		if not Gui.Visible then
			return
		end

		self.SelectedItem = self.SelectedItem + delta

		if self.SelectedItem > #self.Items then
			self.SelectedItem = 1
		elseif self.SelectedItem < 1 then
			self.SelectedItem = #self.Items
		end

		for i, item in pairs(self.Items) do
			item.gui.BackgroundTransparency = i == self.SelectedItem and 0.5 or 1
		end

		Gui.CanvasPosition = Vector2.new(
			0,
			math.max(
				0,
				Title.Size.Y.Offset
					+ Description.Size.Y.Offset
					+ self.SelectedItem * AutoItem.Size.Y.Offset
					- Gui.Size.Y.Offset
			)
		)

		if self.Items[self.SelectedItem] and self.Items[self.SelectedItem].options then
			UpdateInfoDisplay(self.Items[self.SelectedItem].options or {})
		end
	end

	Gui.Parent:GetPropertyChangedSignal("AbsoluteSize"):Connect(UpdateContainerSize)

	return AutoComplete
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="114">
                    <Properties>
                      <string name="Name">Window</string>
                      <string name="Source"><![CDATA[-- Here be dragons
-- luacheck: ignore 212
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local TextChatService = game:GetService("TextChatService")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local WINDOW_MAX_HEIGHT = 300
local MOUSE_TOUCH_ENUM = { Enum.UserInputType.MouseButton1, Enum.UserInputType.MouseButton2, Enum.UserInputType.Touch }

--- Window handles the command bar GUI
local Window = {
	Valid = true,
	AutoComplete = nil,
	ProcessEntry = nil,
	OnTextChanged = nil,
	Cmdr = nil,
	HistoryState = nil,
}

local Gui = Player:WaitForChild("PlayerGui"):WaitForChild("Cmdr"):WaitForChild("Frame")
local Line = Gui:WaitForChild("Line")
local Entry = Gui:WaitForChild("Entry")

Line.Parent = nil

--- Update the text entry label
function Window:UpdateLabel()
	Entry.TextLabel.Text = Player.Name .. "@" .. self.Cmdr.PlaceName .. "$"
end

--- Get the text entry label
function Window:GetLabel()
	return Entry.TextLabel.Text
end

--- Recalculate the window height
function Window:UpdateWindowHeight()
	local windowHeight = Gui.UIListLayout.AbsoluteContentSize.Y
		+ Gui.UIPadding.PaddingTop.Offset
		+ Gui.UIPadding.PaddingBottom.Offset
	Gui.Size = UDim2.new(Gui.Size.X.Scale, Gui.Size.X.Offset, 0, math.clamp(windowHeight, 0, WINDOW_MAX_HEIGHT))
	Gui.CanvasPosition = Vector2.new(0, windowHeight)
end

--- Add a line to the command bar
function Window:AddLine(text, options)
	options = options or {}
	text = tostring(text)

	if typeof(options) == "Color3" then
		options = { Color = options }
	end

	if #text == 0 then
		Window:UpdateWindowHeight()
		return
	end

	local str = self.Cmdr.Util.EmulateTabstops(text or "nil", 8)

	local line = Line:Clone()
	line.Text = str
	line.TextColor3 = options.Color or line.TextColor3
	line.RichText = options.RichText or false
	line.Parent = Gui
end

--- Returns if the command bar is visible
function Window:IsVisible()
	return Gui.Visible
end

--- Sets the command bar visible or not
function Window:SetVisible(visible)
	Gui.Visible = visible

	if visible then
		self.PreviousChatWindowConfigurationEnabled = TextChatService.ChatWindowConfiguration.Enabled
		self.PreviousChatInputBarConfigurationEnabled = TextChatService.ChatInputBarConfiguration.Enabled
		TextChatService.ChatWindowConfiguration.Enabled = false
		TextChatService.ChatInputBarConfiguration.Enabled = false

		Entry.TextBox:CaptureFocus()
		self:SetEntryText("")

		if self.Cmdr.ActivationUnlocksMouse then
			self.PreviousMouseBehavior = UserInputService.MouseBehavior
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		end
	else
		TextChatService.ChatWindowConfiguration.Enabled = if self.PreviousChatWindowConfigurationEnabled ~= nil then 
			self.PreviousChatWindowConfigurationEnabled else true
		TextChatService.ChatInputBarConfiguration.Enabled = if self.PreviousChatInputBarConfigurationEnabled ~= nil then 
			self.PreviousChatInputBarConfigurationEnabled else true

		Entry.TextBox:ReleaseFocus()
		self.AutoComplete:Hide()

		if self.PreviousMouseBehavior then
			UserInputService.MouseBehavior = self.PreviousMouseBehavior
			self.PreviousMouseBehavior = nil
		end
	end
end

--- Hides the command bar
function Window:Hide()
	return self:SetVisible(false)
end

--- Shows the command bar
function Window:Show()
	return self:SetVisible(true)
end

--- Sets the text in the command bar text box, and captures focus
function Window:SetEntryText(text)
	Entry.TextBox.Text = text

	if self:IsVisible() then
		Entry.TextBox:CaptureFocus()
		Entry.TextBox.CursorPosition = #text + 1
		Window:UpdateWindowHeight()
	end
end

--- Gets the text in the command bar text box
function Window:GetEntryText()
	return Entry.TextBox.Text:gsub("\t", "")
end

--- Sets whether the command is in a valid state or not.
-- Cannot submit if in invalid state.
function Window:SetIsValidInput(isValid, errorText)
	Entry.TextBox.TextColor3 = isValid and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(255, 73, 73)
	self.Valid = isValid
	self._errorText = errorText
end

function Window:HideInvalidState()
	Entry.TextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
end

--- Event handler for text box focus lost
function Window:LoseFocus(submit)
	local text = Entry.TextBox.Text

	self:ClearHistoryState()

	if Gui.Visible and not GuiService.MenuIsOpen then
		-- self:SetEntryText("")
		Entry.TextBox:CaptureFocus()
	elseif GuiService.MenuIsOpen and Gui.Visible then
		self:Hide()
	end

	if submit and self.Valid then
		wait()
		self:SetEntryText("")
		self.ProcessEntry(text)
	elseif submit then
		self:AddLine(self._errorText, Color3.fromRGB(255, 153, 153))
	end
end

function Window:TraverseHistory(delta)
	local history = self.Cmdr.Dispatcher:GetHistory()

	if self.HistoryState == nil then
		self.HistoryState = {
			Position = #history + 1,
			InitialText = self:GetEntryText(),
		}
	end

	self.HistoryState.Position = math.clamp(self.HistoryState.Position + delta, 1, #history + 1)

	self:SetEntryText(
		self.HistoryState.Position == #history + 1 and self.HistoryState.InitialText
			or history[self.HistoryState.Position]
	)
end

function Window:ClearHistoryState()
	self.HistoryState = nil
end

function Window:SelectVertical(delta)
	if self.AutoComplete:IsVisible() and not self.HistoryState then
		self.AutoComplete:Select(delta)
	else
		self:TraverseHistory(delta)
	end
end

local lastPressTime = 0
local pressCount = 0
--- Handles user input when the box is focused
function Window:BeginInput(input, gameProcessed)
	if GuiService.MenuIsOpen then
		self:Hide()
	end

	if gameProcessed and self:IsVisible() == false then
		return
	end

	if self.Cmdr.ActivationKeys[input.KeyCode] then -- Activate the command bar
		if self.Cmdr.MashToEnable and not self.Cmdr.Enabled then
			if tick() - lastPressTime < 1 then
				if pressCount >= 5 then
					return self.Cmdr:SetEnabled(true)
				else
					pressCount = pressCount + 1
				end
			else
				pressCount = 1
			end
			lastPressTime = tick()
		elseif self.Cmdr.Enabled then
			self:SetVisible(not self:IsVisible())
			wait()
			self:SetEntryText("")

			if GuiService.MenuIsOpen then -- Special case for menu getting stuck open (roblox bug)
				self:Hide()
			end
		end

		return
	end

	if self.Cmdr.Enabled == false or not self:IsVisible() then
		if self:IsVisible() then
			self:Hide()
		end

		return
	end

	if self.Cmdr.HideOnLostFocus and table.find(MOUSE_TOUCH_ENUM, input.UserInputType) then
		local ps = input.Position
		local ap = Gui.AbsolutePosition
		local as = Gui.AbsoluteSize
		if ps.X < ap.X or ps.X > ap.X + as.X or ps.Y < ap.Y or ps.Y > ap.Y + as.Y then
			self:Hide()
		end
	elseif input.KeyCode == Enum.KeyCode.Down then -- Auto Complete Down
		self:SelectVertical(1)
	elseif input.KeyCode == Enum.KeyCode.Up then -- Auto Complete Up
		self:SelectVertical(-1)
	elseif input.KeyCode == Enum.KeyCode.Return then -- Eat new lines
		wait()
		self:SetEntryText(self:GetEntryText():gsub("\n", ""):gsub("\r", ""))
	elseif input.KeyCode == Enum.KeyCode.Tab then -- Auto complete
		local item = self.AutoComplete:GetSelectedItem()
		local text = self:GetEntryText()
		if item and not (text:sub(#text, #text):match("%s") and self.AutoComplete.LastItem) then
			local replace = item[2]
			local newText
			local insertSpace = true
			local command = self.AutoComplete.Command

			if command then
				local lastArg = self.AutoComplete.Arg

				newText = command.Alias
				insertSpace = self.AutoComplete.NumArgs ~= #command.ArgumentDefinitions
					and self.AutoComplete.IsPartial == false

				local args = command.Arguments
				for i = 1, #args do
					local arg = args[i]
					local segments = arg.RawSegments
					if arg == lastArg then
						segments[#segments] = replace
					end

					local argText = arg.Prefix .. table.concat(segments, ",")

					-- Put auto completion options in quotation marks if they have a space
					if argText:find(" ") or argText == "" then
						argText = ("%q"):format(argText)
					end

					newText = ("%s %s"):format(newText, argText)

					if arg == lastArg then
						break
					end
				end
			else
				newText = replace
			end
			-- need to wait a frame so we can eat the \t
			wait()
			-- Update the text box
			self:SetEntryText(newText .. (insertSpace and " " or ""))
		else
			-- Still need to eat the \t even if there is no auto-complete to show
			wait()
			self:SetEntryText(self:GetEntryText())
		end
	else
		self:ClearHistoryState()
	end
end

-- Hook events
Entry.TextBox.FocusLost:Connect(function(submit)
	return Window:LoseFocus(submit)
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	return Window:BeginInput(input, gameProcessed)
end)

Entry.TextBox:GetPropertyChangedSignal("Text"):Connect(function()
	Gui.CanvasPosition = Vector2.new(0, Gui.AbsoluteCanvasSize.Y)

	if Entry.TextBox.Text:match("\t") then -- Eat \t
		Entry.TextBox.Text = Entry.TextBox.Text:gsub("\t", "")
		return
	end
	if Window.OnTextChanged then
		return Window.OnTextChanged(Entry.TextBox.Text)
	end
end)

Gui.ChildAdded:Connect(function()
	task.defer(Window.UpdateWindowHeight)
end)

return Window
]]></string>
                    </Properties>
                  </Item>
                </Item>
                <Item class="ModuleScript" referent="115">
                  <Properties>
                    <string name="Name">DefaultEventHandlers</string>
                    <string name="Source">local StarterGui = game:GetService("StarterGui")
local Window = require(script.Parent.CmdrInterface.Window)

return function (Cmdr)
	Cmdr:HandleEvent("Message", function (text)
		StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = ("[Announcement] %s"):format(text);
			Color = Color3.fromRGB(249, 217, 56);
		})
	end)

	Cmdr:HandleEvent("AddLine", function (...)
		Window:AddLine(...)
	end)
end</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="116">
                <Properties>
                  <string name="Name">CreateGui</string>
                  <string name="Source"><![CDATA[return function()
	local Cmdr = Instance.new("ScreenGui")
	Cmdr.DisplayOrder = 1000
	Cmdr.Name = "Cmdr"
	Cmdr.ResetOnSpawn = false
	Cmdr.AutoLocalize = false

	local Frame = Instance.new("ScrollingFrame")
	Frame.BackgroundColor3 = Color3.fromRGB(17, 17, 17)
	Frame.BackgroundTransparency = 0.4
	Frame.BorderSizePixel = 0
	Frame.CanvasSize = UDim2.new(0, 0, 0, 0)
	Frame.Name = "Frame"
	Frame.Position = UDim2.new(0.025, 0, 0, 25)
	Frame.ScrollBarThickness = 6
	Frame.ScrollingDirection = Enum.ScrollingDirection.Y
	Frame.Selectable = false
	Frame.Size = UDim2.new(0.95, 0, 0, 0)
	Frame.Visible = false
	Frame.AutomaticCanvasSize = Enum.AutomaticSize.Y
	Frame.Parent = Cmdr

	local Autocomplete = Instance.new("ScrollingFrame")
	Autocomplete.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	Autocomplete.BackgroundTransparency = 0.5
	Autocomplete.BorderSizePixel = 0
	Autocomplete.CanvasSize = UDim2.new(0, 0, 0, 0)
	Autocomplete.Name = "Autocomplete"
	Autocomplete.Position = UDim2.new(0, 167, 0, 75)
	Autocomplete.ScrollBarThickness = 6
	Autocomplete.ScrollingDirection = Enum.ScrollingDirection.Y
	Autocomplete.Selectable = false
	Autocomplete.Size = UDim2.new(0, 200, 0, 200)
	Autocomplete.Visible = false
	Autocomplete.AutomaticCanvasSize = Enum.AutomaticSize.Y
	Autocomplete.Parent = Cmdr

	local UIListLayout = Instance.new("UIListLayout")
	UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout.Parent = Frame

	local Line = Instance.new("TextBox")
	Line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Line.BackgroundTransparency = 1
	Line.Font = Enum.Font.Code
	Line.Name = "Line"
	Line.Size = UDim2.new(1, 0, 0, 20)
	Line.AutomaticSize = Enum.AutomaticSize.Y
	Line.TextColor3 = Color3.fromRGB(255, 255, 255)
	Line.TextSize = 14
	Line.TextXAlignment = Enum.TextXAlignment.Left
	Line.TextEditable = false
	Line.ClearTextOnFocus = false
	Line.Parent = Frame

	local UIPadding = Instance.new("UIPadding")
	UIPadding.PaddingBottom = UDim.new(0, 10)
	UIPadding.PaddingLeft = UDim.new(0, 10)
	UIPadding.PaddingRight = UDim.new(0, 10)
	UIPadding.PaddingTop = UDim.new(0, 10)
	UIPadding.Parent = Frame

	local Entry = Instance.new("Frame")
	Entry.BackgroundTransparency = 1
	Entry.LayoutOrder = 999999999
	Entry.Name = "Entry"
	Entry.Size = UDim2.new(1, 0, 0, 20)
	Entry.Parent = Frame

	local UIListLayout2 = Instance.new("UIListLayout")
	UIListLayout2.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout2.Parent = Autocomplete

	local Title = Instance.new("Frame")
	Title.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	Title.BackgroundTransparency = 0.2
	Title.BorderSizePixel = 0
	Title.LayoutOrder = -2
	Title.Name = "Title"
	Title.Size = UDim2.new(1, 0, 0, 40)
	Title.Parent = Autocomplete

	local Description = Instance.new("Frame")
	Description.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	Description.BackgroundTransparency = 0.2
	Description.BorderSizePixel = 0
	Description.LayoutOrder = -1
	Description.Name = "Description"
	Description.Size = UDim2.new(1, 0, 0, 20)
	Description.Parent = Autocomplete

	local TextButton = Instance.new("TextButton")
	TextButton.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	TextButton.BackgroundTransparency = 0.5
	TextButton.BorderSizePixel = 0
	TextButton.Font = Enum.Font.Code
	TextButton.Size = UDim2.new(1, 0, 0, 30)
	TextButton.Text = ""
	TextButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	TextButton.TextSize = 14
	TextButton.TextXAlignment = Enum.TextXAlignment.Left
	TextButton.Parent = Autocomplete

	local UIListLayout3 = Instance.new("UIListLayout")
	UIListLayout3.FillDirection = Enum.FillDirection.Horizontal
	UIListLayout3.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout3.Padding = UDim.new(0, 7)
	UIListLayout3.Parent = Entry

	local TextBox = Instance.new("TextBox")
	TextBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	TextBox.BackgroundTransparency = 1
	TextBox.ClearTextOnFocus = false
	TextBox.Font = Enum.Font.Code
	TextBox.LayoutOrder = 999999999
	TextBox.Position = UDim2.new(0, 140, 0, 0)
	TextBox.Size = UDim2.new(1, 0, 0, 20)
	TextBox.Text = "x"
	TextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
	TextBox.TextSize = 14
	TextBox.TextXAlignment = Enum.TextXAlignment.Left
	TextBox.Selectable = false
	TextBox.Parent = Entry

	local TextLabel = Instance.new("TextLabel")
	TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	TextLabel.BackgroundTransparency = 1
	TextLabel.Font = Enum.Font.Code
	TextLabel.Size = UDim2.new(0, 0, 0, 20)
	TextLabel.AutomaticSize = Enum.AutomaticSize.X
	TextLabel.Text = ""
	TextLabel.TextColor3 = Color3.fromRGB(255, 223, 93)
	TextLabel.TextSize = 14
	TextLabel.TextXAlignment = Enum.TextXAlignment.Left
	TextLabel.Parent = Entry

	local Field = Instance.new("TextLabel")
	Field.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Field.BackgroundTransparency = 1
	Field.Font = Enum.Font.SourceSansBold
	Field.Name = "Field"
	Field.Size = UDim2.new(0, 37, 1, 0)
	Field.Text = "from"
	Field.TextColor3 = Color3.fromRGB(255, 255, 255)
	Field.TextSize = 20
	Field.TextXAlignment = Enum.TextXAlignment.Left
	Field.Parent = Title

	local UIPadding2 = Instance.new("UIPadding")
	UIPadding2.PaddingLeft = UDim.new(0, 10)
	UIPadding2.Parent = Title

	local Label = Instance.new("TextLabel")
	Label.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Label.BackgroundTransparency = 1
	Label.Font = Enum.Font.SourceSansLight
	Label.Name = "Label"
	Label.Size = UDim2.new(1, 0, 1, 0)
	Label.Text = "The players to teleport. The players to teleport. The players to teleport. The players to teleport. "
	Label.TextColor3 = Color3.fromRGB(255, 255, 255)
	Label.TextSize = 16
	Label.TextWrapped = true
	Label.TextXAlignment = Enum.TextXAlignment.Left
	Label.TextYAlignment = Enum.TextYAlignment.Top
	Label.Parent = Description

	local UIPadding3 = Instance.new("UIPadding")
	UIPadding3.PaddingBottom = UDim.new(0, 10)
	UIPadding3.PaddingLeft = UDim.new(0, 10)
	UIPadding3.PaddingRight = UDim.new(0, 10)
	UIPadding3.Parent = Description

	local Typed = Instance.new("TextLabel")
	Typed.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Typed.BackgroundTransparency = 1
	Typed.Font = Enum.Font.Code
	Typed.Name = "Typed"
	Typed.Size = UDim2.new(1, 0, 1, 0)
	Typed.Text = "Lab"
	Typed.TextColor3 = Color3.fromRGB(131, 222, 255)
	Typed.TextSize = 14
	Typed.TextXAlignment = Enum.TextXAlignment.Left
	Typed.Parent = TextButton

	local UIPadding4 = Instance.new("UIPadding")
	UIPadding4.PaddingLeft = UDim.new(0, 10)
	UIPadding4.Parent = TextButton

	local Suggest = Instance.new("TextLabel")
	Suggest.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Suggest.BackgroundTransparency = 1
	Suggest.Font = Enum.Font.Code
	Suggest.Name = "Suggest"
	Suggest.Size = UDim2.new(1, 0, 1, 0)
	Suggest.Text = "   el"
	Suggest.TextColor3 = Color3.fromRGB(255, 255, 255)
	Suggest.TextSize = 14
	Suggest.TextXAlignment = Enum.TextXAlignment.Left
	Suggest.Parent = TextButton

	local Type = Instance.new("TextLabel")
	Type.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Type.BackgroundTransparency = 1
	Type.BorderColor3 = Color3.fromRGB(255, 153, 153)
	Type.Font = Enum.Font.SourceSans
	Type.Name = "Type"
	Type.Position = UDim2.new(1, 0, 0, 0)
	Type.Size = UDim2.new(0, 0, 1, 0)
	Type.Text = ": Players"
	Type.TextColor3 = Color3.fromRGB(255, 255, 255)
	Type.TextSize = 15
	Type.TextXAlignment = Enum.TextXAlignment.Left
	Type.Parent = Field

	Cmdr.Parent = game:GetService("StarterGui")
	return Cmdr
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="117">
                <Properties>
                  <string name="Name">Initialize</string>
                  <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local CreateGui = require(script.Parent.CreateGui)

--- Handles initial preparation of the game server-side.
return function (cmdr)
	local ReplicatedRoot, RemoteFunction, RemoteEvent

	local function Create (class, name, parent)
		local object = Instance.new(class)
		object.Name = name
		object.Parent = parent or ReplicatedRoot

		return object
	end

	ReplicatedRoot = script.Parent.CmdrClient
	ReplicatedRoot.Parent = ReplicatedStorage

	RemoteFunction = Create("RemoteFunction", "CmdrFunction")
	RemoteEvent = Create("RemoteEvent", "CmdrEvent")

	Create("Folder", "Commands")
	Create("Folder", "Types")

	script.Parent.Shared.Parent = ReplicatedRoot

	cmdr.ReplicatedRoot = ReplicatedRoot
	cmdr.RemoteFunction = RemoteFunction
	cmdr.RemoteEvent = RemoteEvent

	cmdr:RegisterTypesIn(script.Parent.BuiltInTypes)

	script.Parent.BuiltInTypes:Destroy()
	script.Parent.BuiltInCommands.Name = "Server commands"

	if StarterGui:FindFirstChild("Cmdr") == nil then
		CreateGui()
	end
end
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="118">
                <Properties>
                  <string name="Name">Shared</string>
                </Properties>
                <Item class="ModuleScript" referent="119">
                  <Properties>
                    <string name="Name">Argument</string>
                    <string name="Source"><![CDATA[local Util = require(script.Parent.Util)

local function unescapeOperators(text)
	for _, operator in ipairs({"%.", "%?", "%*", "%*%*"}) do
		text = text:gsub("\\" .. operator, operator:gsub("%%", ""))
	end

	return text
end

local Argument = {}
Argument.__index = Argument

--- Returns a new ArgumentContext, an object that handles parsing and validating arguments
function Argument.new (command, argumentObject, value)
	local self = {
		Command = command; -- The command that owns this argument
		Type = nil; -- The type definition
		Name = argumentObject.Name; -- The name for this specific argument
		Object = argumentObject; -- The raw ArgumentObject (definition)
		Required = argumentObject.Default == nil and argumentObject.Optional ~= true; -- If the argument is required or not.
		Executor = command.Executor; -- The player who is running the command
		RawValue = value; -- The raw, unparsed value
		RawSegments = {}; -- The raw, unparsed segments (if the raw value was comma-sep)
		TransformedValues = {}; -- The transformed value (generated later)
		Prefix = ""; -- The prefix for this command (%Team)
		TextSegmentInProgress = ""; -- The text of the raw segment the user is currently typing.
		RawSegmentsAreAutocomplete = false;
	}

	if type(argumentObject.Type) == "table" then
		self.Type = argumentObject.Type
	else
		local parsedType, parsedRawValue, prefix = Util.ParsePrefixedUnionType(
			command.Cmdr.Registry:GetTypeName(argumentObject.Type),
			value
		)

		self.Type = command.Dispatcher.Registry:GetType(parsedType)
		self.RawValue = parsedRawValue
		self.Prefix = prefix

		if self.Type == nil then
			error(string.format("%s has an unregistered type %q", self.Name or "<none>", parsedType or "<none>"))
		end
	end

	setmetatable(self, Argument)

	self:Transform()

	return self
end

function Argument:GetDefaultAutocomplete()
	if self.Type.Autocomplete then
		local strings, options = self.Type.Autocomplete(self:TransformSegment(""))
		return strings, options or {}
	end

	return {}
end

--- Calls the transform function on this argument.
-- The return value(s) from this function are passed to all of the other argument methods.
-- Called automatically at instantiation
function Argument:Transform()
	if #self.TransformedValues ~= 0 then
		return
	end

	local rawValue = self.RawValue
	if self.Type.ArgumentOperatorAliases then
		rawValue = self.Type.ArgumentOperatorAliases[rawValue] or rawValue
	end

	if rawValue == "." and self.Type.Default then
		rawValue = self.Type.Default(self.Executor) or ""
		self.RawSegmentsAreAutocomplete = true
	end

	if rawValue == "?" and self.Type.Autocomplete then
		local strings, options = self:GetDefaultAutocomplete()

		if not options.IsPartial and #strings > 0 then
			rawValue = strings[math.random(1, #strings)]
			self.RawSegmentsAreAutocomplete = true
		end

	end

	if self.Type.Listable and #self.RawValue > 0 then
		local randomMatch = rawValue:match("^%?(%d+)$")
		if randomMatch then
			local maxSize = tonumber(randomMatch)

			if maxSize and maxSize > 0 then
				local items = {}
				local remainingItems, options = self:GetDefaultAutocomplete()

				if not options.IsPartial and #remainingItems > 0 then
					for _ = 1, math.min(maxSize, #remainingItems) do
						table.insert(items, table.remove(remainingItems, math.random(1, #remainingItems)))
					end

					rawValue = table.concat(items, ",")
					self.RawSegmentsAreAutocomplete = true
				end
			end
		elseif rawValue == "*" or rawValue == "**" then
			local strings, options = self:GetDefaultAutocomplete()

			if not options.IsPartial and #strings > 0 then
				if rawValue == "**" and self.Type.Default then
					local defaultString = self.Type.Default(self.Executor) or ""

					for i, string in ipairs(strings) do
						if string == defaultString then
							table.remove(strings, i)
						end
					end
				end

				rawValue = table.concat(
					strings,
					","
				)
				self.RawSegmentsAreAutocomplete = true
			end
		end

		rawValue = unescapeOperators(rawValue)

		local rawSegments = Util.SplitStringSimple(rawValue, ",")

		if #rawSegments == 0 then
			rawSegments = {""}
		end

		if rawValue:sub(#rawValue, #rawValue) == "," then
			rawSegments[#rawSegments + 1] = "" -- makes auto complete tick over right after pressing ,
		end

		for i, rawSegment in ipairs(rawSegments) do
			self.RawSegments[i] = rawSegment
			self.TransformedValues[i] = { self:TransformSegment(rawSegment) }
		end

		self.TextSegmentInProgress = rawSegments[#rawSegments]
	else
		rawValue = unescapeOperators(rawValue)

		self.RawSegments[1] = unescapeOperators(rawValue)
		self.TransformedValues[1] = { self:TransformSegment(rawValue) }
		self.TextSegmentInProgress = self.RawValue
	end
end

function Argument:TransformSegment(rawSegment)
	if self.Type.Transform then
		return self.Type.Transform(rawSegment, self.Executor)
	else
		return rawSegment
	end
end

--- Returns whatever the Transform method gave us.
function Argument:GetTransformedValue(segment)
	return unpack(self.TransformedValues[segment])
end

--- Validates that the argument will work without any type errors.
function Argument:Validate(isFinal)
	if self.RawValue == nil or #self.RawValue == 0 and self.Required == false then
		return true
	end

	if self.Required and (self.RawSegments[1] == nil or #self.RawSegments[1] == 0) then
		return false, "This argument is required."
	end

	if self.Type.Validate or self.Type.ValidateOnce then
		for i = 1, #self.TransformedValues do
			if self.Type.Validate then
				local valid, errorText = self.Type.Validate(self:GetTransformedValue(i))

				if not valid then
					return valid, errorText or "Invalid value"
				end
			end

			if isFinal and self.Type.ValidateOnce then
				local validOnce, errorTextOnce = self.Type.ValidateOnce(self:GetTransformedValue(i))

				if not validOnce then
					return validOnce, errorTextOnce
				end
			end
		end

		return true
	else
		return true
	end
end

--- Gets a list of all possible values that could match based on the current value.
function Argument:GetAutocomplete()
	if self.Type.Autocomplete then
		return self.Type.Autocomplete(self:GetTransformedValue(#self.TransformedValues))
	else
		return {}
	end
end

function Argument:ParseValue(i)
	if self.Type.Parse then
		return self.Type.Parse(self:GetTransformedValue(i))
	else
		return self:GetTransformedValue(i)
	end
end

--- Returns the final value of the argument.
function Argument:GetValue()
	if #self.RawValue == 0 and not self.Required and self.Object.Default ~= nil then
		return self.Object.Default
	end

	if not self.Type.Listable then
		return self:ParseValue(1)
	end

	local values = {}

	for i = 1, #self.TransformedValues do
		local parsedValue = self:ParseValue(i)

		if type(parsedValue) ~= "table" then
			error(("Listable types must return a table from Parse (%s)"):format(self.Type.Name))
		end

		for _, value in pairs(parsedValue) do
			values[value] = true -- Put them into a dictionary to ensure uniqueness
		end
	end

	local valueArray = {}

	for value in pairs(values) do
		valueArray[#valueArray + 1] = value
	end

	return valueArray
end

return Argument
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="120">
                  <Properties>
                    <string name="Name">Command</string>
                    <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Argument = require(script.Parent.Argument)

local IsServer = RunService:IsServer()

local Command = {}
Command.__index = Command

--- Returns a new CommandContext, an object which is created for every command validation.
-- This is also what's passed as the context to the "Run" functions in commands
function Command.new (options)
	local self = {
		Dispatcher = options.Dispatcher; -- The dispatcher that created this command context
		Cmdr = options.Dispatcher.Cmdr; -- A quick reference to Cmdr for command context
		Name = options.CommandObject.Name; -- The command name (not alias)
		RawText = options.Text; -- The raw text used to trigger this command
		Object = options.CommandObject; -- The command object (definition)
		Group = options.CommandObject.Group; -- The group this command is in
		State = {}; -- A table which will hold any custom command state information
		Aliases = options.CommandObject.Aliases;
		Alias = options.Alias; -- The command name that was used
		Description = options.CommandObject.Description;
		Executor = options.Executor; -- The player who ran the command
		ArgumentDefinitions = options.CommandObject.Args; -- The argument definitions from the command definition
		RawArguments = options.Arguments; -- Array of strings which are the unparsed values for the arguments
		Arguments = {}; -- A table which will hold ArgumentContexts for each argument
		Data = options.Data; -- A special container for any additional data the command needs to collect from the client
		Response = nil; -- Will be set at the very end when the command is run and a string is returned from the Run function.
	}

	setmetatable(self, Command)

	return self
end

--- Parses all of the command arguments into ArgumentContexts
-- Called by the command dispatcher automatically
-- allowIncompleteArguments: if true, will not throw an error for missing arguments
function Command:Parse (allowIncompleteArguments)
	local hadOptional = false
	for i, definition in ipairs(self.ArgumentDefinitions) do
		if type(definition) == "function" then
			definition = definition(self)

			if definition == nil then
				break
			end
		end

		local required = (definition.Default == nil and definition.Optional ~= true)

		if required and hadOptional then
			error(("Command %q: Required arguments cannot occur after optional arguments."):format(self.Name))
		elseif not required then
			hadOptional = true
		end

		if self.RawArguments[i] == nil and required and allowIncompleteArguments ~= true then
			return false, ("Required argument #%d %s is missing."):format(i, definition.Name)
		elseif self.RawArguments[i] or allowIncompleteArguments then
			self.Arguments[i] = Argument.new(self, definition, self.RawArguments[i] or "")
		end
	end

	return true
end

--- Validates that all of the arguments are in a valid state.
-- This must be called before :Run() is called.
-- Returns boolean (true if ok), errorText
function Command:Validate (isFinal)
	self._Validated = true
	local errorText = ""
	local success = true

	for i, arg in pairs(self.Arguments) do
		local argSuccess, argErrorText = arg:Validate(isFinal)

		if not argSuccess then
			success = false
			errorText = ("%s; #%d %s: %s"):format(errorText, i, arg.Name, argErrorText or "error")
		end
	end

	return success, errorText:sub(3)
end

--- Returns the last argument that has a value.
-- Useful for getting the autocomplete for the argument the user is working on.
function Command:GetLastArgument()
	for i = #self.Arguments, 1, -1 do
		if self.Arguments[i].RawValue then
			return self.Arguments[i]
		end
	end
end

--- Returns a table containing the parsed values for all of the arguments.
function Command:GatherArgumentValues ()
	local values = {}

	for i = 1, #self.ArgumentDefinitions do
		local arg = self.Arguments[i]
		if arg then
			values[i] = arg:GetValue()
		elseif type(self.ArgumentDefinitions[i]) == "table" then
			values[i] = self.ArgumentDefinitions[i].Default
		end
	end

	return values, #self.ArgumentDefinitions
end

--- Runs the command. Handles dispatching to the server if necessary.
-- Command:Validate() must be called before this is called or it will throw.
function Command:Run ()
	if self._Validated == nil then
		error("Must validate a command before running.")
	end

	local beforeRunHook = self.Dispatcher:RunHooks("BeforeRun", self)
	if beforeRunHook then
		return beforeRunHook
	end

	if not IsServer and self.Object.Data and self.Data == nil then
		local values, length = self:GatherArgumentValues()
		self.Data = self.Object.Data(self, unpack(values, 1, length))
	end

	if not IsServer and self.Object.ClientRun then
		local values, length = self:GatherArgumentValues()
		self.Response = self.Object.ClientRun(self, unpack(values, 1, length))
	end

	if self.Response == nil then
		if self.Object.Run then -- We can just Run it here on this machine
			local values, length = self:GatherArgumentValues()
			self.Response = self.Object.Run(self, unpack(values, 1, length))

		elseif IsServer then -- Uh oh, we're already on the server and there's no Run function.
			if self.Object.ClientRun then
				warn(self.Name, "command fell back to the server because ClientRun returned nil, but there is no server implementation! Either return a string from ClientRun, or create a server implementation for this command.")
			else
				warn(self.Name, "command has no implementation!")
			end

			self.Response = "No implementation."
		else -- We're on the client, so we send this off to the server to let the server see what it can do with it.
			self.Response = self.Dispatcher:Send(self.RawText, self.Data)
		end
	end

	local afterRunHook = self.Dispatcher:RunHooks("AfterRun", self)
	if afterRunHook then
		return afterRunHook
	else
		return self.Response
	end
end

--- Returns an ArgumentContext for the specific index
function Command:GetArgument (index)
	return self.Arguments[index]
end

-- Below are functions that are only meant to be used in command implementations --

--- Returns the extra data associated with this command.
-- This needs to be used instead of just context.Data for reliability when not using a remote command.
function Command:GetData ()
	if self.Data then
		return self.Data
	end

	if self.Object.Data and not IsServer then
		self.Data = self.Object.Data(self)
	end

	return self.Data
end

--- Sends an event message to a player
function Command:SendEvent(player, event, ...)
	assert(typeof(player) == "Instance", "Argument #1 must be a Player")
	assert(player:IsA("Player"), "Argument #1 must be a Player")
	assert(type(event) == "string", "Argument #2 must be a string")

	if IsServer then
		self.Dispatcher.Cmdr.RemoteEvent:FireClient(player, event, ...)
	elseif self.Dispatcher.Cmdr.Events[event] then
		assert(player == Players.LocalPlayer, "Event messages can only be sent to the local player on the client.")
		self.Dispatcher.Cmdr.Events[event](...)
	end
end

--- Sends an event message to all players
function Command:BroadcastEvent(...)
	if not IsServer then
		error("Can't broadcast event messages from the client.", 2)
	end

	self.Dispatcher.Cmdr.RemoteEvent:FireAllClients(...)
end

--- Alias of self:SendEvent(self.Executor, "AddLine", text)
function Command:Reply(...)
	return self:SendEvent(self.Executor, "AddLine", ...)
end

--- Alias of Registry:GetStore(...)
function Command:GetStore(...)
	return self.Dispatcher.Cmdr.Registry:GetStore(...)
end

--- Returns true if the command has an implementation on the caller's machine.
function Command:HasImplementation()
	return ((RunService:IsClient() and self.Object.ClientRun) or self.Object.Run) and true or false
end

return Command
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="121">
                  <Properties>
                    <string name="Name">Dispatcher</string>
                    <string name="Source">local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local Util = require(script.Parent.Util)
local Command = require(script.Parent.Command)

local HISTORY_SETTING_NAME = "CmdrCommandHistory"
local displayedBeforeRunHookWarning = false

--- The dispatcher handles creating and running commands during the game.
local Dispatcher = {
	Cmdr = nil;
	Registry = nil;
}

--- Takes in raw command information and generates a command out of it.
-- text and executor are required arguments.
-- allowIncompleteData, when true, will ignore errors about arguments missing so we can parse live as the user types.
-- data is for special networked Data about the command gathered on the client. Purely Optional.
-- returns the command if successful, or (false, errorText) if not
function Dispatcher:Evaluate (text, executor, allowIncompleteArguments, data)
	if RunService:IsClient() == true and executor ~= Players.LocalPlayer then
		error("Can't evaluate a command that isn't sent by the local player.")
	end

	local arguments = Util.SplitString(text)
	local commandName = table.remove(arguments, 1)
	local commandObject = self.Registry:GetCommand(commandName)

	if commandObject then
		-- No need to continue splitting when there are no more arguments. We'll just mash any additional arguments into the last one.
		arguments = Util.MashExcessArguments(arguments, #commandObject.Args)

		-- Create the CommandContext and parse it.
		local command = Command.new({
			Dispatcher = self,
			Text = text,
			CommandObject = commandObject,
			Alias = commandName,
			Executor = executor,
			Arguments = arguments,
			Data = data
		})
		local success, errorText = command:Parse(allowIncompleteArguments)

		if success then
			return command
		else
			return false, errorText
		end
	else
		return false, ("%q is not a valid command name. Use the help command to see all available commands."):format(tostring(commandName))
	end
end

--- A helper that evaluates and runs the command in one go.
-- Either returns any validation errors as a string, or the output of the command as a string. Definitely a string, though.
function Dispatcher:EvaluateAndRun (text, executor, options)
	executor = executor or Players.LocalPlayer
	options = options or {}

	if RunService:IsClient() and options.IsHuman then
		self:PushHistory(text)
	end

	local command, errorText = self:Evaluate(text, executor, nil, options.Data)

	if not command then
		return errorText
	end

	local ok, out = xpcall(function()
		local valid, errorText = command:Validate(true) -- luacheck: ignore

		if not valid then
			return errorText
		end

		return command:Run() or "Command executed."
	end, function(value)
		return debug.traceback(tostring(value))
	end)

	if not ok then
		warn(("Error occurred while evaluating command string %q\n%s"):format(text, tostring(out)))
	end

	return ok and out or "An error occurred while running this command. Check the console for more information."
end

--- Send text as the local user to remote server to be evaluated there.
function Dispatcher:Send (text, data)
	if RunService:IsClient() == false then
		error("Dispatcher:Send can only be called from the client.")
	end

	return self.Cmdr.RemoteFunction:InvokeServer(text, {
		Data = data
	})
end

--- Invoke a command programmatically as the local user e.g. from a settings menu
-- Command should be the first argument, all arguments afterwards should be the arguments to the command.
function Dispatcher:Run (...)
	if not Players.LocalPlayer then
		error("Dispatcher:Run can only be called from the client.")
	end

	local args = {...}
	local text = args[1]

	for i = 2, #args do
		text = text .. " " .. tostring(args[i])
	end

	local command, errorText = self:Evaluate(text, Players.LocalPlayer)

	if not command then
		error(errorText) -- We do a full-on error here since this is code-invoked and they should know better.
	end

	local success, errorText = command:Validate(true) -- luacheck: ignore

	if not success then
		error(errorText)
	end

	return command:Run()
end

--- Runs hooks matching name and returns nil for ok or a string for cancellation
function Dispatcher:RunHooks(hookName, commandContext, ...)
	if not self.Registry.Hooks[hookName] then
		error(("Invalid hook name: %q"):format(hookName), 2)
	end

	if
		hookName == "BeforeRun"
		and #self.Registry.Hooks[hookName] == 0
		and commandContext.Group ~= "DefaultUtil"
		and commandContext.Group ~= "UserAlias"
		and commandContext:HasImplementation()
	then

		if RunService:IsStudio() then
			if displayedBeforeRunHookWarning == false then
				commandContext:Reply((RunService:IsServer() and "&lt;Server>" or "&lt;Client>") .. " Commands will not run in-game if no BeforeRun hook is configured. Learn more: https://eryn.io/Cmdr/guide/Hooks.html", Color3.fromRGB(255,228,26))
				displayedBeforeRunHookWarning = true
			end
		else
			return "Command blocked for security as no BeforeRun hook is configured."
		end
	end

	for _, hook in ipairs(self.Registry.Hooks[hookName]) do
		local value = hook.callback(commandContext, ...)

		if value ~= nil then
			return tostring(value)
		end
	end
end

function Dispatcher:PushHistory(text)
	assert(RunService:IsClient(), "PushHistory may only be used from the client.")

	local history = self:GetHistory()

	-- Remove duplicates
	if Util.TrimString(text) == "" or text == history[#history] then
		return
	end

	history[#history + 1] = text

	TeleportService:SetTeleportSetting(HISTORY_SETTING_NAME, history)
end

function Dispatcher:GetHistory()
	assert(RunService:IsClient(), "GetHistory may only be used from the client.")

	return TeleportService:GetTeleportSetting(HISTORY_SETTING_NAME) or {}
end

return function (cmdr)
	Dispatcher.Cmdr = cmdr
	Dispatcher.Registry = cmdr.Registry

	return Dispatcher
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="122">
                  <Properties>
                    <string name="Name">Registry</string>
                    <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Util = require(script.Parent.Util)

--- The registry keeps track of all the commands and types that Cmdr knows about.
local Registry = {
	TypeMethods = Util.MakeDictionary({"Transform", "Validate", "Autocomplete", "Parse", "DisplayName", "Listable", "ValidateOnce", "Prefixes", "Default", "ArgumentOperatorAliases"});
	CommandMethods = Util.MakeDictionary({"Name", "Aliases", "AutoExec", "Description", "Args", "Run", "ClientRun", "Data", "Group"});
	CommandArgProps = Util.MakeDictionary({"Name", "Type", "Description", "Optional", "Default"});
	Types = {};
	TypeAliases = {};
	Commands = {};
	CommandsArray = {};
	Cmdr = nil;
	Hooks = {
		BeforeRun = {};
		AfterRun = {}
	};
	Stores = setmetatable({}, {
		__index = function (self, k)
			self[k] = {}
			return self[k]
		end
	});
	AutoExecBuffer = {};
}

--- Registers a type in the system.
-- name: The type Name. This must be unique.
function Registry:RegisterType (name, typeObject)
	if not name or typeof(name) ~= "string" then
		error("Invalid type name provided: nil")
	end

	if not name:find("^[%d%l]%w*$") then
		error(('Invalid type name provided: "%s", type names must be alphanumeric and start with a lower-case letter or a digit.'):format(name))
	end

	for key in pairs(typeObject) do
		if self.TypeMethods[key] == nil then
			error("Unknown key/method in type \"" .. name .. "\": " .. key)
		end
	end

	if self.Types[name] ~= nil then
		error(('Type "%s" has already been registered.'):format(name))
	end

	typeObject.Name = name
	typeObject.DisplayName = typeObject.DisplayName or name

	self.Types[name] = typeObject

	if typeObject.Prefixes then
		self:RegisterTypePrefix(name, typeObject.Prefixes)
	end
end

function Registry:RegisterTypePrefix (name, union)
	if not self.TypeAliases[name] then
		self.TypeAliases[name] = name
	end

	self.TypeAliases[name] = ("%s %s"):format(self.TypeAliases[name], union)
end

function Registry:RegisterTypeAlias (name, alias)
	assert(self.TypeAliases[name] == nil, ("Type alias %s already exists!"):format(alias))
	self.TypeAliases[name] = alias
end

--- Helper method that registers types from all module scripts in a specific container.
function Registry:RegisterTypesIn (container)
	for _, object in pairs(container:GetChildren()) do
		if object:IsA("ModuleScript") then
			object.Parent = self.Cmdr.ReplicatedRoot.Types

			require(object)(self)
		else
			self:RegisterTypesIn(object)
		end
	end
end

-- These are exactly the same thing. No one will notice. Except for you, dear reader.
Registry.RegisterHooksIn = Registry.RegisterTypesIn

--- Registers a command based purely on its definition.
-- Prefer using Registry:RegisterCommand for proper handling of server/client model.
function Registry:RegisterCommandObject (commandObject, fromCmdr)
	for key in pairs(commandObject) do
		if self.CommandMethods[key] == nil then
			error("Unknown key/method in command " .. (commandObject.Name or "unknown command") .. ": " .. key)
		end
	end

	if commandObject.Args then
		for i, arg in pairs(commandObject.Args) do
			if type(arg) == "table" then
				for key in pairs(arg) do
					if self.CommandArgProps[key] == nil then
						error(('Unknown property in command "%s" argument #%d: %s'):format(commandObject.Name or "unknown", i, key))
					end
				end
			end
		end
	end

	if commandObject.AutoExec and RunService:IsClient() then
		table.insert(self.AutoExecBuffer, commandObject.AutoExec)
		self:FlushAutoExecBufferDeferred()
	end

	-- Unregister the old command if it exists...
	local oldCommand = self.Commands[commandObject.Name:lower()]
	if oldCommand and oldCommand.Aliases then
		for _, alias in pairs(oldCommand.Aliases) do
			self.Commands[alias:lower()] = nil
		end
	elseif not oldCommand then
		table.insert(self.CommandsArray, commandObject)
	end

	self.Commands[commandObject.Name:lower()] = commandObject

	if commandObject.Aliases then
		for _, alias in pairs(commandObject.Aliases) do
			self.Commands[alias:lower()] = commandObject
		end
	end
end

--- Registers a command definition and its server equivalent.
-- Handles replicating the definition to the client.
function Registry:RegisterCommand (commandScript, commandServerScript, filter)
	local commandObject = require(commandScript)
	assert(
		typeof(commandObject) == "table",
		`Invalid return value from command script "{commandScript.Name}" (CommandDefinition expected, got {typeof(commandObject)})`
	)

	if commandServerScript then
		assert(RunService:IsServer(), "The commandServerScript parameter is not valid for client usage.")
		commandObject.Run = require(commandServerScript)
	end

	if filter and not filter(commandObject) then
		return
	end

	self:RegisterCommandObject(commandObject)

	commandScript.Parent = self.Cmdr.ReplicatedRoot.Commands
end

--- A helper method that registers all commands inside a specific container.
function Registry:RegisterCommandsIn (container, filter)
	local skippedServerScripts = {}
	local usedServerScripts = {}

	for _, commandScript in pairs(container:GetChildren()) do
		if commandScript:IsA("ModuleScript") then
			if not commandScript.Name:find("Server") then
				local serverCommandScript = container:FindFirstChild(commandScript.Name .. "Server")

				if serverCommandScript then
					usedServerScripts[serverCommandScript] = true
				end

				self:RegisterCommand(commandScript, serverCommandScript, filter)
			else
				skippedServerScripts[commandScript] = true
			end
		else
			self:RegisterCommandsIn(commandScript, filter)
		end
	end

	for skippedScript in pairs(skippedServerScripts) do
		if not usedServerScripts[skippedScript] then
			warn("Command script " .. skippedScript.Name .. " was skipped because it has 'Server' in its name, and has no equivalent shared script.")
		end
	end
end

--- Registers the default commands, with an optional filter function or array of groups.
function Registry:RegisterDefaultCommands (arrayOrFunc)
	assert(RunService:IsServer(), "RegisterDefaultCommands cannot be called from the client.")

	local isArray = type(arrayOrFunc) == "table"

	if isArray then
		arrayOrFunc = Util.MakeDictionary(arrayOrFunc)
	end

	self:RegisterCommandsIn(self.Cmdr.DefaultCommandsFolder, isArray and function (command)
		return arrayOrFunc[command.Group] or false
	end or arrayOrFunc)
end

--- Gets a command definition by name. (Can be an alias)
function Registry:GetCommand (name)
	name = name or ""
	return self.Commands[name:lower()]
end

--- Returns a unique array of all registered commands (not including aliases)
function Registry:GetCommands ()
	return self.CommandsArray
end

--- Returns an array of the names of all registered commands (not including aliases)
function Registry:GetCommandNames ()
	local commands = {}

	for _, command in pairs(self.CommandsArray) do
		table.insert(commands, command.Name)
	end

	return commands
end

Registry.GetCommandsAsStrings = Registry.GetCommandNames

--- Returns an array of the names of all registered types (not including aliases)
function Registry:GetTypeNames ()
	local typeNames = {}

	for typeName in pairs(self.Types) do
		table.insert(typeNames, typeName)
	end

	return typeNames
end


--- Gets a type definition by name.
function Registry:GetType (name)
	return self.Types[name]
end

--- Returns a type name, parsing aliases.
function Registry:GetTypeName (name)
	return self.TypeAliases[name] or name
end

--- Adds a hook to be called when any command is run
function Registry:RegisterHook(hookName, callback, priority)
	if not self.Hooks[hookName] then
		error(("Invalid hook name: %q"):format(hookName), 2)
	end

	table.insert(self.Hooks[hookName], { callback = callback; priority = priority or 0; } )
	table.sort(self.Hooks[hookName], function(a, b) return a.priority < b.priority end)
end

-- Backwards compatability (deprecated)
Registry.AddHook = Registry.RegisterHook

--- Returns the store with the given name
-- Used for commands that require persistent state, like bind or ban
function Registry:GetStore(name)
	return self.Stores[name]
end

--- Calls self:FlushAutoExecBuffer at the end of the frame
function Registry:FlushAutoExecBufferDeferred()
	if self.AutoExecFlushConnection then
		return
	end

	self.AutoExecFlushConnection = RunService.Heartbeat:Connect(function()
		self.AutoExecFlushConnection:Disconnect()
		self.AutoExecFlushConnection = nil
		self:FlushAutoExecBuffer()
	end)
end

--- Runs all pending auto exec commands in Registry.AutoExecBuffer
function Registry:FlushAutoExecBuffer()
	for _, commandGroup in ipairs(self.AutoExecBuffer) do
		for _, command in ipairs(commandGroup) do
			self.Cmdr.Dispatcher:EvaluateAndRun(command)
		end
	end

	self.AutoExecBuffer = {}
end

return function (cmdr)
	Registry.Cmdr = cmdr

	return Registry
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="123">
                  <Properties>
                    <string name="Name">Util</string>
                    <string name="Source"><![CDATA[local TextService = game:GetService("TextService")

local Util = {}

--- Takes an array and flips its values into dictionary keys with value of true.
function Util.MakeDictionary(array)
	local dictionary = {}

	for i = 1, #array do
		dictionary[array[i]] = true
	end

	return dictionary
end

--- Takes a dictionary and returns its keys.
function Util.DictionaryKeys(dict)
	local keys = {}

	for key in pairs(dict) do
		table.insert(keys, key)
	end

	return keys
end

-- Takes an array of instances and returns (array<names>, array<instances>)
local function transformInstanceSet(instances)
	local names = {}

	for i = 1, #instances do
		names[i] = instances[i].Name
	end

	return names, instances
end

--- Returns a function that is a fuzzy finder for the specified set or container.
-- Can pass an array of strings, array of instances, array of EnumItems,
-- array of dictionaries with a Name key or an instance (in which case its children will be used)
-- Exact matches will be inserted in the front of the resulting array
function Util.MakeFuzzyFinder(setOrContainer)
	local names
	local instances = {}

	if typeof(setOrContainer) == "Enum" then
		setOrContainer = setOrContainer:GetEnumItems()
	end

	if typeof(setOrContainer) == "Instance" then
		names, instances = transformInstanceSet(setOrContainer:GetChildren())
	elseif typeof(setOrContainer) == "table" then
		if
			typeof(setOrContainer[1]) == "Instance" or typeof(setOrContainer[1]) == "EnumItem" or
				(typeof(setOrContainer[1]) == "table" and typeof(setOrContainer[1].Name) == "string")
		 then
			names, instances = transformInstanceSet(setOrContainer)
		elseif type(setOrContainer[1]) == "string" then
			names = setOrContainer
		elseif setOrContainer[1] ~= nil then
			error("MakeFuzzyFinder only accepts tables of instances or strings.")
		else
			names = {}
		end
	else
		error("MakeFuzzyFinder only accepts a table, Enum, or Instance.")
	end

	-- Searches the set (checking exact matches first)
	return function(text, returnFirst)
		local results = {}

		for i, name in pairs(names) do
			local value = instances and instances[i] or name

			-- Continue on checking for non-exact matches...
			-- Still need to loop through everything, even on returnFirst, because possibility of an exact match.
			if name:lower() == text:lower() then
				if returnFirst then
					return value
				else
					table.insert(results, 1, value)
				end
			elseif name:lower():find(text:lower(), 1, true) then
				results[#results + 1] = value
			end
		end

		if returnFirst then
			return results[1]
		end

		return results
	end
end

--- Takes an array of instances and returns an array of those instances' names.
function Util.GetNames(instances)
	local names = {}

	for i = 1, #instances do
		names[i] = instances[i].Name or tostring(instances[i])
	end

	return names
end

--- Splits a string using a simple separator (no quote parsing)
function Util.SplitStringSimple(inputstr, sep)
	if sep == nil then
		sep = "%s"
	end
	local t = {}
	local i = 1
	for str in string.gmatch(inputstr, "([^" .. sep .. "]+)") do
		t[i] = str
		i = i + 1
	end
	return t
end

local function charCode(n)
	return utf8.char(tonumber(n, 16))
end

--- Parses escape sequences into their fully qualified characters
function Util.ParseEscapeSequences(text)
	return text:gsub("\\(.)", {
		t = "\t";
		n = "\n";
	})
	:gsub("\\u(%x%x%x%x)", charCode)
	:gsub("\\x(%x%x)", charCode)
end

function Util.EncodeEscapedOperator(text, op)
	local first = op:sub(1, 1)
	local escapedOp = op:gsub(".", "%%%1")
	local escapedFirst = "%" .. first

	return text:gsub("(" .. escapedFirst .. "+)(" .. escapedOp .. ")", function(esc, op)
			return (esc:sub(1, #esc-1) .. op):gsub(".", function(char)
					return "\\u" .. string.format("%04x", string.byte(char), 16)
			end)
	end)
end

local OPERATORS = {"&&", "||", ";"}
function Util.EncodeEscapedOperators(text)
	for _, operator in ipairs(OPERATORS) do
		text = Util.EncodeEscapedOperator(text, operator)
	end

	return text
end

local function encodeControlChars(text)
	return (
		text
		:gsub("\\\\", "___!CMDR_ESCAPE!___")
		:gsub("\\\"", "___!CMDR_QUOTE!___")
		:gsub("\\'", "___!CMDR_SQUOTE!___")
		:gsub("\\\n", "___!CMDR_NL!___")
	)
end

local function decodeControlChars(text)
	return (
		text
		:gsub("___!CMDR_ESCAPE!___", "\\")
		:gsub("___!CMDR_QUOTE!___", "\"")
		:gsub("___!CMDR_NL!___", "\n")
	)
end

--- Splits a string by space but taking into account quoted sequences which will be treated as a single argument.
function Util.SplitString(text, max)
	text = encodeControlChars(text)
	max = max or math.huge
	local t = {}
	local spat, epat = [=[^(['"])]=], [=[(['"])$]=]
	local buf, quoted
	for str in text:gmatch("[^ ]+") do
		str = Util.ParseEscapeSequences(str)
		local squoted = str:match(spat)
		local equoted = str:match(epat)
		local escaped = str:match([=[(\*)['"]$]=])
		if squoted and not quoted and not equoted then
			buf, quoted = str, squoted
		elseif buf and equoted == quoted and #escaped % 2 == 0 then
			str, buf, quoted = buf .. " " .. str, nil, nil
		elseif buf then
			buf = buf .. " " .. str
		end
		if not buf then
			t[#t + (#t > max and 0 or 1)] = decodeControlChars(str:gsub(spat, ""):gsub(epat, ""))
		end
	end

	if buf then
		t[#t + (#t > max and 0 or 1)] = decodeControlChars(buf)
	end

	return t
end

--- Takes an array of arguments and a max value.
-- Any indicies past the max value will be appended to the last valid argument.
function Util.MashExcessArguments(arguments, max)
	local t = {}
	for i = 1, #arguments do
		if i > max then
			t[max] = ("%s %s"):format(t[max] or "", arguments[i])
		else
			t[i] = arguments[i]
		end
	end
	return t
end

--- Trims whitespace from both sides of a string.
function Util.TrimString(str)
	local _, from = string.find(str, "^%s*")
	-- trim the string in two steps to prevent quadratic backtracking when no "%S" match is found
	return from == #str and "" or string.match(str, ".*%S", from + 1)
end

--- Returns the text bounds size based on given text, label (from which properties will be pulled), and optional Vector2 container size.
function Util.GetTextSize(text, label, size)
	return TextService:GetTextSize(text, label.TextSize, label.Font, size or Vector2.new(label.AbsoluteSize.X, 0))
end

--- Makes an Enum type.
function Util.MakeEnumType(name, values)
	local findValue = Util.MakeFuzzyFinder(values)
	return {
		Validate = function(text)
			return findValue(text, true) ~= nil, ("Value %q is not a valid %s."):format(text, name)
		end,
		Autocomplete = function(text)
			local list = findValue(text)
			return type(list[1]) ~= "string" and Util.GetNames(list) or list
		end,
		Parse = function(text)
			return findValue(text, true)
		end
	}
end

--- Parses a prefixed union type argument (such as %Team)
function Util.ParsePrefixedUnionType(typeValue, rawValue)
	local split = Util.SplitStringSimple(typeValue)

	-- Check prefixes in order from longest to shortest
	local types = {}
	for i = 1, #split, 2 do
		types[#types + 1] = {
			prefix = split[i - 1] or "",
			type = split[i]
		}
	end

	table.sort(
		types,
		function(a, b)
			return #a.prefix > #b.prefix
		end
	)

	for i = 1, #types do
		local t = types[i]

		if rawValue:sub(1, #t.prefix) == t.prefix then
			return t.type, rawValue:sub(#t.prefix + 1), t.prefix
		end
	end
end

--- Creates a listable type from a singlular type
function Util.MakeListableType(type, override)
	local listableType = {
		Listable = true,
		Transform = type.Transform,
		Validate = type.Validate,
		ValidateOnce = type.ValidateOnce,
		Autocomplete = type.Autocomplete,
		Default = type.Default,
		ArgumentOperatorAliases = type.ArgumentOperatorAliases,
		Parse = function(...)
			return {type.Parse(...)}
		end
	}

	if override then
		for key, value in pairs(override) do
			listableType[key] = value
		end
	end

	return listableType
end

local function encodeCommandEscape(text)
	return (text:gsub("\\%$", "___!CMDR_DOLLAR!___"))
end

local function decodeCommandEscape(text)
	return (text:gsub("___!CMDR_DOLLAR!___", "$"))
end

function Util.RunCommandString(dispatcher, commandString)
	commandString = Util.ParseEscapeSequences(commandString)
	commandString = Util.EncodeEscapedOperators(commandString)

	local commands = commandString:split("&&")

	local output = ""
	for i, command in ipairs(commands) do
		local outputEncoded = output:gsub("%$", "\\x24"):gsub("%%","%%%%")
		command = command:gsub("||", output:find("%s") and ("%q"):format(outputEncoded) or outputEncoded)

		output = tostring(
			dispatcher:EvaluateAndRun(
				(
					Util.RunEmbeddedCommands(dispatcher, command)
				)
			)
		)


		if i == #commands then
			return output
		end
	end
end

--- Runs embedded commands and replaces them
function Util.RunEmbeddedCommands(dispatcher, str)
	str = encodeCommandEscape(str)

	local results = {}
	-- We need to do this because you can't yield in the gsub function
	for text in str:gmatch("$(%b{})") do
		local doQuotes = true
		local commandString = text:sub(2, #text-1)

		if commandString:match("^{.+}$") then -- Allow double curly for literal replacement
			doQuotes = false
			commandString = commandString:sub(2, #commandString-1)
		end

		results[text] = Util.RunCommandString(dispatcher, commandString)

		if doQuotes then
			if results[text]:find("%s") or results[text] == "" then
				results[text] = string.format("%q", results[text])
			end
		end
	end

	return decodeCommandEscape(str:gsub("$(%b{})", results))
end

--- Replaces arguments in the format $1, $2, $something with whatever the
-- given function returns for it.
function Util.SubstituteArgs(str, replace)
	str = encodeCommandEscape(str)
	-- Convert numerical keys to strings
	if type(replace) == "table" then
		for i = 1, #replace do
			local k = tostring(i)
			replace[k] = replace[i]

			if replace[k]:find("%s") then
				replace[k] = string.format("%q", replace[k])
			end
		end
	end
	return decodeCommandEscape(str:gsub("($%d+)%b{}", "%1"):gsub("$(%w+)", replace))
end

--- Creates an alias command
function Util.MakeAliasCommand(name, commandString)
	local commandName, commandDescription = unpack(name:split("|"))
	local args = {}

	commandString = Util.EncodeEscapedOperators(commandString)

	local seenArgs = {}

	for arg in commandString:gmatch("$(%d+)") do
		if seenArgs[arg] == nil then
			seenArgs[arg] = true
			local options = commandString:match(`${arg}(%b\{})`)

			local argOptional, argType, argName, argDescription
			if options then
				options = options:sub(2, #options - 1) -- remove braces
				argType, argName, argDescription = unpack(options:split("|"))
			end

			argOptional = argType and not not argType:match("%?$")
			argType = if argType then argType:match("^%w+") else "string"
			argName = argName or `Argument {arg}`
			argDescription = argDescription or ""

			table.insert(args, {
				Type = argType,
				Name = argName,
				Description = argDescription,
				Optional = argOptional,
			})
		end
	end

	return {
		Name = commandName,
		Aliases = {},
		Description = `<Alias> {commandDescription or commandString}`,
		Group = "UserAlias",
		Args = args,
		Run = function(context)
			return Util.RunCommandString(context.Dispatcher, Util.SubstituteArgs(commandString, context.RawArguments))
		end,
	}
end

--- Makes a type that contains a sequence, e.g. Vector3 or Color3
function Util.MakeSequenceType(options)
	options = options or {}

	assert(options.Parse ~= nil or options.Constructor ~= nil, "MakeSequenceType: Must provide one of: Constructor, Parse")

	options.TransformEach = options.TransformEach or function(...)
		return ...
	end

	options.ValidateEach = options.ValidateEach or function()
		return true
	end

	return {
		Prefixes = options.Prefixes;

		Transform = function (text)
			return Util.Map(Util.SplitPrioritizedDelimeter(text, {",", "%s"}), function(value)
				return options.TransformEach(value)
			end)
		end;

		Validate = function (components)
			if options.Length and #components > options.Length then
				return false, ("Maximum of %d values allowed in sequence"):format(options.Length)
			end

			for i = 1, options.Length or #components do
				local valid, reason = options.ValidateEach(components[i], i)

				if not valid then
					return false, reason
				end
			end

			return true
		end;

		Parse = options.Parse or function(components)
			return options.Constructor(unpack(components))
		end
	}
end

--- Splits a string by a single delimeter chosen from the given set.
-- The first matching delimeter from the set becomes the split character.
function Util.SplitPrioritizedDelimeter(text, delimeters)
	for i, delimeter in ipairs(delimeters) do
		if text:find(delimeter) or i == #delimeters then
			return Util.SplitStringSimple(text, delimeter)
		end
	end
end

--- Maps values of an array through a callback and returns an array of mapped values
function Util.Map(array, callback)
	local results = {}

	for i, v in ipairs(array) do
		results[i] = callback(v, i)
	end

	return results
end

--- Maps arguments #2-n through callback and returns values as tuple
function Util.Each(callback, ...)
	local results = {}
	for i, value in ipairs({...}) do
		results[i] = callback(value)
	end
	return unpack(results)
end

--- Emulates tabstops with spaces
function Util.EmulateTabstops(text, tabWidth)
	local column = 0
	local textLength = #text
	local result = table.create(textLength)
	for i = 1, textLength do
		local char = string.sub(text, i, i)
		if char == "\t" then
			local spaces = tabWidth - column % tabWidth
			table.insert(result, string.rep(" ", spaces))
			column += spaces
		else
			table.insert(result, char)
			if char == "\n" then
				column = 0 -- Reset column counter on newlines
			elseif char ~= "\r" then
				column += 1
			end
		end
	end
	return table.concat(result)
end

function Util.Mutex()
	local queue = {}
	local locked = false

	return function ()
		if locked then
			table.insert(queue, coroutine.running())
			coroutine.yield()
		else
			locked = true
		end

		return function()
			if #queue > 0 then
				coroutine.resume(table.remove(queue, 1))
			else
				locked = false
			end
		end
	end
end

return Util
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="124">
              <Properties>
                <string name="Name">TS</string>
                <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local module = {}

if RunService:IsServer() then
	module.Cmdr = require(script.Parent.Cmdr)
end

if RunService:IsClient() then
	module.CmdrClient = require(ReplicatedStorage:WaitForChild("CmdrClient"))
end

return module
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="125">
            <Properties>
              <string name="Name">compiler-types</string>
            </Properties>
            <Item class="Folder" referent="126">
              <Properties>
                <string name="Name">types</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="127">
            <Properties>
              <string name="Name">fusion</string>
            </Properties>
            <Item class="ModuleScript" referent="128">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[--!strict

--[[
	The entry point for the Fusion library.
]]

local PubTypes = require(script.PubTypes)
local restrictRead = require(script.Utility.restrictRead)

export type StateObject<T> = PubTypes.StateObject<T>
export type CanBeState<T> = PubTypes.CanBeState<T>
export type Symbol = PubTypes.Symbol
export type Value<T> = PubTypes.Value<T>
export type Computed<T> = PubTypes.Computed<T>
export type ForPairs<KO, VO> = PubTypes.ForPairs<KO, VO>
export type ForKeys<KI, KO> = PubTypes.ForKeys<KI, KO>
export type ForValues<VI, VO> = PubTypes.ForKeys<VI, VO>
export type Observer = PubTypes.Observer
export type Tween<T> = PubTypes.Tween<T>
export type Spring<T> = PubTypes.Spring<T>

type Fusion = {
	version: PubTypes.Version,

	New: (className: string) -> ((propertyTable: PubTypes.PropertyTable) -> Instance),
	Hydrate: (target: Instance) -> ((propertyTable: PubTypes.PropertyTable) -> Instance),
	Ref: PubTypes.SpecialKey,
	Cleanup: PubTypes.SpecialKey,
	Children: PubTypes.SpecialKey,
	Out: PubTypes.SpecialKey,
	OnEvent: (eventName: string) -> PubTypes.SpecialKey,
	OnChange: (propertyName: string) -> PubTypes.SpecialKey,

	Value: <T>(initialValue: T) -> Value<T>,
	Computed: <T>(callback: () -> T, destructor: (T) -> ()?) -> Computed<T>,
	ForPairs: <KI, VI, KO, VO, M>(inputTable: CanBeState<{[KI]: VI}>, processor: (KI, VI) -> (KO, VO, M?), destructor: (KO, VO, M?) -> ()?) -> ForPairs<KO, VO>,
	ForKeys: <KI, KO, M>(inputTable: CanBeState<{[KI]: any}>, processor: (KI) -> (KO, M?), destructor: (KO, M?) -> ()?) -> ForKeys<KO, any>,
	ForValues: <VI, VO, M>(inputTable: CanBeState<{[any]: VI}>, processor: (VI) -> (VO, M?), destructor: (VO, M?) -> ()?) -> ForValues<any, VO>,
	Observer: (watchedState: StateObject<any>) -> Observer,

	Tween: <T>(goalState: StateObject<T>, tweenInfo: TweenInfo?) -> Tween<T>,
	Spring: <T>(goalState: StateObject<T>, speed: number?, damping: number?) -> Spring<T>,

	cleanup: (...any) -> (),
	doNothing: (...any) -> ()
}

return restrictRead("Fusion", {
	version = {major = 0, minor = 2, isRelease = true},

	New = require(script.Instances.New),
	Hydrate = require(script.Instances.Hydrate),
	Ref = require(script.Instances.Ref),
	Out = require(script.Instances.Out),
	Cleanup = require(script.Instances.Cleanup),
	Children = require(script.Instances.Children),
	OnEvent = require(script.Instances.OnEvent),
	OnChange = require(script.Instances.OnChange),

	Value = require(script.State.Value),
	Computed = require(script.State.Computed),
	ForPairs = require(script.State.ForPairs),
	ForKeys = require(script.State.ForKeys),
	ForValues = require(script.State.ForValues),
	Observer = require(script.State.Observer),

	Tween = require(script.Animation.Tween),
	Spring = require(script.Animation.Spring),

	cleanup = require(script.Utility.cleanup),
	doNothing = require(script.Utility.doNothing)
}) :: Fusion
]]></string>
              </Properties>
              <Item class="Folder" referent="129">
                <Properties>
                  <string name="Name">Animation</string>
                </Properties>
                <Item class="ModuleScript" referent="130">
                  <Properties>
                    <string name="Name">Spring</string>
                    <string name="Source">--!nonstrict

--[[
	Constructs a new computed state object, which follows the value of another
	state object using a spring simulation.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local logError = require(Package.Logging.logError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local unpackType = require(Package.Animation.unpackType)
local SpringScheduler = require(Package.Animation.SpringScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)
local xtypeof = require(Package.Utility.xtypeof)
local unwrap = require(Package.State.unwrap)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this Spring object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Sets the position of the internal springs, meaning the value of this
	Spring will jump to the given value. This doesn't affect velocity.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:setPosition(newValue: PubTypes.Animatable)
	local newType = typeof(newValue)
	if newType ~= self._currentType then
		logError("springTypeMismatch", nil, newType, self._currentType)
	end

	self._springPositions = unpackType(newValue, newType)
	self._currentValue = newValue
	SpringScheduler.add(self)
	updateAll(self)
end

--[[
	Sets the velocity of the internal springs, overwriting the existing velocity
	of this Spring. This doesn't affect position.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:setVelocity(newValue: PubTypes.Animatable)
	local newType = typeof(newValue)
	if newType ~= self._currentType then
		logError("springTypeMismatch", nil, newType, self._currentType)
	end

	self._springVelocities = unpackType(newValue, newType)
	SpringScheduler.add(self)
end

--[[
	Adds to the velocity of the internal springs, on top of the existing
	velocity of this Spring. This doesn't affect position.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:addVelocity(deltaValue: PubTypes.Animatable)
	local deltaType = typeof(deltaValue)
	if deltaType ~= self._currentType then
		logError("springTypeMismatch", nil, deltaType, self._currentType)
	end

	local springDeltas = unpackType(deltaValue, deltaType)
	for index, delta in ipairs(springDeltas) do
		self._springVelocities[index] += delta
	end
	SpringScheduler.add(self)
end

--[[
	Called when the goal state changes value, or when the speed or damping has
	changed.
]]
function class:update(): boolean
	local goalValue = self._goalState:get(false)

	-- figure out if this was a goal change or a speed/damping change
	if goalValue == self._goalValue then
		-- speed/damping change
		local damping = unwrap(self._damping)
		if typeof(damping) ~= "number" then
			logErrorNonFatal("mistypedSpringDamping", nil, typeof(damping))
		elseif damping &lt; 0 then
			logErrorNonFatal("invalidSpringDamping", nil, damping)
		else
			self._currentDamping = damping
		end

		local speed = unwrap(self._speed)
		if typeof(speed) ~= "number" then
			logErrorNonFatal("mistypedSpringSpeed", nil, typeof(speed))
		elseif speed &lt; 0 then
			logErrorNonFatal("invalidSpringSpeed", nil, speed)
		else
			self._currentSpeed = speed
		end

		return false
	else
		-- goal change - reconfigure spring to target new goal
		self._goalValue = goalValue

		local oldType = self._currentType
		local newType = typeof(goalValue)
		self._currentType = newType

		local springGoals = unpackType(goalValue, newType)
		local numSprings = #springGoals
		self._springGoals = springGoals

		if newType ~= oldType then
			-- if the type changed, snap to the new value and rebuild the
			-- position and velocity tables
			self._currentValue = self._goalValue

			local springPositions = table.create(numSprings, 0)
			local springVelocities = table.create(numSprings, 0)
			for index, springGoal in ipairs(springGoals) do
				springPositions[index] = springGoal
			end
			self._springPositions = springPositions
			self._springVelocities = springVelocities

			-- the spring may have been animating before, so stop that
			SpringScheduler.remove(self)
			return true

			-- otherwise, the type hasn't changed, just the goal...
		elseif numSprings == 0 then
			-- if the type isn't animatable, snap to the new value
			self._currentValue = self._goalValue
			return true

		else
			-- if it's animatable, let it animate to the goal
			SpringScheduler.add(self)
			return false
		end
	end
end

local function Spring&lt;T>(
	goalState: PubTypes.Value&lt;T>,
	speed: PubTypes.CanBeState&lt;number>?,
	damping: PubTypes.CanBeState&lt;number>?
): Types.Spring&lt;T>
	-- apply defaults for speed and damping
	if speed == nil then
		speed = 10
	end
	if damping == nil then
		damping = 1
	end

	local dependencySet = {[goalState] = true}
	if xtypeof(speed) == "State" then
		dependencySet[speed] = true
	end
	if xtypeof(damping) == "State" then
		dependencySet[damping] = true
	end

	local self = setmetatable({
		type = "State",
		kind = "Spring",
		dependencySet = dependencySet,
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_speed = speed,
		_damping = damping,

		_goalState = goalState,
		_goalValue = nil,

		_currentType = nil,
		_currentValue = nil,
		_currentSpeed = unwrap(speed),
		_currentDamping = unwrap(damping),

		_springPositions = nil,
		_springGoals = nil,
		_springVelocities = nil
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true
	self:update()

	return self
end

return Spring</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="131">
                  <Properties>
                    <string name="Name">SpringScheduler</string>
                    <string name="Source">--!strict

--[[
	Manages batch updating of spring objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local packType = require(Package.Animation.packType)
local springCoefficients = require(Package.Animation.springCoefficients)
local updateAll = require(Package.Dependencies.updateAll)

type Set&lt;T> = {[T]: any}
type Spring = Types.Spring&lt;any>

local SpringScheduler = {}

local EPSILON = 0.0001
local activeSprings: Set&lt;Spring> = {}
local lastUpdateTime = os.clock()

function SpringScheduler.add(spring: Spring)
	-- we don't necessarily want to use the most accurate time - here we snap to
	-- the last update time so that springs started within the same frame have
	-- identical time steps
	spring._lastSchedule = lastUpdateTime
	spring._startDisplacements = {}
	spring._startVelocities = {}
	for index, goal in ipairs(spring._springGoals) do
		spring._startDisplacements[index] = spring._springPositions[index] - goal
		spring._startVelocities[index] = spring._springVelocities[index]
	end

	activeSprings[spring] = true
end

function SpringScheduler.remove(spring: Spring)
	activeSprings[spring] = nil
end


local function updateAllSprings()
	local springsToSleep: Set&lt;Spring> = {}
	lastUpdateTime = os.clock()

	for spring in pairs(activeSprings) do
		local posPos, posVel, velPos, velVel = springCoefficients(lastUpdateTime - spring._lastSchedule, spring._currentDamping, spring._currentSpeed)

		local positions = spring._springPositions
		local velocities = spring._springVelocities
		local startDisplacements = spring._startDisplacements
		local startVelocities = spring._startVelocities
		local isMoving = false

		for index, goal in ipairs(spring._springGoals) do
			local oldDisplacement = startDisplacements[index]
			local oldVelocity = startVelocities[index]
			local newDisplacement = oldDisplacement * posPos + oldVelocity * posVel
			local newVelocity = oldDisplacement * velPos + oldVelocity * velVel

			if math.abs(newDisplacement) > EPSILON or math.abs(newVelocity) > EPSILON then
				isMoving = true
			end

			positions[index] = newDisplacement + goal
			velocities[index] = newVelocity
		end

		if not isMoving then
			springsToSleep[spring] = true
		end
	end

	for spring in pairs(activeSprings) do
		spring._currentValue = packType(spring._springPositions, spring._currentType)
		updateAll(spring)
	end

	for spring in pairs(springsToSleep) do
		activeSprings[spring] = nil
	end
end

RunService:BindToRenderStep(
	"__FusionSpringScheduler",
	Enum.RenderPriority.First.Value,
	updateAllSprings
)

return SpringScheduler</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="132">
                  <Properties>
                    <string name="Name">Tween</string>
                    <string name="Source">--!nonstrict

--[[
	Constructs a new computed state object, which follows the value of another
	state object using a tween.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local TweenScheduler = require(Package.Animation.TweenScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local logError = require(Package.Logging.logError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local xtypeof = require(Package.Utility.xtypeof)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this Tween object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Called when the goal state changes value; this will initiate a new tween.
	Returns false as the current value doesn't change right away.
]]
function class:update(): boolean
	local goalValue = self._goalState:get(false)

	-- if the goal hasn't changed, then this is a TweenInfo change.
	-- in that case, if we're not currently animating, we can skip everything
	if goalValue == self._nextValue and not self._currentlyAnimating then
		return false
	end

	local tweenInfo = self._tweenInfo
	if self._tweenInfoIsState then
		tweenInfo = tweenInfo:get()
	end

	-- if we receive a bad TweenInfo, then error and stop the update
	if typeof(tweenInfo) ~= "TweenInfo" then
		logErrorNonFatal("mistypedTweenInfo", nil, typeof(tweenInfo))
		return false
	end

	self._prevValue = self._currentValue
	self._nextValue = goalValue

	self._currentTweenStartTime = os.clock()
	self._currentTweenInfo = tweenInfo

	local tweenDuration = tweenInfo.DelayTime + tweenInfo.Time
	if tweenInfo.Reverses then
		tweenDuration += tweenInfo.Time
	end
	tweenDuration *= tweenInfo.RepeatCount + 1
	self._currentTweenDuration = tweenDuration

	-- start animating this tween
	TweenScheduler.add(self)

	return false
end

local function Tween&lt;T>(
	goalState: PubTypes.StateObject&lt;PubTypes.Animatable>,
	tweenInfo: PubTypes.CanBeState&lt;TweenInfo>?
): Types.Tween&lt;T>
	local currentValue = goalState:get(false)

	-- apply defaults for tween info
	if tweenInfo == nil then
		tweenInfo = TweenInfo.new()
	end

	local dependencySet = {[goalState] = true}
	local tweenInfoIsState = xtypeof(tweenInfo) == "State"

	if tweenInfoIsState then
		dependencySet[tweenInfo] = true
	end

	local startingTweenInfo = tweenInfo
	if tweenInfoIsState then
		startingTweenInfo = startingTweenInfo:get()
	end

	-- If we start with a bad TweenInfo, then we don't want to construct a Tween
	if typeof(startingTweenInfo) ~= "TweenInfo" then
		logError("mistypedTweenInfo", nil, typeof(startingTweenInfo))
	end

	local self = setmetatable({
		type = "State",
		kind = "Tween",
		dependencySet = dependencySet,
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_goalState = goalState,
		_tweenInfo = tweenInfo,
		_tweenInfoIsState = tweenInfoIsState,

		_prevValue = currentValue,
		_nextValue = currentValue,
		_currentValue = currentValue,

		-- store current tween into separately from 'real' tween into, so it
		-- isn't affected by :setTweenInfo() until next change
		_currentTweenInfo = tweenInfo,
		_currentTweenDuration = 0,
		_currentTweenStartTime = 0,
		_currentlyAnimating = false
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true

	return self
end

return Tween</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="133">
                  <Properties>
                    <string name="Name">TweenScheduler</string>
                    <string name="Source">--!strict

--[[
	Manages batch updating of tween objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local lerpType = require(Package.Animation.lerpType)
local getTweenRatio = require(Package.Animation.getTweenRatio)
local updateAll = require(Package.Dependencies.updateAll)

local TweenScheduler = {}

type Set&lt;T> = {[T]: any}
type Tween = Types.Tween&lt;any>

local WEAK_KEYS_METATABLE = {__mode = "k"}

-- all the tweens currently being updated
local allTweens: Set&lt;Tween> = {}
setmetatable(allTweens, WEAK_KEYS_METATABLE)

--[[
	Adds a Tween to be updated every render step.
]]
function TweenScheduler.add(tween: Tween)
	allTweens[tween] = true
end

--[[
	Removes a Tween from the scheduler.
]]
function TweenScheduler.remove(tween: Tween)
	allTweens[tween] = nil
end

--[[
	Updates all Tween objects.
]]
local function updateAllTweens()
	local now = os.clock()
	-- FIXME: Typed Luau doesn't understand this loop yet
	for tween: Tween in pairs(allTweens :: any) do
		local currentTime = now - tween._currentTweenStartTime

		if currentTime > tween._currentTweenDuration then
			if tween._currentTweenInfo.Reverses then
				tween._currentValue = tween._prevValue
			else
				tween._currentValue = tween._nextValue
			end
			tween._currentlyAnimating = false
			updateAll(tween)
			TweenScheduler.remove(tween)
		else
			local ratio = getTweenRatio(tween._currentTweenInfo, currentTime)
			local currentValue = lerpType(tween._prevValue, tween._nextValue, ratio)
			tween._currentValue = currentValue
			tween._currentlyAnimating = true
			updateAll(tween)
		end
	end
end

RunService:BindToRenderStep(
	"__FusionTweenScheduler",
	Enum.RenderPriority.First.Value,
	updateAllTweens
)

return TweenScheduler</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="134">
                  <Properties>
                    <string name="Name">getTweenRatio</string>
                    <string name="Source">--!strict

--[[
	Given a `tweenInfo` and `currentTime`, returns a ratio which can be used to
	tween between two values over time.
]]

local TweenService = game:GetService("TweenService")

local function getTweenRatio(tweenInfo: TweenInfo, currentTime: number): number
	local delay = tweenInfo.DelayTime
	local duration = tweenInfo.Time
	local reverses = tweenInfo.Reverses
	local numCycles = 1 + tweenInfo.RepeatCount
	local easeStyle = tweenInfo.EasingStyle
	local easeDirection = tweenInfo.EasingDirection

	local cycleDuration = delay + duration
	if reverses then
		cycleDuration += duration
	end

	if currentTime >= cycleDuration * numCycles then
		return 1
	end

	local cycleTime = currentTime % cycleDuration

	if cycleTime &lt;= delay then
		return 0
	end

	local tweenProgress = (cycleTime - delay) / duration
	if tweenProgress > 1 then
		tweenProgress = 2 - tweenProgress
	end

	local ratio = TweenService:GetValue(tweenProgress, easeStyle, easeDirection)
	return ratio
end

return getTweenRatio</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="135">
                  <Properties>
                    <string name="Name">lerpType</string>
                    <string name="Source">--!strict

--[[
	Linearly interpolates the given animatable types by a ratio.
	If the types are different or not animatable, then the first value will be
	returned for ratios below 0.5, and the second value for 0.5 and above.

	FIXME: This function uses a lot of redefinitions to suppress false positives
	from the Luau typechecker - ideally these wouldn't be required
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function lerpType(from: any, to: any, ratio: number): any
	local typeString = typeof(from)

	if typeof(to) == typeString then
		-- both types must match for interpolation to make sense
		if typeString == "number" then
			local to, from = to :: number, from :: number
			return (to - from) * ratio + from

		elseif typeString == "CFrame" then
			local to, from = to :: CFrame, from :: CFrame
			return from:Lerp(to, ratio)

		elseif typeString == "Color3" then
			local to, from = to :: Color3, from :: Color3
			local fromLab = Oklab.to(from)
			local toLab = Oklab.to(to)
			return Oklab.from(
				fromLab:Lerp(toLab, ratio),
				false
			)

		elseif typeString == "ColorSequenceKeypoint" then
			local to, from = to :: ColorSequenceKeypoint, from :: ColorSequenceKeypoint
			local fromLab = Oklab.to(from.Value)
			local toLab = Oklab.to(to.Value)
			return ColorSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				Oklab.from(
					fromLab:Lerp(toLab, ratio),
					false
				)
			)

		elseif typeString == "DateTime" then
			local to, from = to :: DateTime, from :: DateTime
			return DateTime.fromUnixTimestampMillis(
				(to.UnixTimestampMillis - from.UnixTimestampMillis) * ratio + from.UnixTimestampMillis
			)

		elseif typeString == "NumberRange" then
			local to, from = to :: NumberRange, from :: NumberRange
			return NumberRange.new(
				(to.Min - from.Min) * ratio + from.Min,
				(to.Max - from.Max) * ratio + from.Max
			)

		elseif typeString == "NumberSequenceKeypoint" then
			local to, from = to :: NumberSequenceKeypoint, from :: NumberSequenceKeypoint
			return NumberSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				(to.Value - from.Value) * ratio + from.Value,
				(to.Envelope - from.Envelope) * ratio + from.Envelope
			)

		elseif typeString == "PhysicalProperties" then
			local to, from = to :: PhysicalProperties, from :: PhysicalProperties
			return PhysicalProperties.new(
				(to.Density - from.Density) * ratio + from.Density,
				(to.Friction - from.Friction) * ratio + from.Friction,
				(to.Elasticity - from.Elasticity) * ratio + from.Elasticity,
				(to.FrictionWeight - from.FrictionWeight) * ratio + from.FrictionWeight,
				(to.ElasticityWeight - from.ElasticityWeight) * ratio + from.ElasticityWeight
			)

		elseif typeString == "Ray" then
			local to, from = to :: Ray, from :: Ray
			return Ray.new(
				from.Origin:Lerp(to.Origin, ratio),
				from.Direction:Lerp(to.Direction, ratio)
			)

		elseif typeString == "Rect" then
			local to, from = to :: Rect, from :: Rect
			return Rect.new(
				from.Min:Lerp(to.Min, ratio),
				from.Max:Lerp(to.Max, ratio)
			)

		elseif typeString == "Region3" then
			local to, from = to :: Region3, from :: Region3
			-- FUTURE: support rotated Region3s if/when they become constructable
			local position = from.CFrame.Position:Lerp(to.CFrame.Position, ratio)
			local halfSize = from.Size:Lerp(to.Size, ratio) / 2
			return Region3.new(position - halfSize, position + halfSize)

		elseif typeString == "Region3int16" then
			local to, from = to :: Region3int16, from :: Region3int16
			return Region3int16.new(
				Vector3int16.new(
					(to.Min.X - from.Min.X) * ratio + from.Min.X,
					(to.Min.Y - from.Min.Y) * ratio + from.Min.Y,
					(to.Min.Z - from.Min.Z) * ratio + from.Min.Z
				),
				Vector3int16.new(
					(to.Max.X - from.Max.X) * ratio + from.Max.X,
					(to.Max.Y - from.Max.Y) * ratio + from.Max.Y,
					(to.Max.Z - from.Max.Z) * ratio + from.Max.Z
				)
			)

		elseif typeString == "UDim" then
			local to, from = to :: UDim, from :: UDim
			return UDim.new(
				(to.Scale - from.Scale) * ratio + from.Scale,
				(to.Offset - from.Offset) * ratio + from.Offset
			)

		elseif typeString == "UDim2" then
			local to, from = to :: UDim2, from :: UDim2
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2" then
			local to, from = to :: Vector2, from :: Vector2
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2int16" then
			local to, from = to :: Vector2int16, from :: Vector2int16
			return Vector2int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y
			)

		elseif typeString == "Vector3" then
			local to, from = to :: Vector3, from :: Vector3
			return from:Lerp(to, ratio)

		elseif typeString == "Vector3int16" then
			local to, from = to :: Vector3int16, from :: Vector3int16
			return Vector3int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y,
				(to.Z - from.Z) * ratio + from.Z
			)
		end
	end

	-- fallback case: the types are different or not animatable
	if ratio &lt; 0.5 then
		return from
	else
		return to
	end
end

return lerpType</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="136">
                  <Properties>
                    <string name="Name">packType</string>
                    <string name="Source">--!strict

--[[
	Packs an array of numbers into a given animatable data type.
	If the type is not animatable, nil will be returned.

	FUTURE: When Luau supports singleton types, those could be used in
	conjunction with intersection types to make this function fully statically
	type checkable.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function packType(numbers: {number}, typeString: string): PubTypes.Animatable?
	if typeString == "number" then
		return numbers[1]

	elseif typeString == "CFrame" then
		return
			CFrame.new(numbers[1], numbers[2], numbers[3]) *
			CFrame.fromAxisAngle(
				Vector3.new(numbers[4], numbers[5], numbers[6]).Unit,
				numbers[7]
			)

	elseif typeString == "Color3" then
		return Oklab.from(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			false
		)

	elseif typeString == "ColorSequenceKeypoint" then
		return ColorSequenceKeypoint.new(
			numbers[4],
			Oklab.from(
				Vector3.new(numbers[1], numbers[2], numbers[3]),
				false
			)
		)

	elseif typeString == "DateTime" then
		return DateTime.fromUnixTimestampMillis(numbers[1])

	elseif typeString == "NumberRange" then
		return NumberRange.new(numbers[1], numbers[2])

	elseif typeString == "NumberSequenceKeypoint" then
		return NumberSequenceKeypoint.new(numbers[2], numbers[1], numbers[3])

	elseif typeString == "PhysicalProperties" then
		return PhysicalProperties.new(numbers[1], numbers[2], numbers[3], numbers[4], numbers[5])

	elseif typeString == "Ray" then
		return Ray.new(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			Vector3.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "Rect" then
		return Rect.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		local position = Vector3.new(numbers[1], numbers[2], numbers[3])
		local halfSize = Vector3.new(numbers[4] / 2, numbers[5] / 2, numbers[6] / 2)
		return Region3.new(position - halfSize, position + halfSize)

	elseif typeString == "Region3int16" then
		return Region3int16.new(
			Vector3int16.new(numbers[1], numbers[2], numbers[3]),
			Vector3int16.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "UDim" then
		return UDim.new(numbers[1], numbers[2])

	elseif typeString == "UDim2" then
		return UDim2.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Vector2" then
		return Vector2.new(numbers[1], numbers[2])

	elseif typeString == "Vector2int16" then
		return Vector2int16.new(numbers[1], numbers[2])

	elseif typeString == "Vector3" then
		return Vector3.new(numbers[1], numbers[2], numbers[3])

	elseif typeString == "Vector3int16" then
		return Vector3int16.new(numbers[1], numbers[2], numbers[3])
	else
		return nil
	end
end

return packType</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="137">
                  <Properties>
                    <string name="Name">springCoefficients</string>
                    <string name="Source"><![CDATA[--!strict

--[[
	Returns a 2x2 matrix of coefficients for a given time, damping and speed.
	Specifically, this returns four coefficients - posPos, posVel, velPos, and
	velVel - which can be multiplied with position and velocity like so:

	local newPosition = oldPosition * posPos + oldVelocity * posVel
	local newVelocity = oldPosition * velPos + oldVelocity * velVel

	Special thanks to AxisAngle for helping to improve numerical precision.
]]

local function springCoefficients(time: number, damping: number, speed: number): (number, number, number, number)
	-- if time or speed is 0, then the spring won't move
	if time == 0 or speed == 0 then
		return 1, 0, 0, 1
	end
	local posPos, posVel, velPos, velVel

	if damping > 1 then
		-- overdamped spring
		-- solution to the characteristic equation:
		-- z = -ζω ± Sqrt[ζ^2 - 1] ω
		-- x[t] -> x0(e^(t z2) z1 - e^(t z1) z2)/(z1 - z2)
		--		 + v0(e^(t z1) - e^(t z2))/(z1 - z2)
		-- v[t] -> x0(z1 z2(-e^(t z1) + e^(t z2)))/(z1 - z2)
		--		 + v0(z1 e^(t z1) - z2 e^(t z2))/(z1 - z2)

		local scaledTime = time * speed
		local alpha = math.sqrt(damping^2 - 1)
		local scaledInvAlpha = -0.5 / alpha
		local z1 = -alpha - damping
		local z2 = 1 / z1
		local expZ1 = math.exp(scaledTime * z1)
		local expZ2 = math.exp(scaledTime * z2)

		posPos = (expZ2*z1 - expZ1*z2) * scaledInvAlpha
		posVel = (expZ1 - expZ2) * scaledInvAlpha / speed
		velPos = (expZ2 - expZ1) * scaledInvAlpha * speed
		velVel = (expZ1*z1 - expZ2*z2) * scaledInvAlpha

	elseif damping == 1 then
		-- critically damped spring
		-- x[t] -> x0(e^-tω)(1+tω) + v0(e^-tω)t
		-- v[t] -> x0(t ω^2)(-e^-tω) + v0(1 - tω)(e^-tω)

		local scaledTime = time * speed
		local expTerm = math.exp(-scaledTime)

		posPos = expTerm * (1 + scaledTime)
		posVel = expTerm * time
		velPos = expTerm * (-scaledTime*speed)
		velVel = expTerm * (1 - scaledTime)

	else
		-- underdamped spring
		-- factored out of the solutions to the characteristic equation:
		-- α = Sqrt[1 - ζ^2]
		-- x[t] -> x0(e^-tζω)(α Cos[tα] + ζω Sin[tα])/α
		--       + v0(e^-tζω)(Sin[tα])/α
		-- v[t] -> x0(-e^-tζω)(α^2 + ζ^2 ω^2)(Sin[tα])/α
		--       + v0(e^-tζω)(α Cos[tα] - ζω Sin[tα])/α

		local scaledTime = time * speed
		local alpha = math.sqrt(1 - damping^2)
		local invAlpha = 1 / alpha
		local alphaTime = alpha * scaledTime
		local expTerm = math.exp(-scaledTime*damping)
		local sinTerm = expTerm * math.sin(alphaTime)
		local cosTerm = expTerm * math.cos(alphaTime)
		local sinInvAlpha = sinTerm*invAlpha
		local sinInvAlphaDamp = sinInvAlpha*damping

		posPos = sinInvAlphaDamp + cosTerm
		posVel = sinInvAlpha
		velPos = -(sinInvAlphaDamp*damping + sinTerm*alpha)
		velVel = cosTerm - sinInvAlphaDamp
	end

	return posPos, posVel, velPos, velVel
end

return springCoefficients
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="138">
                  <Properties>
                    <string name="Name">unpackType</string>
                    <string name="Source">--!strict

--[[
	Unpacks an animatable type into an array of numbers.
	If the type is not animatable, an empty array will be returned.

	FIXME: This function uses a lot of redefinitions to suppress false positives
	from the Luau typechecker - ideally these wouldn't be required

	FUTURE: When Luau supports singleton types, those could be used in
	conjunction with intersection types to make this function fully statically
	type checkable.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function unpackType(value: any, typeString: string): {number}
	if typeString == "number" then
		local value = value :: number
		return {value}

	elseif typeString == "CFrame" then
		-- FUTURE: is there a better way of doing this? doing distance
		-- calculations on `angle` may be incorrect
		local axis, angle = value:ToAxisAngle()
		return {value.X, value.Y, value.Z, axis.X, axis.Y, axis.Z, angle}

	elseif typeString == "Color3" then
		local lab = Oklab.to(value)
		return {lab.X, lab.Y, lab.Z}

	elseif typeString == "ColorSequenceKeypoint" then
		local lab = Oklab.to(value.Value)
		return {lab.X, lab.Y, lab.Z, value.Time}

	elseif typeString == "DateTime" then
		return {value.UnixTimestampMillis}

	elseif typeString == "NumberRange" then
		return {value.Min, value.Max}

	elseif typeString == "NumberSequenceKeypoint" then
		return {value.Value, value.Time, value.Envelope}

	elseif typeString == "PhysicalProperties" then
		return {value.Density, value.Friction, value.Elasticity, value.FrictionWeight, value.ElasticityWeight}

	elseif typeString == "Ray" then
		return {value.Origin.X, value.Origin.Y, value.Origin.Z, value.Direction.X, value.Direction.Y, value.Direction.Z}

	elseif typeString == "Rect" then
		return {value.Min.X, value.Min.Y, value.Max.X, value.Max.Y}

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		return {
			value.CFrame.X, value.CFrame.Y, value.CFrame.Z,
			value.Size.X, value.Size.Y, value.Size.Z
		}

	elseif typeString == "Region3int16" then
		return {value.Min.X, value.Min.Y, value.Min.Z, value.Max.X, value.Max.Y, value.Max.Z}

	elseif typeString == "UDim" then
		return {value.Scale, value.Offset}

	elseif typeString == "UDim2" then
		return {value.X.Scale, value.X.Offset, value.Y.Scale, value.Y.Offset}

	elseif typeString == "Vector2" then
		return {value.X, value.Y}

	elseif typeString == "Vector2int16" then
		return {value.X, value.Y}

	elseif typeString == "Vector3" then
		return {value.X, value.Y, value.Z}

	elseif typeString == "Vector3int16" then
		return {value.X, value.Y, value.Z}
	else
		return {}
	end
end

return unpackType</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="139">
                <Properties>
                  <string name="Name">Colour</string>
                </Properties>
                <Item class="ModuleScript" referent="140">
                  <Properties>
                    <string name="Name">Oklab</string>
                    <string name="Source"><![CDATA[--!strict

--[[
	Provides functions for converting Color3s into Oklab space, for more
	perceptually uniform colour blending.

	See: https://bottosson.github.io/posts/oklab/
]]

local Oklab = {}

-- Converts a Color3 in RGB space to a Vector3 in Oklab space.
function Oklab.to(rgb: Color3): Vector3
	local l = rgb.R * 0.4122214708 + rgb.G * 0.5363325363 + rgb.B * 0.0514459929
	local m = rgb.R * 0.2119034982 + rgb.G * 0.6806995451 + rgb.B * 0.1073969566
	local s = rgb.R * 0.0883024619 + rgb.G * 0.2817188376 + rgb.B * 0.6299787005

	local lRoot = l ^ (1/3)
	local mRoot = m ^ (1/3)
	local sRoot = s ^ (1/3)

	return Vector3.new(
		lRoot * 0.2104542553 + mRoot * 0.7936177850 - sRoot * 0.0040720468,
		lRoot * 1.9779984951 - mRoot * 2.4285922050 + sRoot * 0.4505937099,
		lRoot * 0.0259040371 + mRoot * 0.7827717662 - sRoot * 0.8086757660
	)
end

-- Converts a Vector3 in CIELAB space to a Color3 in RGB space.
-- The Color3 will be clamped by default unless specified otherwise.
function Oklab.from(lab: Vector3, unclamped: boolean?): Color3
	local lRoot = lab.X + lab.Y * 0.3963377774 + lab.Z * 0.2158037573
	local mRoot = lab.X - lab.Y * 0.1055613458 - lab.Z * 0.0638541728
	local sRoot = lab.X - lab.Y * 0.0894841775 - lab.Z * 1.2914855480

	local l = lRoot ^ 3
	local m = mRoot ^ 3
	local s = sRoot ^ 3

	local red = l * 4.0767416621 - m * 3.3077115913 + s * 0.2309699292
	local green = l * -1.2684380046 + m * 2.6097574011 - s * 0.3413193965
	local blue = l * -0.0041960863 - m * 0.7034186147 + s * 1.7076147010

	if not unclamped then
		red = math.clamp(red, 0, 1)
		green = math.clamp(green, 0, 1)
		blue = math.clamp(blue, 0, 1)
	end

	return Color3.new(red, green, blue)
end

return Oklab
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="141">
                <Properties>
                  <string name="Name">Dependencies</string>
                </Properties>
                <Item class="ModuleScript" referent="142">
                  <Properties>
                    <string name="Name">captureDependencies</string>
                    <string name="Source"><![CDATA[--!strict

--[[
	Calls the given callback, and stores any used external dependencies.
	Arguments can be passed in after the callback.
	If the callback completed successfully, returns true and the returned value,
	otherwise returns false and the error thrown.
	The callback shouldn't yield or run asynchronously.

	NOTE: any calls to useDependency() inside the callback (even if inside any
	nested captureDependencies() call) will not be included in the set, to avoid
	self-dependencies.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local parseError = require(Package.Logging.parseError)
local sharedState = require(Package.Dependencies.sharedState)

type Set<T> = {[T]: any}

local initialisedStack = sharedState.initialisedStack
local initialisedStackCapacity = 0

local function captureDependencies(
	saveToSet: Set<PubTypes.Dependency>,
	callback: (...any) -> any,
	...
): (boolean, any)

	local prevDependencySet = sharedState.dependencySet
	sharedState.dependencySet = saveToSet

	sharedState.initialisedStackSize += 1
	local initialisedStackSize = sharedState.initialisedStackSize

	local initialisedSet
	if initialisedStackSize > initialisedStackCapacity then
		initialisedSet = {}
		initialisedStack[initialisedStackSize] = initialisedSet
		initialisedStackCapacity = initialisedStackSize
	else
		initialisedSet = initialisedStack[initialisedStackSize]
		table.clear(initialisedSet)
	end

	local data = table.pack(xpcall(callback, parseError, ...))

	sharedState.dependencySet = prevDependencySet
	sharedState.initialisedStackSize -= 1

	return table.unpack(data, 1, data.n)
end

return captureDependencies
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="143">
                  <Properties>
                    <string name="Name">initDependency</string>
                    <string name="Source">--!strict

--[[
	Registers the creation of an object which can be used as a dependency.

	This is used to make sure objects don't capture dependencies originating
	from inside of themselves.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function initDependency(dependency: PubTypes.Dependency)
	local initialisedStackSize = sharedState.initialisedStackSize

	for index, initialisedSet in ipairs(initialisedStack) do
		if index > initialisedStackSize then
			return
		end

		initialisedSet[dependency] = true
	end
end

return initDependency</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="144">
                  <Properties>
                    <string name="Name">sharedState</string>
                    <string name="Source">--!strict

--[[
	Stores shared state for dependency management functions.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

type Set&lt;T> = {[T]: any}

-- The set where used dependencies should be saved to.
local dependencySet: Set&lt;PubTypes.Dependency>? = nil

-- A stack of sets where newly created dependencies should be stored.
local initialisedStack: {Set&lt;PubTypes.Dependency>} = {}
local initialisedStackSize = 0

return {
	dependencySet = dependencySet,
	initialisedStack = initialisedStack,
	initialisedStackSize = initialisedStackSize
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="145">
                  <Properties>
                    <string name="Name">updateAll</string>
                    <string name="Source">--!strict

--[[
	Given a reactive object, updates all dependent reactive objects.
	Objects are only ever updated after all of their dependencies are updated,
	are only ever updated once, and won't be updated if their dependencies are
	unchanged.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

type Set&lt;T> = {[T]: any}
type Descendant = (PubTypes.Dependent &amp; PubTypes.Dependency) | PubTypes.Dependent

-- Credit: https://blog.elttob.uk/2022/11/07/sets-efficient-topological-search.html
local function updateAll(root: PubTypes.Dependency)
	local counters: {[Descendant]: number} = {}
	local flags: {[Descendant]: boolean} = {}
	local queue: {Descendant} = {}
	local queueSize = 0
	local queuePos = 1

	for object in root.dependentSet do
		queueSize += 1
		queue[queueSize] = object
		flags[object] = true
	end

	-- Pass 1: counting up
	while queuePos &lt;= queueSize do
		local next = queue[queuePos]
		local counter = counters[next]
		counters[next] = if counter == nil then 1 else counter + 1
		if (next :: any).dependentSet ~= nil then
			for object in (next :: any).dependentSet do
				queueSize += 1
				queue[queueSize] = object
			end
		end
		queuePos += 1
	end

	-- Pass 2: counting down + processing
	queuePos = 1
	while queuePos &lt;= queueSize do
		local next = queue[queuePos]
		local counter = counters[next] - 1
		counters[next] = counter
		if counter == 0 and flags[next] and next:update() and (next :: any).dependentSet ~= nil then
			for object in (next :: any).dependentSet do
				flags[object] = true
			end
		end
		queuePos += 1
	end
end

return updateAll</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="146">
                  <Properties>
                    <string name="Name">useDependency</string>
                    <string name="Source">--!strict

--[[
	If a target set was specified by captureDependencies(), this will add the
	given dependency to the target set.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function useDependency(dependency: PubTypes.Dependency)
	local dependencySet = sharedState.dependencySet

	if dependencySet ~= nil then
		local initialisedStackSize = sharedState.initialisedStackSize
		if initialisedStackSize > 0 then
			local initialisedSet = initialisedStack[initialisedStackSize]
			if initialisedSet[dependency] ~= nil then
				return
			end
		end
		dependencySet[dependency] = true
	end
end

return useDependency</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="147">
                <Properties>
                  <string name="Name">Instances</string>
                </Properties>
                <Item class="ModuleScript" referent="148">
                  <Properties>
                    <string name="Name">Children</string>
                    <string name="Source">--!strict

--[[
	A special key for property tables, which parents any given descendants into
	an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logWarn = require(Package.Logging.logWarn)
local Observer = require(Package.State.Observer)
local xtypeof = require(Package.Utility.xtypeof)

type Set&lt;T> = {[T]: boolean}

-- Experimental flag: name children based on the key used in the [Children] table
local EXPERIMENTAL_AUTO_NAMING = false

local Children = {}
Children.type = "SpecialKey"
Children.kind = "Children"
Children.stage = "descendants"

function Children:apply(propValue: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	local newParented: Set&lt;Instance> = {}
	local oldParented: Set&lt;Instance> = {}

	-- save disconnection functions for state object observers
	local newDisconnects: {[PubTypes.StateObject&lt;any>]: () -> ()} = {}
	local oldDisconnects: {[PubTypes.StateObject&lt;any>]: () -> ()} = {}

	local updateQueued = false
	local queueUpdate: () -> ()

	-- Rescans this key's value to find new instances to parent and state objects
	-- to observe for changes; then unparents instances no longer found and
	-- disconnects observers for state objects no longer present.
	local function updateChildren()
		if not updateQueued then
			return -- this update may have been canceled by destruction, etc.
		end
		updateQueued = false

		oldParented, newParented = newParented, oldParented
		oldDisconnects, newDisconnects = newDisconnects, oldDisconnects
		table.clear(newParented)
		table.clear(newDisconnects)

		local function processChild(child: any, autoName: string?)
			local kind = xtypeof(child)

			if kind == "Instance" then
				-- case 1; single instance

				newParented[child] = true
				if oldParented[child] == nil then
					-- wasn't previously present

					-- TODO: check for ancestry conflicts here
					child.Parent = applyTo
				else
					-- previously here; we want to reuse, so remove from old
					-- set so we don't encounter it during unparenting
					oldParented[child] = nil
				end

				if EXPERIMENTAL_AUTO_NAMING and autoName ~= nil then
					child.Name = autoName
				end

			elseif kind == "State" then
				-- case 2; state object

				local value = child:get(false)
				-- allow nil to represent the absence of a child
				if value ~= nil then
					processChild(value, autoName)
				end

				local disconnect = oldDisconnects[child]
				if disconnect == nil then
					-- wasn't previously present
					disconnect = Observer(child):onChange(queueUpdate)
				else
					-- previously here; we want to reuse, so remove from old
					-- set so we don't encounter it during unparenting
					oldDisconnects[child] = nil
				end

				newDisconnects[child] = disconnect

			elseif kind == "table" then
				-- case 3; table of objects

				for key, subChild in pairs(child) do
					local keyType = typeof(key)
					local subAutoName: string? = nil

					if keyType == "string" then
						subAutoName = key
					elseif keyType == "number" and autoName ~= nil then
						subAutoName = autoName .. "_" .. key
					end

					processChild(subChild, subAutoName)
				end

			else
				logWarn("unrecognisedChildType", kind)
			end
		end

		if propValue ~= nil then
			-- `propValue` is set to nil on cleanup, so we don't process children
			-- in that case
			processChild(propValue)
		end

		-- unparent any children that are no longer present
		for oldInstance in pairs(oldParented) do
			oldInstance.Parent = nil
		end

		-- disconnect observers which weren't reused
		for oldState, disconnect in pairs(oldDisconnects) do
			disconnect()
		end
	end

	queueUpdate = function()
		if not updateQueued then
			updateQueued = true
			task.defer(updateChildren)
		end
	end

	table.insert(cleanupTasks, function()
		propValue = nil
		updateQueued = true
		updateChildren()
	end)

	-- perform initial child parenting
	updateQueued = true
	updateChildren()
end

return Children :: PubTypes.SpecialKey</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="149">
                  <Properties>
                    <string name="Name">Cleanup</string>
                    <string name="Source">--!strict

--[[
	A special key for property tables, which adds user-specified tasks to be run
	when the instance is destroyed.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

local Cleanup = {}
Cleanup.type = "SpecialKey"
Cleanup.kind = "Cleanup"
Cleanup.stage = "observer"

function Cleanup:apply(userTask: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	table.insert(cleanupTasks, userTask)
end

return Cleanup</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="150">
                  <Properties>
                    <string name="Name">Hydrate</string>
                    <string name="Source">--!strict

--[[
	Processes and returns an existing instance, with options for setting
	properties, event handlers and other attributes on the instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local applyInstanceProps = require(Package.Instances.applyInstanceProps)

local function Hydrate(target: Instance)
	return function(props: PubTypes.PropertyTable): Instance
		applyInstanceProps(props, target)
		return target
	end
end

return Hydrate</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="151">
                  <Properties>
                    <string name="Name">New</string>
                    <string name="Source">--!strict

--[[
	Constructs and returns a new instance, with options for setting properties,
	event handlers and other attributes on the instance right away.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local defaultProps = require(Package.Instances.defaultProps)
local applyInstanceProps = require(Package.Instances.applyInstanceProps)
local logError= require(Package.Logging.logError)

local function New(className: string)
	return function(props: PubTypes.PropertyTable): Instance
		local ok, instance = pcall(Instance.new, className)

		if not ok then
			logError("cannotCreateClass", nil, className)
		end

		local classDefaults = defaultProps[className]
		if classDefaults ~= nil then
			for defaultProp, defaultValue in pairs(classDefaults) do
				instance[defaultProp] = defaultValue
			end
		end

		applyInstanceProps(props, instance)

		return instance
	end
end

return New</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="152">
                  <Properties>
                    <string name="Name">OnChange</string>
                    <string name="Source">--!strict

--[[
	Constructs special keys for property tables which connect property change
	listeners to an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)

local function OnChange(propertyName: string): PubTypes.SpecialKey
	local changeKey = {}
	changeKey.type = "SpecialKey"
	changeKey.kind = "OnChange"
	changeKey.stage = "observer"

	function changeKey:apply(callback: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
		local ok, event = pcall(applyTo.GetPropertyChangedSignal, applyTo, propertyName)
		if not ok then
			logError("cannotConnectChange", nil, applyTo.ClassName, propertyName)
		elseif typeof(callback) ~= "function" then
			logError("invalidChangeHandler", nil, propertyName)
		else
			table.insert(cleanupTasks, event:Connect(function()
				callback((applyTo :: any)[propertyName])
			end))
		end
	end

	return changeKey
end

return OnChange</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="153">
                  <Properties>
                    <string name="Name">OnEvent</string>
                    <string name="Source">--!strict

--[[
	Constructs special keys for property tables which connect event listeners to
	an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)

local function getProperty_unsafe(instance: Instance, property: string)
	return (instance :: any)[property]
end

local function OnEvent(eventName: string): PubTypes.SpecialKey
	local eventKey = {}
	eventKey.type = "SpecialKey"
	eventKey.kind = "OnEvent"
	eventKey.stage = "observer"

	function eventKey:apply(callback: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
		local ok, event = pcall(getProperty_unsafe, applyTo, eventName)
		if not ok or typeof(event) ~= "RBXScriptSignal" then
			logError("cannotConnectEvent", nil, applyTo.ClassName, eventName)
		elseif typeof(callback) ~= "function" then
			logError("invalidEventHandler", nil, eventName)
		else
			table.insert(cleanupTasks, event:Connect(callback))
		end
	end

	return eventKey
end

return OnEvent</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="154">
                  <Properties>
                    <string name="Name">Out</string>
                    <string name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which allows users to extract values from
	an instance into an automatically-updated Value object.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)
local xtypeof = require(Package.Utility.xtypeof)

local function Out(propertyName: string): PubTypes.SpecialKey
	local outKey = {}
	outKey.type = "SpecialKey"
	outKey.kind = "Out"
	outKey.stage = "observer"

	function outKey:apply(outState: any, applyTo: Instance, cleanupTasks: { PubTypes.Task })
		local ok, event = pcall(applyTo.GetPropertyChangedSignal, applyTo, propertyName)
		if not ok then
			logError("invalidOutProperty", nil, applyTo.ClassName, propertyName)
		elseif xtypeof(outState) ~= "State" or outState.kind ~= "Value" then
			logError("invalidOutType")
		else
			outState:set((applyTo :: any)[propertyName])
			table.insert(
				cleanupTasks,
				event:Connect(function()
					outState:set((applyTo :: any)[propertyName])
				end)
			)
			table.insert(cleanupTasks, function()
				outState:set(nil)
			end)
		end
	end

	return outKey
end

return Out
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="155">
                  <Properties>
                    <string name="Name">Ref</string>
                    <string name="Source">--!strict

--[[
	A special key for property tables, which stores a reference to the instance
	in a user-provided Value object.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)
local xtypeof = require(Package.Utility.xtypeof)

local Ref = {}
Ref.type = "SpecialKey"
Ref.kind = "Ref"
Ref.stage = "observer"

function Ref:apply(refState: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	if xtypeof(refState) ~= "State" or refState.kind ~= "Value" then
		logError("invalidRefType")
	else
		refState:set(applyTo)
		table.insert(cleanupTasks, function()
			refState:set(nil)
		end)
	end
end

return Ref</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="156">
                  <Properties>
                    <string name="Name">applyInstanceProps</string>
                    <string name="Source">--!strict

--[[
	Applies a table of properties to an instance, including binding to any
	given state objects and applying any special keys.

	No strong reference is kept by default - special keys should take care not
	to accidentally hold strong references to instances forever.

	If a key is used twice, an error will be thrown. This is done to avoid
	double assignments or double bindings. However, some special keys may want
	to enable such assignments - in which case unique keys should be used for
	each occurence.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local cleanup = require(Package.Utility.cleanup)
local xtypeof = require(Package.Utility.xtypeof)
local logError = require(Package.Logging.logError)
local Observer = require(Package.State.Observer)

local function setProperty_unsafe(instance: Instance, property: string, value: any)
	(instance :: any)[property] = value
end

local function testPropertyAssignable(instance: Instance, property: string)
	(instance :: any)[property] = (instance :: any)[property]
end

local function setProperty(instance: Instance, property: string, value: any)
	if not pcall(setProperty_unsafe, instance, property, value) then
		if not pcall(testPropertyAssignable, instance, property) then
			if instance == nil then
				-- reference has been lost
				logError("setPropertyNilRef", nil, property, tostring(value))
			else
				-- property is not assignable
				logError("cannotAssignProperty", nil, instance.ClassName, property)
			end
		else
			-- property is assignable, but this specific assignment failed
			-- this typically implies the wrong type was received
			local givenType = typeof(value)
			local expectedType = typeof((instance :: any)[property])
			logError("invalidPropertyType", nil, instance.ClassName, property, expectedType, givenType)
		end
	end
end

local function bindProperty(instance: Instance, property: string, value: PubTypes.CanBeState&lt;any>, cleanupTasks: {PubTypes.Task})
	if xtypeof(value) == "State" then
		-- value is a state object - assign and observe for changes
		local willUpdate = false
		local function updateLater()
			if not willUpdate then
				willUpdate = true
				task.defer(function()
					willUpdate = false
					setProperty(instance, property, value:get(false))
				end)
			end
		end

		setProperty(instance, property, value:get(false))
		table.insert(cleanupTasks, Observer(value :: any):onChange(updateLater))
	else
		-- value is a constant - assign once only
		setProperty(instance, property, value)
	end
end

local function applyInstanceProps(props: PubTypes.PropertyTable, applyTo: Instance)
	local specialKeys = {
		self = {} :: {[PubTypes.SpecialKey]: any},
		descendants = {} :: {[PubTypes.SpecialKey]: any},
		ancestor = {} :: {[PubTypes.SpecialKey]: any},
		observer = {} :: {[PubTypes.SpecialKey]: any}
	}
	local cleanupTasks = {}

	for key, value in pairs(props) do
		local keyType = xtypeof(key)

		if keyType == "string" then
			if key ~= "Parent" then
				bindProperty(applyTo, key :: string, value, cleanupTasks)
			end
		elseif keyType == "SpecialKey" then
			local stage = (key :: PubTypes.SpecialKey).stage
			local keys = specialKeys[stage]
			if keys == nil then
				logError("unrecognisedPropertyStage", nil, stage)
			else
				keys[key] = value
			end
		else
			-- we don't recognise what this key is supposed to be
			logError("unrecognisedPropertyKey", nil, xtypeof(key))
		end
	end

	for key, value in pairs(specialKeys.self) do
		key:apply(value, applyTo, cleanupTasks)
	end
	for key, value in pairs(specialKeys.descendants) do
		key:apply(value, applyTo, cleanupTasks)
	end

	if props.Parent ~= nil then
		bindProperty(applyTo, "Parent", props.Parent, cleanupTasks)
	end

	for key, value in pairs(specialKeys.ancestor) do
		key:apply(value, applyTo, cleanupTasks)
	end
	for key, value in pairs(specialKeys.observer) do
		key:apply(value, applyTo, cleanupTasks)
	end

	applyTo.Destroying:Connect(function()
		cleanup(cleanupTasks)
	end)
end

return applyInstanceProps</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="157">
                  <Properties>
                    <string name="Name">defaultProps</string>
                    <string name="Source"><![CDATA[--!strict

--[[
	Stores 'sensible default' properties to be applied to instances created by
	the New function.
]]

return {
	ScreenGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	},

	BillboardGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	},

	SurfaceGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,

		SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud,
		PixelsPerStud = 50
	},

	Frame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ScrollingFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ScrollBarImageColor3 = Color3.new(0, 0, 0)
	},

	TextLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextBox = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ClearTextOnFocus = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	ImageLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ImageButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false
	},

	ViewportFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	VideoFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},
	
	CanvasGroup = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	}
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="158">
                <Properties>
                  <string name="Name">Logging</string>
                </Properties>
                <Item class="ModuleScript" referent="159">
                  <Properties>
                    <string name="Name">logError</string>
                    <string name="Source">--!strict

--[[
	Utility function to log a Fusion-specific error.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logError(messageID: string, errObj: Types.Error?, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	error(errorString:gsub("\n", "\n    "), 0)
end

return logError</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="160">
                  <Properties>
                    <string name="Name">logErrorNonFatal</string>
                    <string name="Source">--!strict

--[[
	Utility function to log a Fusion-specific error, without halting execution.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logErrorNonFatal(messageID: string, errObj: Types.Error?, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	task.spawn(function(...)
		error(errorString:gsub("\n", "\n    "), 0)
	end, ...)
end

return logErrorNonFatal</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="161">
                  <Properties>
                    <string name="Name">logWarn</string>
                    <string name="Source">--!strict

--[[
	Utility function to log a Fusion-specific warning.
]]

local Package = script.Parent.Parent
local messages = require(Package.Logging.messages)

local function logWarn(messageID, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	warn(string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...))
end

return logWarn</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="162">
                  <Properties>
                    <string name="Name">messages</string>
                    <string name="Source">--!strict

--[[
	Stores templates for different kinds of logging messages.
]]

return {
	cannotAssignProperty = "The class type '%s' has no assignable property '%s'.",
	cannotConnectChange = "The %s class doesn't have a property called '%s'.",
	cannotConnectEvent = "The %s class doesn't have an event called '%s'.",
	cannotCreateClass = "Can't create a new instance of class '%s'.",
	computedCallbackError = "Computed callback error: ERROR_MESSAGE",
	destructorNeededValue = "To save instances into Values, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededComputed = "To return instances from Computeds, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	multiReturnComputed = "Returning multiple values from Computeds is discouraged, as behaviour will change soon - see discussion #189 on GitHub.",
	destructorNeededForKeys = "To return instances from ForKeys, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededForValues = "To return instances from ForValues, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededForPairs = "To return instances from ForPairs, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	duplicatePropertyKey = "",
	forKeysProcessorError = "ForKeys callback error: ERROR_MESSAGE",
	forKeysKeyCollision = "ForKeys should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previously input key: '%s'; New input key: '%s'",
	forKeysDestructorError = "ForKeys destructor error: ERROR_MESSAGE",
	forPairsDestructorError = "ForPairs destructor error: ERROR_MESSAGE",
	forPairsKeyCollision = "ForPairs should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previous input pair: '[%s] = %s'; New input pair: '[%s] = %s'",
	forPairsProcessorError = "ForPairs callback error: ERROR_MESSAGE",
	forValuesProcessorError = "ForValues callback error: ERROR_MESSAGE",
	forValuesDestructorError = "ForValues destructor error: ERROR_MESSAGE",
	invalidChangeHandler = "The change handler for the '%s' property must be a function.",
	invalidEventHandler = "The handler for the '%s' event must be a function.",
	invalidPropertyType = "'%s.%s' expected a '%s' type, but got a '%s' type.",
	invalidRefType = "Instance refs must be Value objects.",
	invalidOutType = "[Out] properties must be given Value objects.",
	invalidOutProperty = "The %s class doesn't have a property called '%s'.",
	invalidSpringDamping = "The damping ratio for a spring must be >= 0. (damping was %.2f)",
	invalidSpringSpeed = "The speed of a spring must be >= 0. (speed was %.2f)",
	mistypedSpringDamping = "The damping ratio for a spring must be a number. (got a %s)",
	mistypedSpringSpeed = "The speed of a spring must be a number. (got a %s)",
	mistypedTweenInfo = "The tween info of a tween must be a TweenInfo. (got a %s)",
	springTypeMismatch = "The type '%s' doesn't match the spring's type '%s'.",
	strictReadError = "'%s' is not a valid member of '%s'.",
	unknownMessage = "Unknown error: ERROR_MESSAGE",
	unrecognisedChildType = "'%s' type children aren't accepted by `[Children]`.",
	unrecognisedPropertyKey = "'%s' keys aren't accepted in property tables.",
	unrecognisedPropertyStage = "'%s' isn't a valid stage for a special key to be applied at."
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="163">
                  <Properties>
                    <string name="Name">parseError</string>
                    <string name="Source">--!strict

--[[
	An xpcall() error handler to collect and parse useful information about
	errors, such as clean messages and stack traces.

	TODO: this should have a 'type' field for runtime type checking!
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

local function parseError(err: string): Types.Error
	return {
		type = "Error",
		raw = err,
		message = err:gsub("^.+:%d+:%s*", ""),
		trace = debug.traceback(nil, 2)
	}
end

return parseError</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="164">
                <Properties>
                  <string name="Name">PubTypes</string>
                  <string name="Source">--!strict

--[[
	Stores common public-facing type information for Fusion APIs.
]]

type Set&lt;T> = {[T]: any}

--[[
	General use types
]]

-- A unique symbolic value.
export type Symbol = {
	type: string, -- replace with "Symbol" when Luau supports singleton types
	name: string
}

-- Types that can be expressed as vectors of numbers, and so can be animated.
export type Animatable =
	number |
	CFrame |
	Color3 |
	ColorSequenceKeypoint |
	DateTime |
	NumberRange |
	NumberSequenceKeypoint |
	PhysicalProperties |
	Ray |
	Rect |
	Region3 |
	Region3int16 |
	UDim |
	UDim2 |
	Vector2 |
	Vector2int16 |
	Vector3 |
	Vector3int16

-- A task which can be accepted for cleanup.
export type Task =
	Instance |
	RBXScriptConnection |
	() -> () |
	{destroy: (any) -> ()} |
	{Destroy: (any) -> ()} |
	{Task}

-- Script-readable version information.
export type Version = {
	major: number,
	minor: number,
	isRelease: boolean
}
--[[
	Generic reactive graph types
]]

-- A graph object which can have dependents.
export type Dependency = {
	dependentSet: Set&lt;Dependent>
}

-- A graph object which can have dependencies.
export type Dependent = {
	update: (Dependent) -> boolean,
	dependencySet: Set&lt;Dependency>
}

-- An object which stores a piece of reactive state.
export type StateObject&lt;T> = Dependency &amp; {
	type: string, -- replace with "State" when Luau supports singleton types
	kind: string,
	get: (StateObject&lt;T>, asDependency: boolean?) -> T
}

-- Either a constant value of type T, or a state object containing type T.
export type CanBeState&lt;T> = StateObject&lt;T> | T

--[[
	Specific reactive graph types
]]

-- A state object whose value can be set at any time by the user.
export type Value&lt;T> = StateObject&lt;T> &amp; {
	-- kind: "State" (add this when Luau supports singleton types)
 	set: (Value&lt;T>, newValue: any, force: boolean?) -> ()
}

-- A state object whose value is derived from other objects using a callback.
export type Computed&lt;T> = StateObject&lt;T> &amp; Dependent &amp; {
	-- kind: "Computed" (add this when Luau supports singleton types)
}

-- A state object whose value is derived from other objects using a callback.
export type ForPairs&lt;KO, VO> = StateObject&lt;{ [KO]: VO }> &amp; Dependent &amp; {
	-- kind: "ForPairs" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForKeys&lt;KO, V> = StateObject&lt;{ [KO]: V }> &amp; Dependent &amp; {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForValues&lt;K, VO> = StateObject&lt;{ [K]: VO }> &amp; Dependent &amp; {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using tweens.
export type Tween&lt;T> = StateObject&lt;T> &amp; Dependent &amp; {
	-- kind: "Tween" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using spring simulation.
export type Spring&lt;T> = StateObject&lt;T> &amp; Dependent &amp; {
	-- kind: "Spring" (add this when Luau supports singleton types)
	-- Uncomment when ENABLE_PARAM_SETTERS is enabled
	-- setPosition: (Spring&lt;T>, newValue: Animatable) -> (),
	-- setVelocity: (Spring&lt;T>, newValue: Animatable) -> (),
	-- addVelocity: (Spring&lt;T>, deltaValue: Animatable) -> ()
}

-- An object which can listen for updates on another state object.
export type Observer = Dependent &amp; {
	-- kind: "Observer" (add this when Luau supports singleton types)
  	onChange: (Observer, callback: () -> ()) -> (() -> ())
}

--[[
	Instance related types
]]

-- Denotes children instances in an instance or component's property table.
export type SpecialKey = {
	type: string, -- replace with "SpecialKey" when Luau supports singleton types
	kind: string,
	stage: string, -- replace with "self" | "descendants" | "ancestor" | "observer" when Luau supports singleton types
	apply: (SpecialKey, value: any, applyTo: Instance, cleanupTasks: {Task}) -> ()
}

-- A collection of instances that may be parented to another instance.
export type Children = Instance | StateObject&lt;Children> | {[any]: Children}

-- A table that defines an instance's properties, handlers and children.
export type PropertyTable = {[string | SpecialKey]: any}

return nil</string>
                </Properties>
              </Item>
              <Item class="Folder" referent="165">
                <Properties>
                  <string name="Name">State</string>
                </Properties>
                <Item class="ModuleScript" referent="166">
                  <Properties>
                    <string name="Name">Computed</string>
                    <string name="Source">--!nonstrict

--[[
	Constructs and returns objects which can be used to model derived reactive
	state.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logWarn = require(Package.Logging.logWarn)
local isSimilar = require(Package.Utility.isSimilar)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the last cached value calculated by this Computed object.
	The computed object will be registered as a dependency unless `asDependency`
	is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Recalculates this Computed's cached value and dependencies.
	Returns true if it changed, or false if it's identical.
]]
function class:update(): boolean
	-- remove this object from its dependencies' dependent sets
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	-- we need to create a new, empty dependency set to capture dependencies
	-- into, but in case there's an error, we want to restore our old set of
	-- dependencies. by using this table-swapping solution, we can avoid the
	-- overhead of allocating new tables each update.
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	local ok, newValue, newMetaValue = captureDependencies(self.dependencySet, self._processor)

	if ok then
		if self._destructor == nil and needsDestruction(newValue) then
			logWarn("destructorNeededComputed")
		end

		if newMetaValue ~= nil then
			logWarn("multiReturnComputed")
		end

		local oldValue = self._value
		local similar = isSimilar(oldValue, newValue)
		if self._destructor ~= nil then
			self._destructor(oldValue)
		end
		self._value = newValue

		-- add this object to the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return not similar
	else
		-- this needs to be non-fatal, because otherwise it'd disrupt the
		-- update process
		logErrorNonFatal("computedCallbackError", newValue)

		-- restore old dependencies, because the new dependencies may be corrupt
		self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet

		-- restore this object in the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return false
	end
end

local function Computed&lt;T>(processor: () -> T, destructor: ((T) -> ())?): Types.Computed&lt;T>
	local self = setmetatable({
		type = "State",
		kind = "Computed",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},
		_processor = processor,
		_destructor = destructor,
		_value = nil,
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return Computed</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="167">
                  <Properties>
                    <string name="Name">ForKeys</string>
                    <string name="Source">--!nonstrict

--[[
	Constructs a new ForKeys state object which maps keys of an array using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up
	calculated keys. If omitted, the default cleanup function will be used instead.

	Optionally, a `meta` value can be returned in the processor function as the
	second value to pass data from the processor to the destructor.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForKeys object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end


--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- a dependency used during generation of this value has changed

	It will recalculate those key pairs, storing information about any
	dependencies used in the processor callback during output key generation,
	and save the new key to the output array with the same value. If it is
	overwriting an older value, that older value will be passed to the
	destructor for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their output keys from the output table and pass them to the destructor.
]]

function class:update(): boolean
	local inputIsState = self._inputIsState
	local newInputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local oldInputTable = self._oldInputTable
	local outputTable = self._outputTable

	local keyOIMap = self._keyOIMap
	local keyIOMap = self._keyIOMap
	local meta = self._meta

	local didChange = false


	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end


	-- STEP 1: find keys that changed or were not previously present
	for newInKey, value in pairs(newInputTable) do
		-- get or create key data
		local keyData = self._keyData[newInKey]

		if keyData == nil then
			keyData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
			self._keyData[newInKey] = keyData
		end

		-- check if the key is new
		local shouldRecalculate = oldInputTable[newInKey] == nil

		-- check if the key's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end


		-- recalculate the output key if necessary
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local processOK, newOutKey, newMetaValue = captureDependencies(
				keyData.dependencySet,
				self._processor,
				newInKey
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutKey) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForKeys")
				end

				local oldInKey = keyOIMap[newOutKey]
				local oldOutKey = keyIOMap[newInKey]

				-- check for key collision
				if oldInKey ~= newInKey and newInputTable[oldInKey] ~= nil then
					logError("forKeysKeyCollision", nil, tostring(newOutKey), tostring(oldInKey), tostring(newOutKey))
				end

				-- check for a changed output key
				if oldOutKey ~= newOutKey and keyOIMap[oldOutKey] == newInKey then
					-- clean up the old calculated value
					local oldMetaValue = meta[oldOutKey]

					local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldOutKey, oldMetaValue)
					if not destructOK then
						logErrorNonFatal("forKeysDestructorError", err)
					end

					keyOIMap[oldOutKey] = nil
					outputTable[oldOutKey] = nil
					meta[oldOutKey] = nil
				end

				-- update the stored data for this key
				oldInputTable[newInKey] = value
				meta[newOutKey] = newMetaValue
				keyOIMap[newOutKey] = newInKey
				keyIOMap[newInKey] = newOutKey
				outputTable[newOutKey] = value

				-- if we had to recalculate the output, then we did change
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("forKeysProcessorError", newOutKey)
			end
		end


		-- save dependency values and add to main dependency set
		for dependency in pairs(keyData.dependencySet) do
			keyData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end


	-- STEP 2: find keys that were removed
	for outputKey, inputKey in pairs(keyOIMap) do
		if newInputTable[inputKey] == nil then
			-- clean up the old calculated value
			local oldMetaValue = meta[outputKey]

			local destructOK, err = xpcall(self._destructor or cleanup, parseError, outputKey, oldMetaValue)
			if not destructOK then
				logErrorNonFatal("forKeysDestructorError", err)
			end

			-- remove data
			oldInputTable[inputKey] = nil
			meta[outputKey] = nil
			keyOIMap[outputKey] = nil
			keyIOMap[inputKey] = nil
			outputTable[outputKey] = nil
			self._keyData[inputKey] = nil

			-- if we removed a key, then the table/state changed
			didChange = true
		end
	end

	return didChange
end

local function ForKeys&lt;KI, KO, M>(
	inputTable: PubTypes.CanBeState&lt;{ [KI]: any }>,
	processor: (KI) -> (KO, M?),
	destructor: (KO, M?) -> ()?
): Types.ForKeys&lt;KI, KO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForKeys",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_keyOIMap = {},
		_keyIOMap = {},
		_keyData = {},
		_meta = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForKeys</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="168">
                  <Properties>
                    <string name="Name">ForPairs</string>
                    <string name="Source">--!nonstrict

--[[
	Constructs a new ForPairs object which maps pairs of a table using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.

	Additionally, a `meta` table/value can optionally be returned to pass data created
	when running the processor to the destructor when the created object is cleaned up.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForPairs object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- their associated value has changed
	- a dependency used during generation of this value has changed

	It will recalculate those key/value pairs, storing information about any
	dependencies used in the processor callback during value generation, and
	save the new key/value pair to the output array. If it is overwriting an
	older key/value pair, that older pair will be passed to the destructor
	for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their key/value pairs from the output table and pass them to the destructor.
]]
function class:update(): boolean
	local inputIsState = self._inputIsState
	local newInputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local oldInputTable = self._oldInputTable

	local keyIOMap = self._keyIOMap
	local meta = self._meta

	local didChange = false


	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end

	-- clean out output table
	self._oldOutputTable, self._outputTable = self._outputTable, self._oldOutputTable

	local oldOutputTable = self._oldOutputTable
	local newOutputTable = self._outputTable
	table.clear(newOutputTable)

	-- Step 1: find key/value pairs that changed or were not previously present

	for newInKey, newInValue in pairs(newInputTable) do
		-- get or create key data
		local keyData = self._keyData[newInKey]

		if keyData == nil then
			keyData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
			self._keyData[newInKey] = keyData
		end


		-- check if the pair is new or changed
		local shouldRecalculate = oldInputTable[newInKey] ~= newInValue

		-- check if the pair's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end


		-- recalculate the output pair if necessary
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local processOK, newOutKey, newOutValue, newMetaValue = captureDependencies(
				keyData.dependencySet,
				self._processor,
				newInKey,
				newInValue
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutKey) or needsDestruction(newOutValue) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForPairs")
				end

				-- if this key was already written to on this run-through, throw a fatal error.
				if newOutputTable[newOutKey] ~= nil then
					-- figure out which key/value pair previously wrote to this key
					local previousNewKey, previousNewValue
					for inKey, outKey in pairs(keyIOMap) do
						if outKey == newOutKey then
							previousNewValue = newInputTable[inKey]
							if previousNewValue ~= nil then
								previousNewKey = inKey
								break
							end
						end
					end

					if previousNewKey ~= nil then
						logError(
							"forPairsKeyCollision",
							nil,
							tostring(newOutKey),
							tostring(previousNewKey),
							tostring(previousNewValue),
							tostring(newInKey),
							tostring(newInValue)
						)
					end
				end

				local oldOutValue = oldOutputTable[newOutKey]

				if oldOutValue ~= newOutValue then
					local oldMetaValue = meta[newOutKey]
					if oldOutValue ~= nil then
						local destructOK, err = xpcall(self._destructor or cleanup, parseError, newOutKey, oldOutValue, oldMetaValue)
						if not destructOK then
							logErrorNonFatal("forPairsDestructorError", err)
						end
					end

					oldOutputTable[newOutKey] = nil
				end

				-- update the stored data for this key/value pair
				oldInputTable[newInKey] = newInValue
				keyIOMap[newInKey] = newOutKey
				meta[newOutKey] = newMetaValue
				newOutputTable[newOutKey] = newOutValue

				-- if we had to recalculate the output, then we did change
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("forPairsProcessorError", newOutKey)
			end
		else
			local storedOutKey = keyIOMap[newInKey]

			-- check for key collision
			if newOutputTable[storedOutKey] ~= nil then
				-- figure out which key/value pair previously wrote to this key
				local previousNewKey, previousNewValue
				for inKey, outKey in pairs(keyIOMap) do
					if storedOutKey == outKey then
						previousNewValue = newInputTable[inKey]

						if previousNewValue ~= nil then
							previousNewKey = inKey
							break
						end
					end
				end

				if previousNewKey ~= nil then
					logError(
						"forPairsKeyCollision",
						nil,
						tostring(storedOutKey),
						tostring(previousNewKey),
						tostring(previousNewValue),
						tostring(newInKey),
						tostring(newInValue)
					)
				end
			end

			-- copy the stored key/value pair into the new output table
			newOutputTable[storedOutKey] = oldOutputTable[storedOutKey]
		end


		-- save dependency values and add to main dependency set
		for dependency in pairs(keyData.dependencySet) do
			keyData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end

	-- STEP 2: find keys that were removed
	for oldOutKey, oldOutValue in pairs(oldOutputTable) do
		-- check if this key/value pair is in the new output table
		if newOutputTable[oldOutKey] ~= oldOutValue then
			-- clean up the old output pair
			local oldMetaValue = meta[oldOutKey]
			if oldOutValue ~= nil then
				local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldOutKey, oldOutValue, oldMetaValue)
				if not destructOK then
					logErrorNonFatal("forPairsDestructorError", err)
				end
			end

			-- check if the key was completely removed from the output table
			if newOutputTable[oldOutKey] == nil then
				meta[oldOutKey] = nil
				self._keyData[oldOutKey] = nil
			end

			didChange = true
		end
	end

	for key in pairs(oldInputTable) do
		if newInputTable[key] == nil then
			oldInputTable[key] = nil
			keyIOMap[key] = nil
		end
	end

	return didChange
end

local function ForPairs&lt;KI, VI, KO, VO, M>(
	inputTable: PubTypes.CanBeState&lt;{ [KI]: VI }>,
	processor: (KI, VI) -> (KO, VO, M?),
	destructor: (KO, VO, M?) -> ()?
): Types.ForPairs&lt;KI, VI, KO, VO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForPairs",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_oldOutputTable = {},
		_keyIOMap = {},
		_keyData = {},
		_meta = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForPairs</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="169">
                  <Properties>
                    <string name="Name">ForValues</string>
                    <string name="Source">--!nonstrict

--[[
	Constructs a new ForValues object which maps values of a table using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.

	Additionally, a `meta` table/value can optionally be returned to pass data created
	when running the processor to the destructor when the created object is cleaned up.
]]
local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForValues object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any values meeting any of the following criteria:

	- they were not previously present
	- a dependency used during generation of this value has changed

	It will recalculate those values, storing information about any dependencies
	used in the processor callback during value generation, and save the new value
	to the output array with the same key. If it is overwriting an older value,
	that older value will be passed to the destructor for cleanup.

	Finally, this function will find values that are no longer present, and remove
	their values from the output table and pass them to the destructor. You can re-use
	the same value multiple times and this will function will update them as little as
	possible; reusing the same values where possible.
]]
function class:update(): boolean
	local inputIsState = self._inputIsState
	local inputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local outputValues = {}

	local didChange = false

	-- clean out value cache
	self._oldValueCache, self._valueCache = self._valueCache, self._oldValueCache
	local newValueCache = self._valueCache
	local oldValueCache = self._oldValueCache
	table.clear(newValueCache)

	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end


	-- STEP 1: find values that changed or were not previously present
	for inKey, inValue in pairs(inputTable) do
		-- check if the value is new or changed
		local oldCachedValues = oldValueCache[inValue]
		local shouldRecalculate = oldCachedValues == nil

		-- get a cached value and its dependency/meta data if available
		local value, valueData, meta

		if type(oldCachedValues) == "table" and #oldCachedValues > 0 then
			local valueInfo = table.remove(oldCachedValues, #oldCachedValues)
			value = valueInfo.value
			valueData = valueInfo.valueData
			meta = valueInfo.meta

			if #oldCachedValues &lt;= 0 then
				oldValueCache[inValue] = nil
			end
		elseif oldCachedValues ~= nil then
			oldValueCache[inValue] = nil
			shouldRecalculate = true
		end

		if valueData == nil then
			valueData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
		end

		-- check if the value's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(valueData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end

		-- recalculate the output value if necessary
		if shouldRecalculate then
			valueData.oldDependencySet, valueData.dependencySet = valueData.dependencySet, valueData.oldDependencySet
			table.clear(valueData.dependencySet)

			local processOK, newOutValue, newMetaValue = captureDependencies(
				valueData.dependencySet,
				self._processor,
				inValue
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutValue) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForValues")
				end

				-- pass the old value to the destructor if it exists
				if value ~= nil then
					local destructOK, err = xpcall(self._destructor or cleanup, parseError, value, meta)
					if not destructOK then
						logErrorNonFatal("forValuesDestructorError", err)
					end
				end

				-- store the new value and meta data
				value = newOutValue
				meta = newMetaValue
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				valueData.oldDependencySet, valueData.dependencySet = valueData.dependencySet, valueData.oldDependencySet

				logErrorNonFatal("forValuesProcessorError", newOutValue)
			end
		end


		-- store the value and its dependency/meta data
		local newCachedValues = newValueCache[inValue]
		if newCachedValues == nil then
			newCachedValues = {}
			newValueCache[inValue] = newCachedValues
		end

		table.insert(newCachedValues, {
			value = value,
			valueData = valueData,
			meta = meta,
		})

		outputValues[inKey] = value


		-- save dependency values and add to main dependency set
		for dependency in pairs(valueData.dependencySet) do
			valueData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end


	-- STEP 2: find values that were removed
	-- for tables of data, we just need to check if it's still in the cache
	for _oldInValue, oldCachedValueInfo in pairs(oldValueCache) do
		for _, valueInfo in ipairs(oldCachedValueInfo) do
			local oldValue = valueInfo.value
			local oldMetaValue = valueInfo.meta

			local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldValue, oldMetaValue)
			if not destructOK then
				logErrorNonFatal("forValuesDestructorError", err)
			end

			didChange = true
		end

		table.clear(oldCachedValueInfo)
	end

	self._outputTable = outputValues

	return didChange
end

local function ForValues&lt;VI, VO, M>(
	inputTable: PubTypes.CanBeState&lt;{ [any]: VI }>,
	processor: (VI) -> (VO, M?),
	destructor: (VO, M?) -> ()?
): Types.ForValues&lt;VI, VO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForValues",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_outputTable = {},
		_valueCache = {},
		_oldValueCache = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForValues</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="170">
                  <Properties>
                    <string name="Name">Observer</string>
                    <string name="Source">--!nonstrict

--[[
	Constructs a new state object which can listen for updates on another state
	object.

	FIXME: enabling strict types here causes free types to leak
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local initDependency = require(Package.Dependencies.initDependency)

type Set&lt;T> = {[T]: any}

local class = {}
local CLASS_METATABLE = {__index = class}

-- Table used to hold Observer objects in memory.
local strongRefs: Set&lt;Types.Observer> = {}

--[[
	Called when the watched state changes value.
]]
function class:update(): boolean
	for _, callback in pairs(self._changeListeners) do
		task.spawn(callback)
	end
	return false
end

--[[
	Adds a change listener. When the watched state changes value, the listener
	will be fired.

	Returns a function which, when called, will disconnect the change listener.
	As long as there is at least one active change listener, this Observer
	will be held in memory, preventing GC, so disconnecting is important.
]]
function class:onChange(callback: () -> ()): () -> ()
	local uniqueIdentifier = {}

	self._numChangeListeners += 1
	self._changeListeners[uniqueIdentifier] = callback

	-- disallow gc (this is important to make sure changes are received)
	strongRefs[self] = true

	local disconnected = false
	return function()
		if disconnected then
			return
		end
		disconnected = true
		self._changeListeners[uniqueIdentifier] = nil
		self._numChangeListeners -= 1

		if self._numChangeListeners == 0 then
			-- allow gc if all listeners are disconnected
			strongRefs[self] = nil
		end
	end
end

local function Observer(watchedState: PubTypes.Value&lt;any>): Types.Observer
	local self = setmetatable({
		type = "State",
		kind = "Observer",
		dependencySet = {[watchedState] = true},
		dependentSet = {},
		_changeListeners = {},
		_numChangeListeners = 0,
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the watched state's dependent set
	watchedState.dependentSet[self] = true

	return self
end

return Observer</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="171">
                  <Properties>
                    <string name="Name">Value</string>
                    <string name="Source">--!nonstrict

--[[
	Constructs and returns objects which can be used to model independent
	reactive state.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)
local isSimilar = require(Package.Utility.isSimilar)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the value currently stored in this State object.
	The state object will be registered as a dependency unless `asDependency` is
	false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Updates the value stored in this State object.

	If `force` is enabled, this will skip equality checks and always update the
	state object and any dependents - use this with care as this can lead to
	unnecessary updates.
]]
function class:set(newValue: any, force: boolean?)
	local oldValue = self._value
	if force or not isSimilar(oldValue, newValue) then
		self._value = newValue
		updateAll(self)
	end
end

local function Value&lt;T>(initialValue: T): Types.State&lt;T>
	local self = setmetatable({
		type = "State",
		kind = "Value",
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_value = initialValue
	}, CLASS_METATABLE)

	initDependency(self)

	return self
end

return Value</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="172">
                  <Properties>
                    <string name="Name">unwrap</string>
                    <string name="Source">--!strict

--[[
	A common interface for accessing the values of state objects or constants.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local xtypeof = require(Package.Utility.xtypeof)

local function unwrap&lt;T>(item: PubTypes.CanBeState&lt;T>, useDependency: boolean?): T
	return if xtypeof(item) == "State" then (item :: PubTypes.StateObject&lt;T>):get(useDependency) else (item :: T)
end

return unwrap</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="173">
                <Properties>
                  <string name="Name">Types</string>
                  <string name="Source">--!strict

--[[
	Stores common type information used internally.

	These types may be used internally so Fusion code can type-check, but
	should never be exposed to public users, as these definitions are fair game
	for breaking changes.
]]

local Package = script.Parent
local PubTypes = require(Package.PubTypes)

type Set&lt;T> = {[T]: any}

--[[
	General use types
]]

-- A symbol that represents the absence of a value.
export type None = PubTypes.Symbol &amp; {
	-- name: "None" (add this when Luau supports singleton types)
}

-- Stores useful information about Luau errors.
export type Error = {
	type: string, -- replace with "Error" when Luau supports singleton types
	raw: string,
	message: string,
	trace: string
}

--[[
	Specific reactive graph types
]]

-- A state object whose value can be set at any time by the user.
export type State&lt;T> = PubTypes.Value&lt;T> &amp; {
	_value: T
}

-- A state object whose value is derived from other objects using a callback.
export type Computed&lt;T> = PubTypes.Computed&lt;T> &amp; {
	_oldDependencySet: Set&lt;PubTypes.Dependency>,
	_callback: () -> T,
	_value: T
}

-- A state object whose value is derived from other objects using a callback.
export type ForPairs&lt;KI, VI, KO, VO, M> = PubTypes.ForPairs&lt;KO, VO> &amp; {
	_oldDependencySet: Set&lt;PubTypes.Dependency>,
	_processor: (KI, VI) -> (KO, VO),
	_destructor: (VO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState&lt;{ [KI]: VI }>,
	_oldInputTable: { [KI]: VI },
	_outputTable: { [KO]: VO },
	_oldOutputTable: { [KO]: VO },
	_keyIOMap: { [KI]: KO },
	_meta: { [KO]: M? },
	_keyData: {
		[KI]: {
			dependencySet: Set&lt;PubTypes.Dependency>,
			oldDependencySet: Set&lt;PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object whose value is derived from other objects using a callback.
export type ForKeys&lt;KI, KO, M> = PubTypes.ForKeys&lt;KO, any> &amp; {
	_oldDependencySet: Set&lt;PubTypes.Dependency>,
	_processor: (KI) -> (KO),
	_destructor: (KO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState&lt;{ [KI]: KO }>,
	_oldInputTable: { [KI]: KO },
	_outputTable: { [KO]: any },
	_keyOIMap: { [KO]: KI },
	_meta: { [KO]: M? },
	_keyData: {
		[KI]: {
			dependencySet: Set&lt;PubTypes.Dependency>,
			oldDependencySet: Set&lt;PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object whose value is derived from other objects using a callback.
export type ForValues&lt;VI, VO, M> = PubTypes.ForValues&lt;any, VO> &amp; {
	_oldDependencySet: Set&lt;PubTypes.Dependency>,
	_processor: (VI) -> (VO),
	_destructor: (VO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState&lt;{ [VI]: VO }>,
	_outputTable: { [any]: VI },
	_valueCache: { [VO]: any },
	_oldValueCache: { [VO]: any },
	_meta: { [VO]: M? },
	_valueData: {
		[VI]: {
			dependencySet: Set&lt;PubTypes.Dependency>,
			oldDependencySet: Set&lt;PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object which follows another state object using tweens.
export type Tween&lt;T> = PubTypes.Tween&lt;T> &amp; {
	_goalState: State&lt;T>,
	_tweenInfo: TweenInfo,
	_prevValue: T,
	_nextValue: T,
	_currentValue: T,
	_currentTweenInfo: TweenInfo,
	_currentTweenDuration: number,
	_currentTweenStartTime: number,
	_currentlyAnimating: boolean
}

-- A state object which follows another state object using spring simulation.
export type Spring&lt;T> = PubTypes.Spring&lt;T> &amp; {
	_speed: PubTypes.CanBeState&lt;number>,
	_speedIsState: boolean,
	_lastSpeed: number,
	_damping: PubTypes.CanBeState&lt;number>,
	_dampingIsState: boolean,
	_lastDamping: number,
	_goalState: State&lt;T>,
	_goalValue: T,
	_currentType: string,
	_currentValue: T,
	_springPositions: {number},
	_springGoals: {number},
	_springVelocities: {number}
}

-- An object which can listen for updates on another state object.
export type Observer = PubTypes.Observer &amp; {
	_changeListeners: Set&lt;() -> ()>,
	_numChangeListeners: number
}

return nil</string>
                </Properties>
              </Item>
              <Item class="Folder" referent="174">
                <Properties>
                  <string name="Name">Utility</string>
                </Properties>
                <Item class="ModuleScript" referent="175">
                  <Properties>
                    <string name="Name">None</string>
                    <string name="Source">--!strict

--[[
	A symbol for representing nil values in contexts where nil is not usable.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

return {
	type = "Symbol",
	name = "None"
} :: Types.None</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="176">
                  <Properties>
                    <string name="Name">cleanup</string>
                    <string name="Source">--!strict

--[[
	Cleans up the tasks passed in as the arguments.
	A task can be any of the following:

	- an Instance - will be destroyed
	- an RBXScriptConnection - will be disconnected
	- a function - will be run
	- a table with a `Destroy` or `destroy` function - will be called
	- an array - `cleanup` will be called on each item
]]

local function cleanupOne(task: any)
	local taskType = typeof(task)

	-- case 1: Instance
	if taskType == "Instance" then
		task:Destroy()

	-- case 2: RBXScriptConnection
	elseif taskType == "RBXScriptConnection" then
		task:Disconnect()

	-- case 3: callback
	elseif taskType == "function" then
		task()

	elseif taskType == "table" then
		-- case 4: destroy() function
		if typeof(task.destroy) == "function" then
			task:destroy()

		-- case 5: Destroy() function
		elseif typeof(task.Destroy) == "function" then
			task:Destroy()

		-- case 6: array of tasks
		elseif task[1] ~= nil then
			for _, subtask in ipairs(task) do
				cleanupOne(subtask)
			end
		end
	end
end

local function cleanup(...: any)
	for index = 1, select("#", ...) do
		cleanupOne(select(index, ...))
	end
end

return cleanup</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="177">
                  <Properties>
                    <string name="Name">doNothing</string>
                    <string name="Source">--!strict

--[[
	An empty function. Often used as a destructor to indicate no destruction.
]]

local function doNothing(...: any)
end

return doNothing</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="178">
                  <Properties>
                    <string name="Name">isSimilar</string>
                    <string name="Source">--!strict
--[[
    Returns true if A and B are 'similar' - i.e. any user of A would not need
    to recompute if it changed to B.
]]

local function isSimilar(a: any, b: any): boolean
    -- HACK: because tables are mutable data structures, don't make assumptions
    -- about similarity from equality for now (see issue #44)
    if typeof(a) == "table" then
        return false
    else
        return a == b
    end
end

return isSimilar</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="179">
                  <Properties>
                    <string name="Name">needsDestruction</string>
                    <string name="Source">--!strict

--[[
    Returns true if the given value is not automatically memory managed, and
    requires manual cleanup.
]]

local function needsDestruction(x: any): boolean
    return typeof(x) == "Instance"
end

return needsDestruction</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="180">
                  <Properties>
                    <string name="Name">restrictRead</string>
                    <string name="Source">--!strict

--[[
	Restricts the reading of missing members for a table.
]]

local Package = script.Parent.Parent
local logError = require(Package.Logging.logError)

type table = {[any]: any}

local function restrictRead(tableName: string, strictTable: table): table
	-- FIXME: Typed Luau doesn't recognise this correctly yet
	local metatable = getmetatable(strictTable :: any)

	if metatable == nil then
		metatable = {}
		setmetatable(strictTable, metatable)
	end

	function metatable:__index(memberName)
		logError("strictReadError", nil, tostring(memberName), tableName)
	end

	return strictTable
end

return restrictRead</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="181">
                  <Properties>
                    <string name="Name">xtypeof</string>
                    <string name="Source">--!strict

--[[
	Extended typeof, designed for identifying custom objects.
	If given a table with a `type` string, returns that.
	Otherwise, returns `typeof()` the argument.
]]

local function xtypeof(x: any)
	local typeString = typeof(x)

	if typeString == "table" and typeof(x.type) == "string" then
		return x.type
	else
		return typeString
	end
end

return xtypeof</string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="182">
            <Properties>
              <string name="Name">jsnatives</string>
            </Properties>
            <Item class="ModuleScript" referent="183">
              <Properties>
                <string name="Name">out</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local Proxy = TS.import(script, script, "proxy").default
local JSON = TS.import(script, script, "json").default
local Object = TS.import(script, script, "object").Object
local ArrayUtils = TS.import(script, script, "array_utils").default
local Number = TS.import(script, script, "number").default
local Error = TS.import(script, script, "error")
local Symbol = TS.import(script, script, "symbol").default
local SetUtils = TS.import(script, script, "set_utils").default
local String = TS.import(script, script, "string").default
local inspect = TS.import(script, script, "inspect").default
local console = TS.import(script, script, "console").default
local encodeUriComponent = TS.import(script, script, "encodeUriComponent").default
local _timers = TS.import(script, script, "timers")
local setTimeout = _timers.setTimeout
local clearTimeout = _timers.clearTimeout
local setInterval = _timers.setInterval
local clearInterval = _timers.clearInterval
return {
	Proxy = Proxy,
	Object = Object,
	JSON = JSON,
	ArrayUtils = ArrayUtils,
	Number = Number,
	Error = Error,
	Symbol = Symbol,
	String = String,
	inspect = inspect,
	console = console,
	SetUtils = SetUtils,
	encodeUriComponent = encodeUriComponent,
	setTimeout = setTimeout,
	clearTimeout = clearTimeout,
	setInterval = setInterval,
	clearInterval = clearInterval,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="184">
                <Properties>
                  <string name="Name">array_utils</string>
                  <string name="Source">--!nocheck
local Object = require(script.Parent.object).Object

local ArrayUtils = {}

-- tips found at https://github.com/Roblox/luau-polyfill/blob/main/modules/collections/src/Array/isArray.lua
-- for me, deepcheck is in most of cases not needed, because roblox-ts's handling of arrays avoid majority of the issues
-- looking for issues to change the behavior, may change deepcheck default in future
function ArrayUtils.isArray(object, deepCheck)
  if type(object) ~= "table" then return false end

  if next(object) == nil then return true end -- empty table is an array

  local length = #object

  if length == 0 then return false end -- non 0 length with next returning something is not an array

  if deepCheck == nil or not deepCheck then
    return true -- avoid expansive calculation if deepCheck is not true or not provided
  end

  local count = 0
  local sum = 0
  for _, key in Object.keys(object) do -- use of object.keys to avoid triggering __index in proxies
    if type(key) ~= "number" then return false end
    if key % 1 ~= 0 or key &lt; 1 or key > length then return false end
    count += 1
    sum += key
  end

  return count == length and sum == length * (length + 1) / 2
end

function ArrayUtils.concat(arrayOrValue, ...)
  local array
  if not ArrayUtils.isArray(arrayOrValue) then 
    array = { arrayOrValue }
  else
    array = Object.dup(arrayOrValue)
  end

  for i=1, select("#", ...) do
    local source = select(i, ...)
    if not ArrayUtils.isArray(source) then 
      source = { source }
    end
    for _, v in source do
      array[#array + 1] = v
    end
  end
  return array
end

function ArrayUtils.flat(array, depth)
  if depth == nil or type(depth) ~= "number" then depth = 1 end
  if not ArrayUtils.isArray(array) then return array end

  if depth &lt; 1 then return array end
  
  local out = {}

  for _, v in array do
    if ArrayUtils.isArray(v) then
      for _, v2 in ArrayUtils.flat(v, depth - 1) do
        out[#out + 1] = v2
      end
    else
      out[#out + 1] = v
    end
  end

  return out
end

function ArrayUtils.flatMap(array, func)
  if type(func) ~= "function" then error("func must be a function") end
  if not ArrayUtils.isArray(array) then error("array must be an array") end

  local out = {}
  for i, v in array do
    out[i] = func(v, i, array)
  end
  return ArrayUtils.flat(out)
end

function ArrayUtils.reverse(array)
  if not ArrayUtils.isArray(array) then error("array must be an array") end

  local endIndex = #array
	local index = 1
	while index &lt; endIndex do
		array[index], array[endIndex] = array[endIndex], array[index]
		index += 1
		endIndex -= 1
	end
	return array
end

function ArrayUtils.toReversed(array)
  if not ArrayUtils.isArray(array) then error("array must be an array") end

  return ArrayUtils.reverse(Object.dup(array))
end

function ArrayUtils.slice(array, start, ends)
  if not ArrayUtils.isArray(array) then error("array must be an array") end

                                                          -- For an array [1, 2, 3, 4, 5]
  if start == nil then start = 0 end                      -- if start is nil, set it to 0
  if type(start) ~= "number" then error("start must be a number") end
  if start &lt; 0 then start = #array - (start * -1) end     -- if start is -2, then it's 3
  if start &lt; 0 then start = 0 end                         -- if start is still negative, set it to 0
  if ends == nil then ends = #array - 1 end               -- if ends is nil, set it to the last index
  if type(ends) ~= "number" then error("ends must be a number") end
  if ends &lt; 0 then ends = #array - (ends * -1) end        -- if ends is -1, then it's 4
  if ends &lt; 0 then ends = 0 end                           -- if ends is still negative, set it to 0
  if ends > #array then ends = #array end                 -- if ends is greater than the last index, set it to the last index
  if start >= ends then return {} end                     -- if start is greater than or equal to ends, return an empty array

  -- convert js indexing to lua indexing
  start += 1
  ends += 1

  local out = {}
  for i=start, ends - 1 do
    out[#out + 1] = array[i]
  end
  return out
end

function ArrayUtils.splice(array, start, count, ...)
  if not ArrayUtils.isArray(array) then error("array must be an array") end
                                                          -- For an array [1, 2, 3, 4, 5]
  if start == nil then start = 0 end                      -- if start is nil, set it to 0
  if type(start) ~= "number" then error("start must be a number") end
  if start &lt; 0 then start = #array - 1 - (start * -1) end -- if start is -2, then it's 3
  if start &lt; 0 then start = 0 end                         -- if start is still negative, set it to 0
  if start > #array then start = #array end               -- if start is greater than the length of the array, set it to the length of the array
  if count == nil then count = #array - start end         -- if count is nil, set it to the difference between the length of the array and start
  if type(count) ~= "number" then error("count must be a number") end
  if count &lt; 0 then count = 0 end                         -- if count is still negative, set it to 0
  if count > #array - start then count = #array - start end -- if count is greater than the difference between the length of the array and start, set it to the difference between the length of the array and start

  local ends = start + count - 1

  -- convert js indexing to lua indexing
  start += 1
  ends += 1

  local deleted = {}
  for i=start, ends do
    deleted[#deleted + 1] = table.remove(array, start)
  end

  for i = select("#", ...), 1, -1 do
    table.insert(array, start, (select(i, ...)))
  end
  
  return deleted
end


return {
  default = ArrayUtils,
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="185">
                <Properties>
                  <string name="Name">console</string>
                  <string name="Source">-- all thanks to https://github.com/howmanysmall/luau-polyfill/blob/main/src/Console/makeConsoleImpl.luau
--!nocheck
local inspect = require(script.Parent.inspect).default

local GetService = game.GetService
local attemptedGetButFailed = false
local cached: LogService? = nil

local function GetLogService(): LogService?
	if cached or attemptedGetButFailed then
		return cached
	end

	local success, value = pcall(GetService, game, "LogService")
	if not success then
		attemptedGetButFailed = true
		return nil
	end

	cached = value
	return value
end

local INDENT = "  "

local console = {}
local indentDepth = 0

local function indent()
  return string.rep(INDENT, indentDepth)
end

function console.rawLog(content, ...)
  print(content, ...)
end

function console.log(content, ...)
  local message
  if type(content) == "string" then
    message = string.format(content, ...)
  else
    message = inspect(content)
  end
  print(indent() .. message)
end

function console.debug(content, ...)
  local message
  if type(content) == "string" then
    message = string.format(content, ...)
  else
    message = inspect(content)
  end
  print(indent() .. message)
end

function console.info(content, ...)
  local message
  if type(content) == "string" then
    message = string.format(content, ...)
  else
    message = inspect(content)
  end
  print(indent() .. message)
end

function console.warn(content, ...)
  local message
  if type(content) == "string" then
    message = string.format(content, ...)
  else
    message = inspect(content)
  end
  warn(indent() .. message)
end

function console.error(content, ...)
  -- JS' `console.error` doesn't interrupt execution like Lua's `error`,
  -- which is more similar to throwing an exception in JS.
  local message
  if type(content) == "string" then
    message = string.format(content, ...)
  else
    message = inspect(content)
  end
  warn(indent() .. message)
end

function console.group(content, ...)
  local message
  if type(content) == "string" then
    message = string.format(content, ...)
  else
    message = inspect(content)
  end
  print(indent() .. message)
  indentDepth = indentDepth + 1
end

function console.groupCollapsed(content, ...)
  return console.group(content, ...)
end

function console.groupEnd()
  if indentDepth > 0 then
    indentDepth = indentDepth - 1
  end
end

local startTimes: {[string]: number} = {}
function console.time(label: string?)
  local trueLabel = label or "default"
  if startTimes[trueLabel] ~= nil then
    console.warn(`Timer '{trueLabel}' already exists`)
    return
  end

  startTimes[trueLabel] = os.clock()
end
function console.timeEnd(label: string?)
  local trueLabel = label or "default"
  local finishTime = os.clock()
  local startTime = startTimes[trueLabel]

  if startTime == nil then
    console.warn(`Timer '{trueLabel}' does not exist`)
    return
  end

  console.log(`{trueLabel}: {(finishTime - startTime) * 1000} ms`)
  startTimes[trueLabel] = nil
end

function console.clear()
  local logService = GetLogService()
  if logService then
    pcall(function()
      logService:ClearOutput()
    end)
  end
end

return {
  default = console,
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="186">
                <Properties>
                  <string name="Name">encodeUriComponent</string>
                  <string name="Source">-- reference documentation: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
--!nocheck
local HttpService = game:GetService("HttpService")
local Error = require(script.Parent.error).default
local String = require(script.Parent.string).default

local function encodeURIComponent(value: string): string
	local valueLength = utf8.len(value)
	if valueLength == 0 or valueLength == nil then
		return ""
	end
	-- we don't exhaustively test the whole string for invalid characters like ECMA-262 15.1.3 says
	local check = String.charCodeAt(value, 1)
	if valueLength == 1 then
		if check == 0xD800 then
			error(Error.new("URI malformed"))
		end
		if check == 0xDFFF then
			error(Error.new("URI malformed"))
		end
	end
	if check >= 0xDC00 and check &lt; 0xDFFF then
		error(Error.new("URI malformed"))
	end
	local encoded = HttpService:UrlEncode(value)
	-- reverting encoded chars which are not encoded by JS
	local result = string.gsub(
		string.gsub(
			string.gsub(
				string.gsub(
					string.gsub(
						string.gsub(
							string.gsub(string.gsub(string.gsub(encoded, "%%2D", "-"), "%%5F", "_"), "%%2E", "."),
							"%%21",
							"!"
						),
						"%%7E",
						"~"
					),
					"%%2A",
					"*"
				),
				"%%27",
				"'"
			),
			"%%28",
			"("
		),
		"%%29",
		")"
	)
	return result
end

return {
  default = encodeURIComponent,
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="187">
                <Properties>
                  <string name="Name">error</string>
                  <string name="Source">-- thanks to https://github.com/howmanysmall/luau-polyfill/blob/main/src/Error/Error.global.luau
export type Error = {name: string, message: string, stack: string?}
type Error_private = Error &amp; {__stack: string?}

local Error = {}

local DEFAULT_NAME = "Error"
Error.__index = Error
Error.__tostring = function(self)
	-- Luau FIXME: I can't cast to Error or Object here: Type 'Object' could not be converted into '{ @metatable *unknown*, {|  |} }'
	return getmetatable(Error :: any).__tostring(self)
end

-- ROBLOX NOTE: extracted __createError function so that both Error.new() and Error() can capture the stack trace at the same depth
local function __createError(message: string?): Error
	local self = (setmetatable({
		name = DEFAULT_NAME;
		message = message or "";
	}, Error) :: any) :: Error
	Error.__captureStackTrace(self, 4)
	return self
end

function Error.new(message: string?): Error
	return __createError(message)
end

function Error.captureStackTrace(err: Error, options: ((...any) -> any)?)
	Error.__captureStackTrace(err, 3, options)
end

function Error.__captureStackTrace(err_: Error, level: number, options: ((...any) -> any)?)
	local err = err_ :: Error_private
	if typeof(options) == "function" then
		local stack = debug.traceback(nil, level)
		local functionName: string = debug.info(options, "n")
		local sourceFilePath: string = debug.info(options, "s")

		local espacedSourceFilePath = string.gsub(sourceFilePath, "([%(%)%.%%%+%-%*%?%[%^%$])", "%%%1")
		local stacktraceLinePattern = espacedSourceFilePath .. ":%d* function " .. functionName
		local beg = string.find(stack, stacktraceLinePattern)
		local end_ = nil
		if beg ~= nil then
			beg, end_ = string.find(stack, "\n", beg + 1)
		end
		if end_ ~= nil then
			stack = string.sub(stack, end_ + 1)
		end
		err.__stack = stack
	else
		err.__stack = debug.traceback(nil, level)
	end
	Error.__recalculateStacktrace(err)
end

function Error.__recalculateStacktrace(err_: Error)
	local err = err_ :: Error_private
	local message = err.message
	local name = err.name or DEFAULT_NAME

	local errName = name .. (if message ~= nil and message ~= "" then ": " .. message else "")
	local stack = if err.__stack then err.__stack else ""

	err.stack = errName .. "\n" .. stack
end

return {
  default = setmetatable(Error, {
    __call = function(_, ...)
      return __createError(...)
    end;
    __tostring = function(self)
      if self.name ~= nil then
        if self.message and self.message ~= "" then
          return string.format("%*: %*", tostring(self.name), tostring(self.message))
        end
        return tostring(self.name)
      end
      return tostring(DEFAULT_NAME)
    end;
  })
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="188">
                <Properties>
                  <string name="Name">inspect</string>
                  <string name="Source">-- all thanks to https://github.com/howmanysmall/luau-polyfill/blob/main/src/Collections/inspect.luau
-- derived from these upstream sources:
-- https://github.com/graphql/graphql-js/blob/1951bce42092123e844763b6a8e985a8a3327511/src/jsutils/inspect.js
--!nocheck
local HttpService = game:GetService("HttpService")

local isArray = require(script.Parent.array_utils).default.isArray

-- local NULL = require(srcWorkspace.luaUtils.null)

-- Support for options partial implementation
-- see: https://nodejs.org/dist/latest-v16.x/docs/api/util.html#utilinspectobject-options
export type InspectOptions = {
	depth: number?,
}

type FormatOptions = {
	depth: number,
}

local MAX_ARRAY_LENGTH = 10
local DEFAULT_RECURSIVE_DEPTH = 2

-- deviation: pre-declare functions
local formatValue
local formatObjectValue
local formatArray
local formatObject
local getObjectTag

--[[
 * Used to print values in error messages.
 ]]
local function inspect(value, options: InspectOptions?): string
	local inspectOptions: InspectOptions = options or {depth = DEFAULT_RECURSIVE_DEPTH}
	local depth = inspectOptions.depth or DEFAULT_RECURSIVE_DEPTH
	inspectOptions.depth = if depth >= 0 then depth else DEFAULT_RECURSIVE_DEPTH
	return formatValue(value, {}, inspectOptions :: FormatOptions)
end

local function isIndexKey(k, contiguousLength)
	return type(k) == "number"
		and k &lt;= contiguousLength -- nothing out of bounds
		and 1 &lt;= k -- nothing illegal for array indices
		and math.floor(k) == k -- no float keys
end

local function getTableLength(tbl)
	local length = 1
	local value = rawget(tbl, length)
	while value ~= nil do
		length += 1
		value = rawget(tbl, length)
	end
	return length - 1
end

local function sortKeysForPrinting(a: any, b)
	local typeofA = type(a)
	local typeofB = type(b)

	-- strings and numbers are sorted numerically/alphabetically
	if typeofA == typeofB and (typeofA == "number" or typeofA == "string") then
		return a &lt; b
	end

	-- sort the rest by type name
	return typeofA &lt; typeofB
end

local function getFragmentedKeys(tbl)
	local keys = {}
	local keysLength = 0
	local tableLength = getTableLength(tbl)
	for key in next, tbl do
		if not isIndexKey(key, tableLength) then
			keysLength += 1
			keys[keysLength] = key
		end
	end

	table.sort(keys, sortKeysForPrinting)
	return keys, keysLength, tableLength
end

function formatValue(value, seenValues, options: FormatOptions)
	local valueType = typeof(value)
	if valueType == "string" then
		return HttpService:JSONEncode(value)
		-- deviation: format numbers like in JS
	end

	if valueType == "number" then
		if value ~= value then
			return "NaN"
		end

		if value == math.huge then
			return "Infinity"
		end

		if value == -math.huge then
			return "-Infinity"
		end

		return tostring(value)
	end

	if valueType == "function" then
		local result = "[function"
		local functionName = debug.info(value :: (any) -> any, "n")
		if functionName ~= nil and functionName ~= "" then
			result ..= " " .. functionName
		end

		return result .. "]"
	end

	if valueType == "table" then
		-- ROBLOX TODO: parameterize inspect with the library-specific NULL sentinel. maybe function generics?
		-- if value == NULL then
		-- 	return 'null'
		-- end
		return formatObjectValue(value, seenValues, options)
	end

	return tostring(value)
end

function formatObjectValue(value, previouslySeenValues, options: FormatOptions)
	if table.find(previouslySeenValues, value) ~= nil then
		return "[Circular]"
	end

	local length = #previouslySeenValues
	local seenValues = table.move(previouslySeenValues, 1, length, 1, table.create(length + 1))
	seenValues[length + 1] = value

	if type(value.toJSON) == "function" then
		local jsonValue = value:toJSON(value)

		if jsonValue ~= value then
			return if type(jsonValue) == "string" then jsonValue else formatValue(jsonValue, seenValues, options)
		end
	end

	if isArray(value) then
		return formatArray(value, seenValues, options)
	end

	return formatObject(value, seenValues, options)
end

function formatObject(object, seenValues, options: FormatOptions)
	local mt = getmetatable(object)
	if mt and rawget(mt, "__tostring") then
		return tostring(object)
	end

	local fragmentedKeys, fragmentedKeysLength, keysLength = getFragmentedKeys(object)

	if keysLength == 0 and fragmentedKeysLength == 0 then
		return "{}"
	end
	if #seenValues > options.depth then
		return "[" .. getObjectTag(object) .. "]"
	end

	local properties = table.create(keysLength + fragmentedKeysLength)
	for index = 1, keysLength do
		local value = formatValue(object[index], seenValues, options)
		properties[index] = value
	end

	for index = 1, fragmentedKeysLength do
		local key = fragmentedKeys[index]
		local value = formatValue(object[key], seenValues, options)
		properties[keysLength + index] = key .. ": " .. value
	end

	return "{ " .. table.concat(properties, ", ") .. " }"
end

function formatArray(array: {[number]: any}, seenValues: {[number]: any}, options: FormatOptions): string
	local length = #array
	if length == 0 then
		return "[]"
	end
	if #seenValues > options.depth then
		return "[Array]"
	end

	local len = math.min(MAX_ARRAY_LENGTH, length)
	local remaining = length - len
	local items = table.create(len + 1)

	for index = 1, len do
		items[index] = formatValue(array[index], seenValues, options)
	end

	if remaining == 1 then
		items[len + 1] = "... 1 more item"
	elseif remaining > 1 then
		items[len + 1] = string.format("... %* more items", tostring(remaining))
	end

	return "[" .. table.concat(items, ", ") .. "]"
end

function getObjectTag(_object): string
	-- local tag = Object.prototype.toString
	-- 	.call(object)
	-- 	.replace("")
	-- 	.replace("")

	-- if tag == "Object" and typeof(object.constructor) == "function" then
	-- 	local name = object.constructor.name

	-- 	if typeof(name) == "string" and name ~= "" then
	-- 		return name
	-- 	end
	-- end

	-- return tag
	return "Object"
end

return {
  default = inspect,
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="189">
                <Properties>
                  <string name="Name">json</string>
                  <string name="Source"><![CDATA[--!nocheck
local HttpService = game:GetService("HttpService")
local Object = require(script.Parent.object).Object

local JSON = {}

function JSON.stringify(data)
  return Object.toString(data)
end

function JSON.parse(data)
  return HttpService:JSONDecode(data)
end

return {
  default = JSON,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="190">
                <Properties>
                  <string name="Name">number</string>
                  <string name="Source">-- many elements thanks to https://github.com/howmanysmall/luau-polyfill/blob/main/src/Number

local Number = {}

Number.EPSILON = 2.2204460492503e-16

Number.MAX_SAFE_INTEGER = 9007199254740991
Number.MIN_SAFE_INTEGER = -9007199254740991

Number.MAX_VALUE = 1.7976931348623157e+308
Number.MIN_VALUE = 5e-324

Number.NaN = -(0 / 0)
Number.NegativeNaN = 0 / 0

Number.NEGATIVE_INFINITY = -math.huge
Number.POSITIVE_INFINITY = math.huge

Number.isFinite = function(value: number): boolean
	return type(value) == "number" and value == value and value ~= math.huge and value ~= -math.huge
end

Number.isInteger = function(value: number): boolean
	return Number.isFinite(value) and value == math.floor(value)
end

Number.isNaN = function(value: number): boolean
	return type(value) == "number" and value ~= value
end

Number.isSafeInteger = function(value: number): boolean
	return Number.isInteger(value) and value >= Number.MIN_SAFE_INTEGER and value &lt;= Number.MAX_SAFE_INTEGER
end

-- in difference of roblox's implementations, toExponential is a prototyme methods, so, we normally are sure that the value is a number
-- we consider a nil fractionDigits as 10, like js, that expands a maximum fractionDigits is undefined
Number.toExponential = function(value: number, fractionDigits: number?): string | nil
	local num = value

  if fractionDigits == nil then fractionDigits = 10 end
  fractionDigits = math.clamp(fractionDigits :: number, 0, 100) --clamping, not crashing, even if js crashes, it avoids unexpected errors

	local formatString
	if fractionDigits == nil then
		formatString = "%e"
	else
		formatString = "%." .. tostring(fractionDigits) .. "e"
	end

	return string.gsub(string.gsub(string.gsub(string.format(formatString, num), "%+0", "+"), "%-0", "-"), "0*e", "e")
end

function extractFloatNumberFromString(value: string): string
  return value:match("^ *[-+]?%d+%.?%d*[eE][-+]?%d+") or value:match("^ *[-+]?%d*%.?%d+")
end


Number.parseFloat = function(value: unknown): number
	if type(value) == "string" then
		return tonumber(extractFloatNumberFromString(value)) or Number.NaN
	elseif type(value) == "number" then
		return value
	end

	return Number.NaN
end

local radix_chars = { "0","1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z" }

function extractIntegerNumberFromString(value: string, radix: number?): string
  if radix ~= nil then radix = math.clamp(radix :: number, 2, 36) end
  
  -- extraxt 0x, 0o, 0b prefixes and manages it with radix
  local temp = nil
  if radix == nil or radix == 16 then temp = value:match("^%s*0x(.*)") end
  if temp then 
    if radix == nil then radix = 16 end
    if radix == 16 then value = temp end
  else
    if radix == nil or radix == 8 then temp = value:match("^%s*0o(.*)") end
    if temp then 
      if radix == nil then radix = 8 end
      if radix == 8 then value = temp end
    else
      if radix == nil or radix == 2 then temp = value:match("^%s*0b(.*)") end
      if temp then 
        if radix == nil then radix = 2 end
        if radix == 2 then value = temp end
      end
    end
  end

  if radix == nil then radix = 10 end

  local r = "^%s*([0-"
  if radix &lt; 10 then r = r .. radix_chars[radix :: number] else r = r .. "9" end

  if(radix > 10) then
    r = r .. "a-" .. radix_chars[radix :: number]
    r = r .. "A-" .. radix_chars[radix :: number]:upper()
  end

  r = r .. "]+)"

  return value:match(r), radix
end

Number.parseInt = function(value: unknown, radix: number?): number
	if type(value) == "string" then
		return tonumber(extractIntegerNumberFromString(value, radix)) or Number.NaN
	elseif type(value) == "number" then
		return math.floor(value)
	end

	return Number.NaN
end

Number.toFixed = function(value: number, digits: number?): string
  if type(value) ~= "number" then
    return "nan"
  end

  return string.format("%." .. (digits or 0) .. "f", value)
end

Number.toString = function(value: number, radix: number?): string
  if radix == nil then radix = 10 end
  radix = math.clamp(radix :: number, 2, 36)

  if value == Number.NaN then return "nan" end
  if value == Number.NegativeNaN then return "-nan" end
  if value == Number.NEGATIVE_INFINITY then return "-infinity" end
  if value == Number.POSITIVE_INFINITY then return "infinity" end

  if radix == 10 then return tostring(value) end

  local isNegative = value &lt; 0
  value = math.abs(value)

  local integerPart = math.floor(value)
  local fractionalPart = value - integerPart

  local result = ""
  if isNegative then result = "-" end

  -- integer part
  local intString = ""
  if integerPart == 0 then intString = "0"
  else
    while integerPart > 0 do
      intString = radix_chars[integerPart % radix + 1] .. intString
      integerPart = math.floor(integerPart / radix)
    end
  end

  result = result .. intString

  -- fractional part
  if fractionalPart > 0 then
    result = result .. "."
    local fractionalString = ""
    while fractionalPart > 0 and #fractionalString &lt; 16 do
      fractionalPart = fractionalPart * radix
      local digit = math.floor(fractionalPart)
      fractionalString = fractionalString .. radix_chars[digit + 1]
      fractionalPart = fractionalPart - digit
    end
    result = result .. fractionalString
  end

  return result
end


return {
  default = setmetatable(Number, {
    __call = function(_, value: unknown)
      if type(value) == "number" then
          return value
      elseif type(value) == "string" then
        return Number.parseFloat(value)
      elseif type(value) == "boolean" then
        return value and 1 or 0
      elseif type(value) == "table" then
        if #value::{any} == 1 then
          return Number.parseFloat((value::{any})[1])
        end
      end

      return Number.NaN
    end
  }),
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="191">
                <Properties>
                  <string name="Name">object</string>
                  <string name="Source">---@diagnostic disable: undefined-global
--!nocheck
local HttpService = game:GetService("HttpService")

local function objK(key, value) return key end
local function objV(key, value) return value end
local function objE(key, value) return {key, value} end
local function mapObject(object, withKeys, withValues)
  local assigner = withKeys and withValues and objE or (withKeys and objK or (withValues and objV or nil))
  local res = table.create(#object)
  for k, v in object do
    res[#res + 1] = assigner(k, v)
  end
  return res
end

local function keysFromMeta(object)
  local meta = getmetatable(object)
  local fun = nil
  if meta == false then -- protected metatable
    fun = object["$$KEYS"]
  elseif meta ~= nil then
    fun = meta.__keys
  end
  if fun then -- if the function is not nil, we can use it to get the keys
    return fun(object)
  end
  return nil
end

local function keysFromMetaOrObject(object)
  local keys = keysFromMeta(object)
  if keys ~= nil then
    return keys
  end
  return mapObject(object, true, false) -- we normally map the object otherwise
end

local Object = {}

function Object.create(inherited)
  if type(inherited) ~= "table" and inherited ~= nil then error("Inherited must be an object or nil") end
  if inherited == nil then return {} end
  if type(inherited) ~= "table" then error("Inherited must be an object") end
  local obj = {}
  setmetatable(obj, { __index = inherited })
  return obj
end

function Object.keys(object)
  if type(object) ~= "table" then error("object must be a table") end
  return keysFromMetaOrObject(object)
end

function Object.entries(object)
  if type(object) ~= "table" then error("object must be a table") end
  local keys = keysFromMeta(object)
  if keys ~= nil then
    local entries = table.create(#object)
    for _, k in keys do
      entries[#entries + 1] = { k, object[k] }
    end
    return entries
  else
    return mapObject(object, true, true)
  end
end

function Object.values(object)
  if type(object) ~= "table" then error("object must be a table") end
  local keys = keysFromMeta(object)
  if keys ~= nil then
    local values = table.create(#object)
    for _, k in keys do
      values[#values + 1] = object[k]
    end
    return values
  else
    return mapObject(object, false, true)
  end
end

function Object.fromEntries(entries)
  if type(entries) ~= "table" then error("entries must be a table") end
  local obj = Object.create(#entries)
  for _, k in Object.keys(entries) do
    local entry = entries[k]
    if type(entry) ~= "table" then error("entry must be a table with 1 and 2 keys") end
    obj[entry[1]] = entry[2]
  end
  return obj
end

function Object.assign(target, ...)
  if type(target) ~= "table" then error("target must be a table") end
  for i = 1, select("#", ...) do
    local source = select(i, ...)
    if type(source) ~= "table" then error("source must be a table") end
    for _, k in Object.keys(source) do
      local v = source[k]
      target[k] = v
    end
  end
  return target
end

function Object.hasOwn(object, key)
  if type(object) ~= "table" then error("object must be a table") end
  return object[key] ~= nil and object[key] ~= Object[key]
end

function isObjectOrProxyNotAnyClass(object)
  if type(object) ~= "table" then return false end    -- not a table
  if getmetatable(object) == nil then return true end -- not has no meta
  if object["$$PROXY"] ~= nil then return true end    -- has meta but is a proxy
  return false
end

function Object.dup(object, deep, cache)
  if not isObjectOrProxyNotAnyClass(object) then return object end -- cannot duplicate complex objects
	local result = table.create(#object)
	for _, k in Object.keys(object) do
    local v = object[k]
    if deep and type(v) == "table" then
      if cache == nil then cache = {} end
      if cache[v] ~= nil then
        result[k] = cache[v]
      else
        local copy = Object.dup(v, deep, cache)
        cache[v] = copy
        result[k] = copy
      end
    else
      result[k] = v
    end
	end
	return result
end

-- better thanks to: https://github.com/Roblox/luau-polyfill/blob/main/modules/collections/src/Object/is.lua
function Object.is(a, b)
  if a == b then
    return a ~= 0 or 1 / a == 1 / b
  end
  return a ~= a and b ~= b
end

-- found thanks to https://github.com/Roblox/luau-polyfill/blob/main/modules/collections/src/Object/freeze.lua
function Object.freeze(object, deep)
  if type(object) ~= "table" then return object end
  if deep then
    for _, k in Object.keys(object) do
      object[k] = Object.freeze(object[k], deep)
    end
  end
  return table.freeze(object)
end

function Object.isFrozen(object)
  return table.isfrozen(object)
end



-- tips found thanks to https://github.com/Roblox/luau-polyfill/blob/main/modules/collections/src/Object/preventExtensions.lua
-- as no "configuration" exists in lua, the only things to do is preventing adding properties
function Object.preventExtensions(object)
  if type(object) ~= "table" then return object end
  return setmetatable(object, {
    __newindex = function(_, k) -- with extensions prevented, a property CAN be deleted, but not added
      error("Cannot add new properties to an object that has extensions prevented.")
    end,
    __metatable = false
  })
end

function Object.seal(object)
  if type(object) ~= "table" then return object end
  local keys = {}
  for _, k in Object.keys(object) do
    keys[k] = true
  end
  local function keysGetter()
    return keys
  end
  return setmetatable(object, {
    __index = function(_, k)
      if k == "$$KEYS" then
        return keysGetter
      end
      return nil
    end,
    __newindex = function(_, k)
      if not keys[k] then -- a key that was in object before can be set to nil and re-added, we are not considering keys has been deleted
        error("Cannot add new properties to an object that has extensions prevented.")
      end
    end,
    __metatable = false
  })
end

function Object.equals(a, b, deep)
	-- a[k] == b[k]
	for _, k in Object.keys(a) do
		local av = a[k]
		local bv = b[k]
		if av ~= bv then -- same table references dont need to be compared 
      if type(av) == "table" and type(bv) == "table" and deep then
        -- deeply compare the tables if deep is true
        local result = Object.equals(av, bv, deep)
        if not result then
          return false
        end
      else
        return false
      end
		end
	end

	-- extra keys in b
	for _, k in Object.keys(b) do
		if a[k] == nil then return false end
	end

	return true
end

function Object.toString(data)
	return HttpService:JSONEncode(Object.dup(data, true))
end

function Object.isEmpty(object)
	return next(object) == nil
end

function Object.isCallable(object)
  return type(object) == "function" or (
    type(object) == "table" and
    getmetatable(object) ~= nil and 
    type(getmetatable(object).__call) == "function" and (
      getmetatable(object).__callable == nil or getmetatable(object).__callable()
    )
  )
end

function Object.excludeTypes(value, types, deep)
  if not isObjectOrProxyNotAnyClass(value) then return value end -- cannot exclude types on complex objects
  local nextIndex, nextValue = next(types)
  if nextIndex == nil then return value end
  if type(nextValue) ~= "boolean" then --not a set yet
    local typesArr = types
    types = {}
    for _, t in typesArr do types[t] = true end
  elseif type(nextValue) ~= "string" and type(nextValue) ~= "boolean" then -- not a a transformed set or a string array
    error("types must be an array of strings")
  end
  for _, k in Object.keys(value) do
    local v = value[k]
    if type(v) == "table" and deep then
      value[k] = Object.excludeTypes(v, types, deep)
    end
    if types[type(v)] then
      value[k] = nil
    end
  end
  return value
end

Object.diffDeletedSymbol = {}

function Object.diff(current, other, deep)
  if not isObjectOrProxyNotAnyClass(current) or not isObjectOrProxyNotAnyClass(other) then 
    if current == other then return nil end
    return current
  end
  local diffed = Object.create(nil)
  local set = Object.create(nil)
  for _, k in Object.keys(current) do set[k] = true end
  for _, k in Object.keys(other) do set[k] = true end
  for k in set do
    local cv = current[k]
    local ov = other[k]
    if type(cv) == "table" and type(ov) == "table" and deep then
      local result = Object.diff(cv, ov, deep)
      if not Object.isEmpty(result) then
        diffed[k] = result
      end
    elseif cv == nil and ov ~= nil then
      diffed[k] = Object.diffDeletedSymbol
    elseif cv ~= ov then
      diffed[k] = cv
    end
  end
  return diffed
end

function Object.patch(current, diff, deep)
  if not isObjectOrProxyNotAnyClass(current) or not isObjectOrProxyNotAnyClass(diff) then return current end
  for _, k in Object.keys(diff) do
    local v = diff[k]
    if v == Object.diffDeletedSymbol then
      current[k] = nil
    elseif type(v) == "table" and type(current[k]) == "table" and deep then
      current[k] = Object.patch(current[k], v, deep)
    else
      current[k] = v
    end
  end
  return current
end
return { 
  Object = Object,
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="192">
                <Properties>
                  <string name="Name">proxy</string>
                  <string name="Source"><![CDATA[--!nocheck
local ObjectModule = require(script.Parent.object)
local Object = ObjectModule.Object
local Proxy = {}

Proxy.new = function (target, hooks, raw, metatableDefaults)
  if(type(target) ~= "table") then error("Target must be a table") end
  if(type(hooks) ~= "table") then error("Hooks must be a table") end
  if(type(raw) ~= "table" and raw ~= nil) then error("Raw must be a table or nil") end
  if(type(metatableDefaults) ~= "table" and metatableDefaults ~= nil) then error("Metatable defaults must be a table or nil") end

  if raw == nil then
    raw = {}
  end

  if metatableDefaults == nil then
    metatableDefaults = {}
  end

  metatableDefaults.__keys = function(proxy)
    if hooks.ownKeys then
      return hooks.ownKeys(target, proxy)
    else
      return Object.keys(target)
    end
  end

  metatableDefaults.__index = function(proxy, key)
    if key == "$$KEYS" then -- in case of protected metatable, we need to return the keys of the proxy using this reference
      return metatableDefaults.__keys
    end
    if key == "$$PROXY" then
      return proxy
    end

    if hooks.get then
      return hooks.get(target, key, proxy)
    else
      return target[key]
    end
  end

  metatableDefaults.__newindex = function(proxy, key, value)
    if hooks.set then
      local success = hooks.set(target, key, value, proxy)
      if not success then
        error("[PROXYERROR] Failed to set value on target object")
      end
    else
      target[key] = value
    end
  end

  metatableDefaults.__callable = function()
    if hooks.apply then
      return true
    else
      return false -- even if target is callable, it will not be callable through the proxy
    end
  end

  metatableDefaults.__call = function(proxy, ...)
    if hooks.apply then
      return hooks.apply(target, proxy, ...)
    else
      return target(...)
    end
  end

  metatableDefaults.__len = function(proxy)
    if hooks.len then
      return hooks.len(target, proxy)
    else
      return #target
    end
  end

  metatableDefaults.__iter = function(proxy)
    if hooks.iter then
      return hooks.iter(target, proxy)
    end
    local keys = metatableDefaults.__keys(proxy)
    local i = 0
    return function(lastKey)
      if lastKey ~= nil and lastKey ~= keys[i] then
        --retrieving the current last key to replace the index
        for j = 1, #keys do
          if keys[j] == lastKey then
            i = j
            break
          end
        end
      end
      i = i + 1
      if i <= #keys then
        return keys[i], proxy[keys[i]]
      end
      return nil
    end, proxy
  end

  return setmetatable(raw, metatableDefaults)
end

return {
  default = Proxy,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="193">
                <Properties>
                  <string name="Name">set_utils</string>
                  <string name="Source"><![CDATA[local SetUtils = {}

function SetUtils.union(set1: {[any]: true}, set2: {[any]: true})
  local result = {}
  for key in set1 do
    result[key] = true
  end
  for key in set2 do
    result[key] = true
  end
  return result
end

function SetUtils.intersection(set1: {[any]: true}, set2: {[any]: true})
  local result = {}
  for key in set1 do
    if set2[key] then
      result[key] = true
    end
  end
  return result
end

function SetUtils.difference(set1: {[any]: true}, set2: {[any]: true})
  local result = {}
  for key in set1 do
    if not set2[key] then
      result[key] = true
    end
  end
  return result
end

function SetUtils.symmetricDifference(set1: {[any]: true}, set2: {[any]: true})
  return SetUtils.union(SetUtils.difference(set1, set2), SetUtils.difference(set2, set1))
end

function SetUtils.isSubsetOf(set1: {[any]: true}, set2: {[any]: true})
  for key in set1 do
    if not set2[key] then
      return false
    end
  end
  return true
end

function SetUtils.isSupersetOf(set1: {[any]: true}, set2: {[any]: true})
  return SetUtils.isSubsetOf(set2, set1)
end

function SetUtils.isDisjointFrom(set1: {[any]: true}, set2: {[any]: true})
  for key in set1 do
    if set2[key] then
      return false
    end
  end
  return true
end

return {
  default = SetUtils,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="194">
                <Properties>
                  <string name="Name">string</string>
                  <string name="Source"><![CDATA[-- many tips thanks to https://github.com/howmanysmall/luau-polyfill/blob/main/src/String
--!nocheck
local Number = require(script.Parent.number).default


local String = {}

function String.charCodeAt(str: string, index: (number | string)?): number
  if type(str) ~= "string" then error("str must be a string") end
  if type(index) ~= "number" then index = tonumber(index) end
  if index == nil then error("index must be a number") end

  if index < 0 or index > #str - 1 then return Number.NaN end

  index += 1 -- convert to lua indexing

  local offset = utf8.offset(str, index)

  if offset == nil or offset > #str then return Number.NaN end

  return utf8.codepoint(str, offset) or Number.NaN
end


function String.endsWith(str: string, search: unknown, position: (number | string)?): boolean
  if type(search) ~= "string" then search = tostring(search) end
  if search == nil then error("search must be a string") end
  if search == "" then return true end
  if type(str) ~= "string" then error("str must be a string") end
  if type(position) ~= "number" then position = tonumber(position) or #str end
  if position < #search then return false end
  if position > #str then position = #str end

  local pos = position - #search + 1

  return string.find(str, search, pos, true) == pos
end

function String.startsWith(str: string, search: unknown, position: (number | string)?): boolean
  if type(search) ~= "string" then search = tostring(search) end
  if search == nil then error("search must be a string") end
  if search == "" then return true end
  if type(str) ~= "string" then error("str must be a string") end
  if type(position) ~= "number" then position = tonumber(position) or 0 end
  if position < 0 then position = 0 end
  if position > #str then position = #str end

  position += 1 -- convert to lua indexing

  return string.find(str, search, position, true) == position
end

function searchInit(str: string, search: string, position: number, reverse: boolean): number
  if type(search) ~= "string" then search = tostring(search) or "" end
  if type(position) ~= "number" then position = tonumber(position) end
  if position == nil then position = if reverse then #str else 0 end
	if search == "" then return math.clamp(position, 0, #str) end
  position += 1 -- convert to lua indexing

  if reverse then
    if position > #str then position = #str end
    if position < 1 then return -1 end
  else
    if position < 1 then position = 1 end
    if position > #str then return -1 end
  end

  return str, search, position
end

function String.indexOf(str: string, _search: unknown, _position: (string | number)?): number
  local strOrReturnPos, search, position = searchInit(str, _search, _position, false)
  if strOrReturnPos ~= str then return strOrReturnPos end

	for i = position, #str do
		if string.sub(str, i, i + #search - 1) == search then return i - 1 end
	end

	return -1
end

function String.lastIndexOf(str: string, _search: unknown, _position: (string | number)?): number
  local strOrReturnPos, search, position = searchInit(str, _search, _position, true)
  if strOrReturnPos ~= str then return strOrReturnPos end

	for i = position, 1, -1 do
		if string.sub(str, i, i + #search - 1) == search then return i - 1 end
	end

	return -1
end

function String.findOr(str: string, patternTable: {string}, position: (string | number)?): (number | nil, string | nil)
  if type(str) ~= "string" then error("str must be a string") end
  if type(patternTable) ~= "table" then error("patternTable must be a table") end
  if type(position) ~= "number" then position = tonumber(position) or 0 end
  position += 1 -- convert to lua indexing

	local foundString = nil
  local lowestIndexFound = #str
	for _, value in patternTable do
		local start, ends = string.find(str, value, position)
		if start ~= nil then
      if start < lowestIndexFound then
        foundString = string.sub(str, start, ends)
        lowestIndexFound = start
      end
		end
	end

  return lowestIndexFound - 1, foundString
end

function String.includes(str: string, substring: unknown, position: (string | number)?): boolean
  return String.indexOf(str, substring, position) ~= -1
end

function String.slice(str: string, start: (number | string)?, ends: (number | string)?): string
  if type(str) ~= "string" then error("str must be a string") end
  if type(start) ~= "number" then start = tonumber(start) or 0 end
  if type(ends) ~= "number" then ends = tonumber(ends) or #str - 1 end

  if start < 0 then start = #str - (start * -1) end
  if ends < 0 then ends = #str - 1 - (ends * -1) end
 
  start = math.clamp(start, 0, #str-1)
  ends = math.clamp(ends, 0, #str-1)

  if start > ends then return "" end

  return string.sub(str, start + 1, ends + 1)
end

function String.substring(str: string, start: (number | string)?, length: (number | string)?): string
  if type(str) ~= "string" then error("str must be a string") end
  if type(start) ~= "number" then start = tonumber(start) or 0 end
  if type(length) ~= "number" then length = tonumber(length) or #str - start end

  return string.sub(str, start + 1, start + length)
end

function String.split(str: string, separator: unknown, limit: (number | string)?): {string}
  if type(str) ~= "string" then error("str must be a string") end
  if type(separator) ~= "string" then separator = tostring(separator) end
  if type(limit) ~= "number" then limit = tonumber(limit) or Number.MAX_SAFE_INTEGER end
  if separator == nil then return {str} end
  if limit <= 0 then return {} end
  local result = {}

  if separator == "" then 
    for v in str:gmatch(".") do
      table.insert(result, v)
    end
    return result
  end

  repeat
    local start, ends = string.find(str, separator)
    if start ~= nil then
      table.insert(result, string.sub(str, 1, start - 1))
      str = string.sub(str, ends + 1)
    end
  until #result >= limit or start == nil

  table.insert(result, str)

  return result
end

function String.trimEnd(str: string): string
  if type(str) ~= "string" then error("str must be a string") end
  return (string.gsub(str, "[%s]+$", ""))
end

function String.trimStart(str: string): string
  if type(str) ~= "string" then error("str must be a string") end
  return (string.gsub(str, "^[%s]+", ""))
end

function String.trim(str: string): string
  return String.trimEnd(String.trimStart(str))
end

function String.replaceAll(str: string, search: unknown, replace: unknown | ((string) -> string) | {[string]: string}, limit: (number | string)?): string  
  if type(str) ~= "string" then error("str must be a string") end
  if type(search) ~= "string" then search = tostring(search) end
  if search == nil then error("search must be a string") end
  if type(replace) ~= "string" and type(replace) ~= "function" and type(replace) ~= "table" then replace = tostring(replace) end
  if replace == nil then error("replace must be a string or a function or a table") end
  if type(limit) ~= "number" then limit = tonumber(limit) end -- can be nil, so no need to check

  return (string.gsub(str, search, replace, limit))
end

function String.replace(str: string, search: unknown, replace: unknown | ((string) -> string) | {[string]: string}): string
  return String.replaceAll(str, search, replace, 1)
end

String.rep = string.rep

function String.search(str: string, pattern: unknown): number
  if type(pattern) ~= "string" then pattern = tostring(pattern) end
  if pattern == nil then error("pattern must be a string") end
  return (string.find(str, pattern) or -1)
end

function String.at(str: string, index: (number | string)): string
  if type(index) ~= "number" then index = tonumber(index) end
  if index == nil then error("index must be a number") end
  if index < 0 then index = #str + index end
  if index < 0 then return "" end
  if index > #str then return "" end
  index += 1 -- convert to lua indexing
  return string.sub(str, index, index)
end

function String.concat(...: unknown): string
  local result = ""
  for i=1, select("#", ...) do
    local value = select(i, ...)
    if type(value) ~= "string" then value = tostring(value) or "" end
    result = result .. value
  end
  return result
end

function padInit(str: string, length: unknown, fillString: string): string
  if type(length) ~= "number" then length = tonumber(length) or 0 end
  if type(fillString) ~= "string" then fillString = tostring(fillString) or " " end
  if fillString == "" then fillString = " " end
  if length <= #str then return str end
  local generateLength = length - #str
  return string.sub(string.rep(fillString, math.ceil(generateLength / #fillString)), 1, generateLength)
end

function String.padEnd(str: string, length: unknown, fillString: string): string
  local strOrFillString = padInit(str, length, fillString)
  if strOrFillString == str then return str end
  return str .. strOrFillString
end

function String.padStart(str: string, length: unknown, fillString: string): string
  local strOrFillString = padInit(str, length, fillString)
  if strOrFillString == str then return str end
  return strOrFillString .. str
end

function String.padBoth(str: string, length: unknown, fillString: string): string
  local strOrFillString = padInit(str, length, fillString)
  if strOrFillString == str then return str end
  local side = str.sub(strOrFillString, 1, math.floor(#strOrFillString / 2))
  return side .. str .. side
end

String.toLowerCase = string.lower
String.toUpperCase = string.upper

function String.toCamelCase(str: string): string
  return (str:gsub("[%s%-_]+(%w)", string.upper):gsub("^%u", string.lower))
end

function String.toPascalCase(str: string): string
  return (str:gsub("[%s%-_]+(%w)", string.upper):gsub("^%l", string.upper))
end

function String.toSnakeCase(str: string): string
  return str:gsub("%u", function(c) return "_" .. c end):gsub("[%s%-_]+(%w)", function(c) return "_" .. c end):gsub("^_+", ""):lower()
end

function String.toKebabCase(str: string): string
  return str:gsub("%u", function(c) return "-" .. c end):gsub("[%s%-_]+(%w)", function(c) return "-" .. c end):gsub("^-+", ""):lower()
end

function String.toTitleCase(str: string): string
  return (str:gsub("%u", function(c) return " " .. c:upper() end):gsub("[%s%-_]+(%w)", function(c) return " " .. c:upper() end):gsub("^%s+(%l)", string.upper))
end

function String.toSentenceCase(str: string): string
  return (str:gsub("%u", function(c) return " " .. c:lower() end):gsub("[%s%-_]+(%w)", function(c) return " " .. c:lower() end):gsub("^%s+(%l)", string.upper))
end

return {
  default = String,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="195">
                <Properties>
                  <string name="Name">symbol</string>
                  <string name="Source"><![CDATA[-- all thanks to https://github.com/howmanysmall/luau-polyfill/blob/main/src/Symbol

export type Symbol = typeof(newproxy(true)) & {[string]: any}
local Registry = {} :: {[string]: Symbol}

local isSymbol = nil

local Symbol = {
	new = function(name: string?): Symbol
		local self = newproxy(true) :: any

		local wrappedName = "Symbol()"
		if name then
			wrappedName = string.format("Symbol(%*)", name)
		end

		getmetatable(self).__tostring = function()
			return wrappedName
		end

		getmetatable(self).__index = function(_, key)
			if key == isSymbol then
				return true
			end
			return nil
		end

    getmetatable(self).__metatable = false

		return (self :: any) :: Symbol
	end,

  isSymbol = function(value: any)
    return type(value) == "table" and value[isSymbol] == true
  end,
}

isSymbol = Symbol.new("is-symbol")

Symbol["for"] = function(key: string)
  if Registry[key] == nil then
    Registry[key] = Symbol.new(key)
  end
  return Registry[key]
end

return {
  default = setmetatable(Symbol, {
    __call = function(self, key: string)
      return Symbol.new(key)
    end
  }),
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="196">
                <Properties>
                  <string name="Name">timers</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local Symbol = TS.import(script, script.Parent, "symbol").default
local timeouts = setmetatable({}, {
	__mode = "k",
})
local intervals = setmetatable({}, {
	__mode = "k",
})
--[[
	*
	 * Clears a timeout.
	 * @param sym - The symbol of the timeout to clear.
	 
]]
local function clearTimeout(sym)
	local _condition = sym ~= nil
	if _condition then
		local _sym = sym
		local _result = timeouts[_sym]
		if _result ~= nil then
			_result = _result()
		end
		_condition = _result == false
	end
	if _condition then
		local _sym = sym
		timeouts[_sym] = nil
	end
end
--[[
	*
	 * Sets a timeout.
	 * @param cb - The callback to execute after the timeout.
	 * @param ms - The timeout in milliseconds.
	 * @returns The symbol of the timeout.
	 
]]
local function setTimeout(cb, ms)
	if ms == nil then
		ms = 0
	end
	local sym = Symbol("timeout")
	local active = true
	task.delay(ms / 1000, function()
		if not active then
			return nil
		end
		cb(sym)
	end)
	timeouts[sym] = function()
		active = false
		return active
	end
	return sym
end
--[[
	*
	 * Sets an interval.
	 * @param cb - The callback to execute after the interval.
	 * @param ms - The interval in milliseconds.
	 * @returns The symbol of the interval.
	 
]]
local function setInterval(cb, ms)
	if ms == nil then
		ms = 0
	end
	local sym = Symbol("interval")
	local active = true
	local run
	run = function()
		return task.delay(ms / 1000, function()
			if not active then
				return nil
			end
			cb(sym)
			run()
		end)
	end
	intervals[sym] = function()
		active = false
		return active
	end
	return sym
end
--[[
	*
	 * Clears an interval.
	 * @param sym - The symbol of the interval to clear.
	 
]]
local function clearInterval(sym)
	local _condition = sym ~= nil
	if _condition then
		local _sym = sym
		local _result = intervals[_sym]
		if _result ~= nil then
			_result = _result()
		end
		_condition = _result == false
	end
	if _condition then
		local _sym = sym
		intervals[_sym] = nil
	end
end
return {
	clearTimeout = clearTimeout,
	setTimeout = setTimeout,
	setInterval = setInterval,
	clearInterval = clearInterval,
}
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="197">
            <Properties>
              <string name="Name">maid</string>
            </Properties>
            <Item class="ModuleScript" referent="198">
              <Properties>
                <string name="Name">Maid</string>
                <string name="Source"><![CDATA[---	Manages the cleaning of events and other things.
-- Useful for encapsulating state and make deconstructors easy
-- @classmod Maid
-- @see Signal

local Maid = {}
Maid.ClassName = "Maid"

--- Returns a new Maid object
-- @constructor Maid.new()
-- @treturn Maid
function Maid.new()
	local self = {}

	self._tasks = {}

	return setmetatable(self, Maid)
end

--- Returns Maid[key] if not part of Maid metatable
-- @return Maid[key] value
function Maid:__index(index)
	if Maid[index] then
		return Maid[index]
	else
		return self._tasks[index]
	end
end

--- Add a task to clean up
-- @usage
-- Maid[key] = (function)         Adds a task to perform
-- Maid[key] = (event connection) Manages an event connection
-- Maid[key] = (thread)           Manages a thread
-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,
--                                it is destroyed.
function Maid:__newindex(index, newTask)
	if Maid[index] ~= nil then
		error(("Cannot use '%s' as a Maid key"):format(tostring(index)), 2)
	end

	local tasks = self._tasks
	local oldTask = tasks[index]

	if oldTask == newTask then
        	return
	end

	tasks[index] = newTask

	if oldTask then
		if type(oldTask) == "function" then
			oldTask()
		elseif type(oldTask) == "thread" then
			local cancelled
			if coroutine.running() ~= oldTask then
				cancelled = pcall(function()
					task.cancel(oldTask)
				end)
			end

			if not cancelled then
				task.defer(function()
					task.cancel(oldTask)
				end)
			end
		elseif typeof(oldTask) == "RBXScriptConnection" then
			oldTask:Disconnect()
		elseif oldTask.Destroy then
			oldTask:Destroy()
		end
	end
end

--- Same as indexing, but uses an incremented number as a key.
-- @param task An item to clean
-- @treturn number taskId
function Maid:GiveTask(task)
	assert(task, "Task cannot be false or nil")

	local taskId = #self._tasks+1
	self[taskId] = task

	if type(task) == "table" and (not task.Destroy) then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end

function Maid:GivePromise(promise)
	if not promise:IsPending() then
		return promise
	end

	local newPromise = promise.resolved(promise)
	local id = self:GiveTask(newPromise)

	-- Ensure GC
	newPromise:Finally(function()
		self[id] = nil
	end)

	return newPromise
end

--- Cleans up all tasks.
-- @alias Destroy
function Maid:DoCleaning()
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, job in pairs(tasks) do
		if typeof(job) == "RBXScriptConnection" then
			tasks[index] = nil
			job:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, job = next(tasks)
	while job ~= nil do
		tasks[index] = nil
		if type(job) == "function" then
			job()
		elseif type(job) == "thread" then
			local cancelled
			if coroutine.running() ~= job then
				cancelled = pcall(function()
					task.cancel(job)
				end)
			end

			if not cancelled then
				local toCancel = job
				task.defer(function()
					task.cancel(toCancel)
				end)
			end
		elseif typeof(job) == "RBXScriptConnection" then
			job:Disconnect()
		elseif job.Destroy then
			job:Destroy()
		end
		index, job = next(tasks)
	end
end

--- Alias for DoCleaning()
-- @function Destroy
Maid.Destroy = Maid.DoCleaning

return Maid
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="199">
            <Properties>
              <string name="Name">matter</string>
            </Properties>
            <Item class="ModuleScript" referent="200">
              <Properties>
                <string name="Name">lib</string>
                <string name="Source"><![CDATA[--[=[
	@class Matter

	Matter. It's what everything is made out of.
]=]

--[=[
	@within Matter
	@prop World World
]=]

--[=[
	@within Matter
	@prop Loop Loop
]=]

--[=[
	@within Matter
	@prop Debugger Debugger
]=]

--[=[
	@within Matter
	@prop None None

	A value should be interpreted as nil when merging dictionaries.

	`Matter.None` is used by [`Component:patch`](/api/Component#patch).
]=]

--[=[
	@within Matter
	@function component
	@param name? string -- Optional name for debugging purposes
	@param defaultData? {} -- Default data that will be merged with data passed to the component when created
	@return Component -- Your new type of component

	Creates a new type of component. Call the component as a function to create an instance of that component.

	If `defaultData` is specified, it will be merged with data passed to the component when the component instance is
	created. Note that this is not *fallback* data: if you later remove a field from a component instance that is
	specified in the default data, it won't fall back to the value specified in default data.

	```lua
	-- Component:
	local MyComponent = Matter.component("My component")

	-- component instance:
	local myComponentInstance = MyComponent({
		some = "data"
	})
	```
]=]

local immutable = require(script.immutable)
local World = require(script.World)
local Loop = require(script.Loop)
local newComponent = require(script.component).newComponent
local topoRuntime = require(script.topoRuntime)

export type World = typeof(World.new())
export type Loop = typeof(Loop.new())

return table.freeze({
	World = World,
	Loop = Loop,

	component = newComponent,

	useEvent = require(script.hooks.useEvent),
	useDeltaTime = require(script.hooks.useDeltaTime),
	useThrottle = require(script.hooks.useThrottle),
	log = require(script.hooks.log),
	useHookState = topoRuntime.useHookState,
	useCurrentSystem = topoRuntime.useCurrentSystem,

	merge = immutable.merge,
	None = immutable.None,

	Debugger = require(script.debugger.debugger),
})
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="201">
                <Properties>
                  <string name="Name">Loop</string>
                  <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local rollingAverage = require(script.Parent.rollingAverage)
local topoRuntime = require(script.Parent.topoRuntime)

local recentErrors = {}
local recentErrorLastTime = 0

local function systemFn(system: System)
	if type(system) == "table" then
		return system.system
	end

	return system
end

local function systemName(system: System)
	local fn = systemFn(system)
	return debug.info(fn, "s") .. "->" .. debug.info(fn, "n")
end

--[=[
	@class Loop

	The Loop class handles scheduling and *looping* (who would have guessed) over all of your game systems.

	:::caution Yielding
	Yielding is not allowed in systems. Doing so will result in the system thread being closed early, but it will not
	affect other systems.
	:::
]=]
local Loop = {}
Loop.__index = Loop

--[=[
	Creates a new loop. `Loop.new` accepts as arguments the values that will be passed to all of your systems.

	So typically, you want to pass the World in here, as well as maybe a table of global game state.

	```lua
	local world = World.new()
	local gameState = {}

	local loop = Loop.new(world, gameState)
	```

	@param ... ...any -- Values that will be passed to all of your systems
	@return Loop
]=]
function Loop.new(...)
	return setmetatable({
		_systems = {},
		_skipSystems = {},
		_orderedSystemsByEvent = {},
		_state = { ... },
		_stateLength = select("#", ...),
		_systemState = {},
		_middlewares = {},
		_systemErrors = {},
		_systemLogs = {},
		_debugger = nil,
		profiling = nil,
		trackErrors = false,
	}, Loop)
end

--[=[
	@within Loop
	@type System SystemTable | (...any) -> ()

	Either a plain function or a table defining the system.
]=]

--[=[
	@within Loop
	@interface SystemTable
	.system (...any) -> () -- The system function
	.event? string -- The event the system runs on. A string, a key from the table you pass to `Loop:begin`.
	.priority? number -- Priority influences the position in the frame the system is scheduled to run at.
	.after? {System} -- A list of systems that this system must run after.

	A table defining a system with possible options.

	Systems are scheduled in order of `priority`, meaning lower `priority` runs first.
	The default priority is `0`.
]=]

type System = (...any) -> () | { system: (...any) -> (), event: string?, priority: number?, after: nil | {} }

--[=[
	Schedules a set of systems based on the constraints they define.

	Systems may optionally declare:
	- The name of the event they run on (e.g., RenderStepped, Stepped, Heartbeat)
	- A numerical priority value
	- Other systems that they must run *after*

	If systems do not specify an event, they will run on the `default` event.

	Systems that share an event will run in order of their priority, which means that systems with a lower `priority`
	value run first. The default priority is `0`.

	Systems that have defined what systems they run `after` can only be scheduled after all systems they depend on have
	already been scheduled.

	All else being equal, the order in which systems run is stable, meaning if you don't change your code, your systems
	will always run in the same order across machines.

	:::info
	It is possible for your systems to be in an unresolvable state. In which case, `scheduleSystems` will error.
	This can happen when your systems have circular or unresolvable dependency chains.

	If a system has both a `priority` and defines systems it runs `after`, the system can only be scheduled if all of
	the systems it depends on have a lower or equal priority.

	Systems can never depend on systems that run on other events, because it is not guaranteed or required that events
	will fire every frame or will always fire in the same order.
	:::

	:::caution
	`scheduleSystems` has to perform nontrivial sorting work each time it's called, so you should avoid calling it multiple
	times if possible.
	:::

	@param systems { System } -- Array of systems to schedule.
]=]
function Loop:scheduleSystems(systems: { System })
	for _, system in ipairs(systems) do
		if table.find(self._systems, system) == nil then
			table.insert(self._systems, system)
		end
		self._systemState[system] = {}

		if RunService:IsStudio() then
			-- In Studio, we start logging immediately.
			self._systemLogs[system] = {}
		end
	end

	self:_sortSystems()
end
--[=[
	Schedules a single system. This is an expensive function to call multiple times. Instead, try batch scheduling
	systems with [Loop:scheduleSystems] if possible.

	@param system System
]=]
function Loop:scheduleSystem(system: System)
	return self:scheduleSystems({ system })
end

--[=[
	Removes a previously-scheduled system from the Loop. Evicting a system also cleans up any storage from hooks.
	This is intended to be used for hot reloading. Dynamically loading and unloading systems for gameplay logic
	is not recommended.

	@param system System
]=]
function Loop:evictSystem(system: System)
	local systemIndex = table.find(self._systems, system)

	if systemIndex == nil then
		error("Can't evict system because it doesn't exist")
	end

	table.remove(self._systems, systemIndex)

	self._systemErrors[system] = nil

	topoRuntime.start({
		system = self._systemState[system],
	}, function() end)

	self._systemState[system] = nil
	self._systemLogs[system] = nil

	self:_sortSystems()
end

--[=[
	Replaces an older version of a system with a newer version of the system. Internal system storage (which is used
	by hooks) will be moved to be associated with the new system. This is intended to be used for hot reloading.

	@param old System
	@param new System
]=]
function Loop:replaceSystem(old: System, new: System)
	local systemIndex = table.find(self._systems, old)

	if not systemIndex then
		error("Before system does not exist!")
	end

	table.remove(self._systems, systemIndex)
	table.insert(self._systems, new)

	self._systemState[new] = self._systemState[old] or {}
	self._systemState[old] = nil

	if self._skipSystems[old] then
		self._skipSystems[old] = nil
		self._skipSystems[new] = true
	end

	for _, system in self._systems do
		if type(system) == "table" and system.after then
			local index = table.find(system.after, old)

			if index then
				system.after[index] = new
			end
		end
	end

	self:_sortSystems()
end

local function orderSystemsByDependencies(unscheduledSystems: { System })
	local systemPriorityMap = {}
	local visiting = "v"

	local function systemPriority(system: System)
		local priority = systemPriorityMap[system]

		if not priority then
			priority = 0

			systemPriorityMap[system] = visiting

			if type(system) == "table" then
				if system.after then
					for _, dependency in system.after do
						if systemPriorityMap[dependency] ~= visiting then
							priority = math.max(priority, systemPriority(dependency) + 1)
						else
							local errorStatement = {
								`Cyclic dependency detected: System '{systemName(system)}' is set to execute after System '{systemName(
									dependency
								)}', and vice versa. This creates a loop that prevents the systems from being able to execute in a valid order.`,
								"To resolve this issue, reconsider the dependencies between these systems. One possible solution is to update the 'after' field from one of the systems.",
							}
							error(table.concat(errorStatement, "\n"))
						end
					end
				elseif system.priority then
					priority = system.priority
				end
			end

			systemPriorityMap[system] = priority
		end

		return priority
	end

	local scheduledSystems = table.clone(unscheduledSystems)

	table.sort(scheduledSystems, function(a, b)
		local priorityA = systemPriority(a)
		local priorityB = systemPriority(b)

		if priorityA == priorityB then
			local nameA = systemName(a)
			local nameB = systemName(b)

			if nameA == nameB then
				return table.find(unscheduledSystems, a) < table.find(unscheduledSystems, b)
			end

			return nameA < nameB
		end

		return priorityA < priorityB
	end)

	return scheduledSystems
end

function Loop:_sortSystems()
	local systemsByEvent = {}

	for _, system in pairs(self._systems) do
		local eventName = "default"

		if type(system) == "table" then
			if system.event then
				eventName = system.event
			end
			if system.after then
				if system.priority then
					error(`{systemName(system)} shouldn't have both priority and after defined`)
				end

				if #system.after == 0 then
					error(
						`System "{systemName(system)}" "after" table was provided but is empty; did you accidentally use a nil value or make a typo?`
					)
				end

				for _, dependency in system.after do
					if not table.find(self._systems, dependency) then
						error(
							`Unable to schedule "{systemName(system)}" because the system "{systemName(dependency)}" is not scheduled.\n\nEither schedule "{systemName(
								dependency
							)}" before "{systemName(system)}" or consider scheduling these systems together with Loop:scheduleSystems`
						)
					end
				end
			end
		end

		if not systemsByEvent[eventName] then
			systemsByEvent[eventName] = {}
		end

		table.insert(systemsByEvent[eventName], system)
	end

	self._orderedSystemsByEvent = {}

	for eventName, systems in pairs(systemsByEvent) do
		self._orderedSystemsByEvent[eventName] = orderSystemsByDependencies(systems)
	end
end

--[=[
	Connects to frame events and starts invoking your systems.

	Pass a table of events you want to be able to run systems on, a map of name to event. Systems can use these names
	to define what event they run on. By default, systems run on an event named `"default"`. Custom events may be used
	if they have a `Connect` function.

	```lua
	loop:begin({
		default = RunService.Heartbeat,
		Heartbeat = RunService.Heartbeat,
		RenderStepped = RunService.RenderStepped,
		Stepped = RunService.Stepped,
	})
	```

	&nbsp;

	Returns a table similar to the one you passed in, but the values are `RBXScriptConnection` values (or whatever is
	returned by `:Connect` if you passed in a synthetic event).

	@param events {[string]: RBXScriptSignal} -- A map from event name to event objects.
	@return {[string]: RBXScriptConnection} -- A map from your event names to connection objects.
]=]
function Loop:begin(events)
	local connections = {}

	for eventName, event in pairs(events) do
		local lastTime = os.clock()
		local generation = false

		local function stepSystems()
			if not self._orderedSystemsByEvent[eventName] then
				-- Skip events that have no systems
				return
			end

			local currentTime = os.clock()
			local deltaTime = currentTime - lastTime
			lastTime = currentTime

			generation = not generation

			local dirtyWorlds: { [any]: true } = {}
			local profiling = self.profiling

			for _, system in ipairs(self._orderedSystemsByEvent[eventName]) do
				topoRuntime.start({
					system = self._systemState[system],
					frame = {
						generation = generation,
						deltaTime = deltaTime,
						dirtyWorlds = dirtyWorlds,
						logs = self._systemLogs[system],
					},
					currentSystem = system,
				}, function()
					if self._skipSystems[system] then
						if profiling then
							profiling[system] = nil
						end
						return
					end

					local fn = systemFn(system)
					debug.profilebegin("system: " .. systemName(system))

					local thread = coroutine.create(fn)

					local startTime = os.clock()
					local success, errorValue = coroutine.resume(thread, unpack(self._state, 1, self._stateLength))

					if profiling ~= nil then
						local duration = os.clock() - startTime

						if profiling[system] == nil then
							profiling[system] = {}
						end

						local debugger = self._debugger

						if debugger and debugger.debugSystem == system and debugger._queries then
							local totalQueryTime = 0

							for _, query in debugger._queries do
								totalQueryTime += query.averageDuration
							end

							rollingAverage.addSample(
								profiling[system],
								if debugger.debugSystem then duration - totalQueryTime else duration
							)
						else
							rollingAverage.addSample(profiling[system], duration)
						end
					end

					if coroutine.status(thread) ~= "dead" then
						coroutine.close(thread)

						task.spawn(
							error,
							(
								"Matter: System %s yielded! Its thread has been closed. "
								.. "Yielding in systems is not allowed."
							):format(systemName(system))
						)
					end

					for world in dirtyWorlds do
						world:optimizeQueries()
					end
					table.clear(dirtyWorlds)

					if not success then
						if os.clock() - recentErrorLastTime > 10 then
							recentErrorLastTime = os.clock()
							recentErrors = {}
						end

						local errorString = systemName(system)
							.. ": "
							.. tostring(errorValue)
							.. "\n"
							.. debug.traceback(thread)

						if not recentErrors[errorString] then
							task.spawn(error, errorString)
							warn("Matter: The above error will be suppressed for the next 10 seconds")
							recentErrors[errorString] = true
						end

						if self.trackErrors then
							if self._systemErrors[system] == nil then
								self._systemErrors[system] = {}
							end

							local errorStorage = self._systemErrors[system]
							local lastError = errorStorage[#errorStorage]

							if lastError and lastError.error == errorString then
								lastError.when = os.time()
							else
								table.insert(errorStorage, {
									error = errorString,
									when = os.time(),
								})

								if #errorStorage > 100 then
									table.remove(errorStorage, 1)
								end
							end
						end
					end

					debug.profileend()
				end)
			end
		end

		for _, middleware in ipairs(self._middlewares) do
			stepSystems = middleware(stepSystems, eventName)

			if type(stepSystems) ~= "function" then
				error(
					("Middleware function %s:%s returned %s instead of a function"):format(
						debug.info(middleware, "s"),
						debug.info(middleware, "l"),
						typeof(stepSystems)
					)
				)
			end
		end

		connections[eventName] = event:Connect(stepSystems)
	end

	return connections
end

--[=[
	Adds a user-defined middleware function that is called during each frame.

	This allows you to run code before and after each frame, to perform initialization and cleanup work.

	```lua
	loop:addMiddleware(function(nextFn)
		return function()
			Plasma.start(plasmaNode, nextFn)
		end
	end)
	```

	You must pass `addMiddleware` a function that itself returns a function that invokes `nextFn` at some point.

	The outer function is invoked only once. The inner function is invoked during each frame event.

	:::info
	Middleware added later "wraps" middleware that was added earlier. The innermost middleware function is the internal
	function that actually calls your systems.
	:::
	@param middleware (nextFn: () -> (), eventName: string) -> () -> ()
]=]
function Loop:addMiddleware(middleware: (nextFn: () -> ()) -> () -> ())
	table.insert(self._middlewares, middleware)
end

return Loop
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="202">
                <Properties>
                  <string name="Name">Loop.spec</string>
                  <string name="Source"><![CDATA[local Loop = require(script.Parent.Loop)
local useHookState = require(script.Parent.topoRuntime).useHookState
local World = require(script.Parent.World)
local component = require(script.Parent).component
local BindableEvent = require(script.Parent.mock.BindableEvent)

local bindable = BindableEvent.new()

return function()
	describe("Loop", function()
		it("should call systems", function()
			local loop = Loop.new(1, 2, 3)

			local callCount = 0
			loop:scheduleSystem(function(a, b, c)
				callCount += 1

				expect(a).to.equal(1)
				expect(b).to.equal(2)
				expect(c).to.equal(3)
			end)

			local connection = loop:begin({ default = bindable.Event })

			expect(callCount).to.equal(0)
			bindable:Fire()
			expect(callCount).to.equal(1)
			connection.default:Disconnect()
			expect(callCount).to.equal(1)
		end)

		it("should allow evicting systems", function()
			local loop = Loop.new()

			local cleanedUp = false
			local function customHook()
				useHookState(nil, function()
					cleanedUp = true
				end)
			end

			local counts = {}
			local function system1()
				customHook()
				counts[1] = (counts[1] or 0) + 1
			end

			local function system2()
				counts[2] = (counts[2] or 0) + 1
			end

			loop:scheduleSystems({ system1, system2 })

			local bindable = BindableEvent.new()

			loop:begin({
				default = bindable.Event,
			})

			bindable:Fire()

			expect(cleanedUp).to.equal(false)
			expect(counts[1]).to.equal(1)
			expect(counts[2]).to.equal(1)

			loop:evictSystem(system1)

			expect(cleanedUp).to.equal(true)

			bindable:Fire()

			expect(counts[1]).to.equal(1)
			expect(counts[2]).to.equal(2)
		end)

		it("should allow replacing systems", function()
			local state = {}
			local loop = Loop.new(state)

			local function sampleHook(value)
				local storage = useHookState()

				if value then
					storage.value = value
				end

				return storage.value
			end

			local function makeSystem(isFirst)
				return function(state)
					local param = if isFirst then "sample text" else nil
					local returnValue = sampleHook(param)

					if isFirst then
						state.foo = "one"
					else
						state.foo = returnValue
					end
				end
			end

			local system1 = makeSystem(true)
			local system2 = makeSystem(false)

			loop:scheduleSystem(system1)

			local bindable = BindableEvent.new()

			loop:begin({
				default = bindable.Event,
			})

			bindable:Fire()

			expect(state.foo).to.equal("one")

			loop:replaceSystem(system1, system2)

			bindable:Fire()

			expect(state.foo).to.equal("sample text")
		end)

		it("should call systems in order", function()
			local loop = Loop.new()

			local order = {}
			local systemA = {
				system = function()
					table.insert(order, "a")
				end,
			}
			local systemB = {
				system = function()
					table.insert(order, "b")
				end,
				after = { systemA },
			}
			local systemC = {
				system = function()
					table.insert(order, "c")
				end,
				after = { systemA, systemB },
			}

			loop:scheduleSystems({
				systemC,
				systemB,
				systemA,
			})

			local connection = loop:begin({ default = bindable.Event })

			expect(#order).to.equal(0)

			bindable:Fire()

			expect(#order).to.equal(3)
			expect(order[1]).to.equal("a")
			expect(order[2]).to.equal("b")
			expect(order[3]).to.equal("c")

			connection.default:Disconnect()
		end)

		it("should call systems in order with dependent system after priority system", function()
			local loop = Loop.new()

			local order = {}
			local systemB = {
				system = function()
					table.insert(order, "b")
				end,
			}
			local systemC = {
				system = function()
					table.insert(order, "c")
				end,
				priority = 1000,
			}
			local systemA = {
				system = function()
					table.insert(order, "a")
				end,
				after = { systemC },
			}

			loop:scheduleSystems({
				systemB,
				systemC,
				systemA,
			})

			local connection = loop:begin({ default = bindable.Event })

			expect(#order).to.equal(0)

			bindable:Fire()

			expect(#order).to.equal(3)
			expect(order[1]).to.equal("b")
			expect(order[2]).to.equal("c")
			expect(order[3]).to.equal("a")

			connection.default:Disconnect()
		end)

		it("should not schedule systems more than once", function()
			local loop = Loop.new()

			local order = {}
			local systemA = {
				system = function()
					table.insert(order, "a")
				end,
				t = 1,
			}

			local systemB = {
				system = function()
					table.insert(order, "b")
				end,
				t = 2,
			}

			loop:scheduleSystems({
				systemA,
				systemA,
			})

			loop:scheduleSystem(systemB)
			loop:scheduleSystem(systemB)

			local connection = loop:begin({ default = bindable.Event })

			expect(#order).to.equal(0)

			bindable:Fire()

			expect(#order).to.equal(2)
			expect(order[1]).to.equal("a")
			expect(order[2]).to.equal("b")

			connection.default:Disconnect()
		end)

		it("should schedule systems in order if dependencies are defined", function()
			local loop = Loop.new()

			local order = {}
			local systemA = {
				system = function()
					table.insert(order, "a")
				end,
			}

			local function namedSystemB()
				table.insert(order, "b")
			end

			local systemB = {
				system = namedSystemB,
				after = { systemA },
			}

			--By naming the system functions this ensures that the initial table.sort call in the
			--system scheduler returns the following order systemC -> systemB -> systemA
			--and we want to schedule it in this order to ensure that the scheduler is able to complete
			--without erroring
			local function namedSystemA()
				table.insert(order, "c")
			end

			local systemC = {
				system = namedSystemA,
				after = { systemA, systemB },
			}

			loop:scheduleSystems({
				systemC,
				systemB,
				systemA,
			})

			local connection = loop:begin({ default = bindable.Event })

			expect(#order).to.equal(0)

			bindable:Fire()

			expect(#order).to.equal(3)
			expect(order[1]).to.equal("a")
			expect(order[2]).to.equal("b")
			expect(order[3]).to.equal("c")

			connection.default:Disconnect()
		end)

		it("should schedule systems based on order passed into scheduleSystems", function()
			local loop = Loop.new()

			local order = {}
			local systemA = {
				system = function()
					table.insert(order, "a")
				end,
			}
			local systemB = {
				system = function()
					table.insert(order, "b")
				end,
			}
			local systemC = {
				system = function()
					table.insert(order, "c")
				end,
			}

			loop:scheduleSystems({
				systemB,
				systemC,
				systemA,
			})

			local connection = loop:begin({ default = bindable.Event })

			expect(#order).to.equal(0)

			bindable:Fire()

			expect(#order).to.equal(3)
			expect(order[1]).to.equal("b")
			expect(order[2]).to.equal("c")
			expect(order[3]).to.equal("a")

			connection.default:Disconnect()
		end)

		it("should throw error for systems with unscheduled depedencies", function()
			local loop = Loop.new()

			local _order = {}
			local systemA = {
				system = function()
					table.insert(_order, "a")
				end,
			}
			local systemB = {
				system = function()
					table.insert(_order, "b")
				end,
				after = { systemA },
			}

			expect(function()
				loop:scheduleSystems({
					systemB,
				})
			end).to.throw()

			loop:scheduleSystem(systemA)
			loop:scheduleSystem(systemB)

			expect(function()
				loop:evictSystem(systemA)
			end).to.throw()
		end)

		it("should throw error for system if dependency is evicted", function()
			local loop = Loop.new()

			local _order = {}
			local systemA = {
				system = function()
					table.insert(_order, "a")
				end,
			}
			local systemB = {
				system = function()
					table.insert(_order, "b")
				end,
				after = { systemA },
			}

			loop:scheduleSystem(systemA)
			loop:scheduleSystem(systemB)

			expect(function()
				loop:evictSystem(systemA)
			end).to.throw()
		end)

		it("should throw error for system with empty after table", function()
			local loop = Loop.new()

			local _order = {}
			local systemA = {
				system = function()
					table.insert(_order, "a")
				end,
				after = {},
			}

			expect(function()
				loop:scheduleSystems({
					systemA,
				})
			end).to.throw()
		end)

		it("should throw error for systems with cyclic dependency", function()
			local loop = Loop.new()

			local _order = {}
			local systemC = {}
			local systemA = {
				system = function()
					table.insert(_order, "a")
				end,
				after = { systemC },
			}
			local systemB = {
				system = function()
					table.insert(_order, "b")
				end,
				after = { systemA, systemC },
			}
			systemC.system = function()
				table.insert(_order, "c")
			end
			systemC.after = { systemA, systemB }

			expect(function()
				loop:scheduleSystems({
					systemC,
					systemB,
					systemA,
				})
			end).to.throw()
		end)

		it("should throw error for systems with both after and priority defined", function()
			local loop = Loop.new()

			local _order = {}
			local systemA = {
				system = function()
					table.insert(_order, "a")
				end,
				priority = 1,
				after = {},
			}

			expect(function()
				loop:scheduleSystems({
					systemA,
				})
			end).to.throw()
		end)

		it("should call systems with priority and after in order", function()
			local loop = Loop.new()

			local order = {}
			local systemA = {
				system = function()
					table.insert(order, "a")
				end,
				priority = 1,
			}
			local systemB = {
				system = function()
					table.insert(order, "b")
				end,
				priority = 2,
			}
			local systemC = {
				system = function()
					table.insert(order, "c")
				end,
				priority = 3,
			}
			local systemD = {
				system = function()
					table.insert(order, "d")
				end,
				after = { systemB },
			}
			local systemE = {
				system = function()
					table.insert(order, "e")
				end,
				after = { systemA },
			}

			loop:scheduleSystems({
				systemE,
				systemD,
				systemC,
				systemB,
				systemA,
			})

			local connection = loop:begin({ default = bindable.Event })

			expect(#order).to.equal(0)

			bindable:Fire()

			expect(#order).to.equal(5)
			expect(order[1]).to.equal("a")
			expect(order[2]).to.equal("e")
			expect(order[3]).to.equal("b")
			expect(order[4]).to.equal("d")
			expect(order[5]).to.equal("c")

			connection.default:Disconnect()
		end)

		it("should call systems with priority in order", function()
			local loop = Loop.new()

			local order = {}

			local function cleanupStartReplication()
				table.insert(order, "e")
			end

			local function replicateEnemies()
				table.insert(order, "d")
			end

			local function spawnSwords()
				table.insert(order, "c")
			end

			local function spawnEnemies()
				table.insert(order, "b")
			end

			local function neutral()
				table.insert(order, "a")
			end

			loop:scheduleSystems({
				{
					system = spawnEnemies,
					priority = 0,
				},
				neutral,
				{
					system = replicateEnemies,
					priority = 100,
				},
				{
					system = spawnSwords,
					priority = 1,
				},
				{
					system = cleanupStartReplication,
					priority = 5000,
				},
			})

			local connection = loop:begin({ default = bindable.Event })

			expect(#order).to.equal(0)

			bindable:Fire()

			expect(#order).to.equal(5)
			expect(order[1]).to.equal("a")
			expect(order[2]).to.equal("b")
			expect(order[3]).to.equal("c")
			expect(order[4]).to.equal("d")
			expect(order[5]).to.equal("e")

			connection.default:Disconnect()
		end)

		it("should call middleware", function()
			local loop = Loop.new(1, 2, 3)

			local called = {}
			loop:addMiddleware(function(nextFn)
				return function()
					table.insert(called, 2)
					nextFn()
				end
			end)
			loop:addMiddleware(function(nextFn)
				return function()
					table.insert(called, 1)
					nextFn()
				end
			end)

			loop:scheduleSystem(function()
				table.insert(called, 3)
			end)

			loop:begin({ default = bindable.Event })

			expect(#called).to.equal(0)
			bindable:Fire()
			expect(#called).to.equal(3)
			expect(called[1]).to.equal(1)
			expect(called[2]).to.equal(2)
			expect(called[3]).to.equal(3)
		end)

		it("should optimize queries of worlds used inside it", function()
			local world = World.new()
			local loop = Loop.new(world)

			local A = component()

			world:spawn(A())

			loop:scheduleSystem(function(world)
				world:query(A)
			end)

			local bindable = BindableEvent.new()
			loop:begin({
				default = bindable.Event,
			})

			bindable:Fire()

			expect(#world._storages).to.equal(1)
		end)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="203">
                <Properties>
                  <string name="Name">Queue</string>
                  <string name="Source"><![CDATA[local Queue = {}
Queue.__index = Queue

function Queue.new()
	return setmetatable({
		_head = nil,
		_tail = nil,
	}, Queue)
end

function Queue:pushBack(value)
	local entry = {
		value = value,
		next = nil,
	}

	if self._tail ~= nil then
		self._tail.next = entry
	end

	self._tail = entry

	if self._head == nil then
		self._head = entry
	end
end

function Queue:popFront()
	if self._head == nil then
		return nil
	end

	local value = self._head.value
	self._head = self._head.next

	return value
end

return Queue
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="204">
                <Properties>
                  <string name="Name">World</string>
                  <string name="Source"><![CDATA[local Component = require(script.Parent.component)
local archetypeModule = require(script.Parent.archetype)
local topoRuntime = require(script.Parent.topoRuntime)

local assertValidComponentInstance = Component.assertValidComponentInstance
local assertValidComponent = Component.assertValidComponent
local assertComponentArgsProvided = Component.assertComponentArgsProvided
local archetypeOf = archetypeModule.archetypeOf
local negateArchetypeOf = archetypeModule.negateArchetypeOf
local areArchetypesCompatible = archetypeModule.areArchetypesCompatible

local function assertEntityExists(world, id: number)
	assert(world:contains(id), "Entity doesn't exist, use world:contains to check if needed")
end

local function assertWorldOperationIsValid(world, id: number, ...)
	assertEntityExists(world, id)
	assertComponentArgsProvided(...)
end

--[=[
	@class World

	A World contains entities which have components.
	The World is queryable and can be used to get entities with a specific set of components.
	Entities are simply ever-increasing integers.
]=]
local World = {}
World.__index = World

--[=[
	Creates a new World.
]=]
function World.new()
	local firstStorage = {}

	return setmetatable({
		-- List of maps from archetype string --> entity ID --> entity data
		_storages = { firstStorage },
		-- The most recent storage that has not been dirtied by an iterator
		_pristineStorage = firstStorage,

		-- Map from entity ID -> archetype string
		_entityArchetypes = {},

		-- Cache of the component metatables on each entity. Used for generating archetype.
		-- Map of entity ID -> array
		_entityMetatablesCache = {},

		-- Cache of what query archetypes are compatible with what component archetypes
		_queryCache = {},

		-- Cache of what entity archetypes have ever existed in the game. This is used for knowing
		-- when to update the queryCache.
		_entityArchetypeCache = {},

		-- The next ID that will be assigned with World:spawn
		_nextId = 1,

		-- The total number of active entities in the world
		_size = 0,

		-- Storage for `queryChanged`
		_changedStorage = {},
	}, World)
end

-- Searches all archetype storages for the entity with the given archetype
-- Returns the storage that the entity is in if it exists, otherwise nil
function World:_getStorageWithEntity(archetype, id)
	for _, storage in self._storages do
		local archetypeStorage = storage[archetype]
		if archetypeStorage then
			if archetypeStorage[id] then
				return storage
			end
		end
	end
	return nil
end

function World:_markStorageDirty()
	local newStorage = {}
	table.insert(self._storages, newStorage)
	self._pristineStorage = newStorage

	if topoRuntime.withinTopoContext() then
		local frameState = topoRuntime.useFrameState()

		frameState.dirtyWorlds[self] = true
	end
end

function World:_getEntity(id)
	local archetype = self._entityArchetypes[id]
	local storage = self:_getStorageWithEntity(archetype, id)

	return storage[archetype][id]
end

function World:_next(last)
	local entityId, archetype = next(self._entityArchetypes, last)

	if entityId == nil then
		return nil
	end

	local storage = self:_getStorageWithEntity(archetype, entityId)

	return entityId, storage[archetype][entityId]
end

--[=[
	Iterates over all entities in this World. Iteration returns entity ID followed by a dictionary mapping
	Component to Component Instance.

	**Usage:**

	```lua
	for entityId, entityData in world do
		print(entityId, entityData[Components.Example])
	end
	```

	@return number
	@return {[Component]: ComponentInstance}
]=]
function World:__iter()
	return World._next, self
end

--[=[
	Spawns a new entity in the world with the given components.

	@param ... ComponentInstance -- The component values to spawn the entity with.
	@return number -- The new entity ID.
]=]
function World:spawn(...)
	return self:spawnAt(self._nextId, ...)
end

--[=[
	Spawns a new entity in the world with a specific entity ID and given components.

	The next ID generated from [World:spawn] will be increased as needed to never collide with a manually specified ID.

	@param id number -- The entity ID to spawn with
	@param ... ComponentInstance -- The component values to spawn the entity with.
	@return number -- The same entity ID that was passed in
]=]
function World:spawnAt(id, ...)
	if self:contains(id) then
		error(
			string.format(
				"The world already contains an entity with ID %d. Use World:replace instead if this is intentional.",
				id
			),
			2
		)
	end

	self._size += 1

	if id >= self._nextId then
		self._nextId = id + 1
	end

	local components = {}
	local metatables = {}

	for i = 1, select("#", ...) do
		local newComponent = select(i, ...)

		assertValidComponentInstance(newComponent, i)

		local metatable = getmetatable(newComponent)

		if components[metatable] then
			error(("Duplicate component type at index %d"):format(i), 2)
		end

		self:_trackChanged(metatable, id, nil, newComponent)

		components[metatable] = newComponent
		table.insert(metatables, metatable)
	end

	self._entityMetatablesCache[id] = metatables

	self:_transitionArchetype(id, components)

	return id
end

function World:_newQueryArchetype(queryArchetype)
	if self._queryCache[queryArchetype] == nil then
		self._queryCache[queryArchetype] = {}
	else
		return -- Archetype isn't actually new
	end

	for _, storage in self._storages do
		for entityArchetype in storage do
			if areArchetypesCompatible(queryArchetype, entityArchetype) then
				self._queryCache[queryArchetype][entityArchetype] = true
			end
		end
	end
end

function World:_updateQueryCache(entityArchetype)
	for queryArchetype, compatibleArchetypes in pairs(self._queryCache) do
		if areArchetypesCompatible(queryArchetype, entityArchetype) then
			compatibleArchetypes[entityArchetype] = true
		end
	end
end

function World:_transitionArchetype(id, components)
	debug.profilebegin("transitionArchetype")
	local newArchetype = nil
	local oldArchetype = self._entityArchetypes[id]
	local oldStorage

	if oldArchetype then
		oldStorage = self:_getStorageWithEntity(oldArchetype, id)

		if not components then
			oldStorage[oldArchetype][id] = nil
		end
	end

	if components then
		newArchetype = archetypeOf(unpack(self._entityMetatablesCache[id]))

		if oldArchetype ~= newArchetype then
			if oldStorage then
				oldStorage[oldArchetype][id] = nil
			end

			if self._pristineStorage[newArchetype] == nil then
				self._pristineStorage[newArchetype] = {}
			end

			if self._entityArchetypeCache[newArchetype] == nil then
				debug.profilebegin("update query cache")
				self._entityArchetypeCache[newArchetype] = true
				self:_updateQueryCache(newArchetype)
				debug.profileend()
			end
			self._pristineStorage[newArchetype][id] = components
		else
			oldStorage[newArchetype][id] = components
		end
	end

	self._entityArchetypes[id] = newArchetype

	debug.profileend()
end

--[=[
	Replaces a given entity by ID with an entirely new set of components.
	Equivalent to removing all components from an entity, and then adding these ones.

	@param id number -- The entity ID
	@param ... ComponentInstance -- The component values to spawn the entity with.
]=]
function World:replace(id, ...)
	assertWorldOperationIsValid(self, id, ...)

	local components = {}
	local metatables = {}
	local entity = self:_getEntity(id)

	for i = 1, select("#", ...) do
		local newComponent = select(i, ...)

		assertValidComponentInstance(newComponent, i)

		local metatable = getmetatable(newComponent)

		if components[metatable] then
			error(("Duplicate component type at index %d"):format(i), 2)
		end

		self:_trackChanged(metatable, id, entity[metatable], newComponent)

		components[metatable] = newComponent
		table.insert(metatables, metatable)
	end

	for metatable, component in pairs(entity) do
		if not components[metatable] then
			self:_trackChanged(metatable, id, component, nil)
		end
	end

	self._entityMetatablesCache[id] = metatables

	self:_transitionArchetype(id, components)
end

--[=[
	Despawns a given entity by ID, removing it and all its components from the world entirely.

	@param id number -- The entity ID
]=]
function World:despawn(id)
	local entity = self:_getEntity(id)

	for metatable, component in pairs(entity) do
		self:_trackChanged(metatable, id, component, nil)
	end

	self._entityMetatablesCache[id] = nil
	self:_transitionArchetype(id, nil)

	self._size -= 1
end

--[=[
	Removes all entities from the world.

	:::caution
	Removing entities in this way is not reported by `queryChanged`.
	:::
]=]
function World:clear()
	local firstStorage = {}
	self._storages = { firstStorage }
	self._pristineStorage = firstStorage
	self._entityArchetypes = {}
	self._entityMetatablesCache = {}
	self._size = 0
	self._changedStorage = {}
end

--[=[
	Checks if the given entity ID is currently spawned in this world.

	@param id number -- The entity ID
	@return bool -- `true` if the entity exists
]=]
function World:contains(id)
	return self._entityArchetypes[id] ~= nil
end

--[=[
	Gets a specific component (or set of components) from a specific entity in this world.

	@param id number -- The entity ID
	@param ... Component -- The components to fetch
	@return ... -- Returns the component values in the same order they were passed in
]=]
function World:get(id, ...)
	assertWorldOperationIsValid(self, id, ...)

	local entity = self:_getEntity(id)

	local length = select("#", ...)

	if length == 1 then
		assertValidComponent((...), 1)
		return entity[...]
	end

	local components = {}
	for i = 1, length do
		local metatable = select(i, ...)
		assertValidComponent(metatable, i)
		components[i] = entity[metatable]
	end

	return unpack(components, 1, length)
end

local function noop() end

local noopQuery = setmetatable({
	next = noop,
	snapshot = function()
		return {}
	end,
	without = function(self)
		return self
	end,
	view = function()
		return setmetatable({
			get = noop,
			contains = function()
				return false
			end,
		}, {
			__iter = function()
				return noop
			end,
			__call = noop,
		})
	end,
}, {
	__iter = function()
		return noop
	end,
	__call = noop,
})

--[=[
	@class QueryResult

	A result from the [`World:query`](/api/World#query) function.

	Calling the table or the `next` method allows iteration over the results. Once all results have been returned, the
	QueryResult is exhausted and is no longer useful.

	```lua
	for id, enemy, charge, model in world:query(Enemy, Charge, Model) do
		-- Do something
	end
	```
]=]

local QueryResult = {}
QueryResult.__index = QueryResult

function QueryResult.new(world, expand, queryArchetype, compatibleArchetypes, metatables)
	return setmetatable({
		world = world,
		seenEntities = {},
		currentCompatibleArchetype = next(compatibleArchetypes),
		compatibleArchetypes = compatibleArchetypes,
		storageIndex = 1,
		metatables = metatables,
		_expand = expand,
		_queryArchetype = queryArchetype,
	}, QueryResult)
end

local function nextItem(query)
	local world = query.world
	local currentCompatibleArchetype = query.currentCompatibleArchetype
	local seenEntities = query.seenEntities
	local compatibleArchetypes = query.compatibleArchetypes

	local entityId, entityData

	local storages = world._storages
	repeat
		local nextStorage = storages[query.storageIndex]
		local currently = nextStorage[currentCompatibleArchetype]
		if currently then
			entityId, entityData = next(currently, query.lastEntityId)
		end

		while entityId == nil do
			currentCompatibleArchetype = next(compatibleArchetypes, currentCompatibleArchetype)

			if currentCompatibleArchetype == nil then
				query.storageIndex += 1

				nextStorage = storages[query.storageIndex]

				if nextStorage == nil or next(nextStorage) == nil then
					return
				end

				currentCompatibleArchetype = nil

				if world._pristineStorage == nextStorage then
					world:_markStorageDirty()
				end

				continue
			elseif nextStorage[currentCompatibleArchetype] == nil then
				continue
			end

			entityId, entityData = next(nextStorage[currentCompatibleArchetype])
		end

		query.lastEntityId = entityId

	until seenEntities[entityId] == nil

	query.currentCompatibleArchetype = currentCompatibleArchetype

	seenEntities[entityId] = true

	return entityId, entityData
end

function QueryResult:__iter()
	return function()
		return self._expand(nextItem(self))
	end
end

function QueryResult:__call()
	return self._expand(nextItem(self))
end

--[=[
	Returns the next set of values from the query result. Once all results have been returned, the
	QueryResult is exhausted and is no longer useful.

	:::info
	This function is equivalent to calling the QueryResult as a function. When used in a for loop, this is implicitly
	done by the language itself.
	:::

	```lua
	-- Using world:query in this position will make Lua invoke the table as a function. This is conventional.
	for id, enemy, charge, model in world:query(Enemy, Charge, Model) do
		-- Do something
	end
	```

	If you wanted to iterate over the QueryResult without a for loop, it's recommended that you call `next` directly
	instead of calling the QueryResult as a function.
	```lua
	local id, enemy, charge, model = world:query(Enemy, Charge, Model):next()
	local id, enemy, charge, model = world:query(Enemy, Charge, Model)() -- Possible, but unconventional
	```

	@return id -- Entity ID
	@return ...ComponentInstance -- The requested component values
]=]
function QueryResult:next()
	return self._expand(nextItem(self))
end

local snapshot = {
	__iter = function(self): any
		local i = 0
		return function()
			i += 1

			local data = self[i]

			if data then
				return unpack(data, 1, data.n)
			end
			return
		end
	end,
}

--[=[
	Creates a "snapshot" of this query, draining this QueryResult and returning a list containing all of its results.

	By default, iterating over a QueryResult happens in "real time": it iterates over the actual data in the ECS, so
	changes that occur during the iteration will affect future results.

	By contrast, `QueryResult:snapshot()` creates a list of all of the results of this query at the moment it is called,
	so changes made while iterating over the result of `QueryResult:snapshot` do not affect future results of the
	iteration.

	Of course, this comes with a cost: we must allocate a new list and iterate over everything returned from the
	QueryResult in advance, so using this method is slower than iterating over a QueryResult directly.

	The table returned from this method has a custom `__iter` method, which lets you use it as you would use QueryResult
	directly:

	```lua
		for entityId, health, player in world:query(Health, Player):snapshot() do

		end
	```

	However, the table itself is just a list of sub-tables structured like `{entityId, component1, component2, ...etc}`.

	@return {{entityId: number, component: ComponentInstance, component: ComponentInstance, component: ComponentInstance, ...}}
]=]
function QueryResult:snapshot()
	local list = setmetatable({}, snapshot)

	local function iter()
		return nextItem(self)
	end

	for entityId, entityData in iter do
		if entityId then
			table.insert(list, table.pack(self._expand(entityId, entityData)))
		end
	end

	return list
end

--[=[
	Returns an iterator that will skip any entities that also have the given components.

	:::tip
	This is essentially equivalent to querying normally, using `World:get` to check if a component is present,
	and using Lua's `continue` keyword to skip this iteration (though, using `:without` is faster).

	This means that you should avoid queries that return a very large amount of results only to filter them down
	to a few with `:without`. If you can, always prefer adding components and making your query more specific.
	:::

	@param ... Component -- The component types to filter against.
	@return () -> (id, ...ComponentInstance) -- Iterator of entity ID followed by the requested component values

	```lua
	for id in world:query(Target):without(Model) do
		-- Do something
	end
	```
]=]

function QueryResult:without(...)
	local world = self.world
	local filter = negateArchetypeOf(...)

	local negativeArchetype = `{self._queryArchetype}x{filter}`

	if world._queryCache[negativeArchetype] == nil then
		world:_newQueryArchetype(negativeArchetype)
	end

	local compatibleArchetypes = world._queryCache[negativeArchetype]

	self.compatibleArchetypes = compatibleArchetypes
	self.currentCompatibleArchetype = next(compatibleArchetypes)
	return self
end

--[=[
	@class View

	Provides random access to the results of a query.

	Calling the View is equivalent to iterating a query.

	```lua
	for id, player, health, poison in world:query(Player, Health, Poison):view() do
		-- Do something
	end
	```
]=]

--[=[
	Creates a View of the query and does all of the iterator tasks at once at an amortized cost.
	This is used for many repeated random access to an entity. If you only need to iterate, just use a query.

	```lua
	local inflicting = world:query(Damage, Hitting, Player):view()
	for _, source in world:query(DamagedBy) do
		local damage = inflicting:get(source.from)
	end

	for _ in world:query(Damage):view() do end -- You can still iterate views if you want!
	```

	@return View See [View](/api/View) docs.
]=]

function QueryResult:view()
	local components = {}
	local metatables = self.metatables
	local queryLength = #metatables
	local componentRecords = {}
	for index, metatable in metatables do
		components[index] = {}
		componentRecords[metatable] = index
	end

	local function iter()
		return nextItem(self)
	end

	local entities = {}
	local entityIndex = 0
	local entityRecords = {}

	for entityId, entityData in iter do
		entityIndex += 1

		for metatable, componentIndex in componentRecords do
			components[componentIndex][entityId] = entityData[metatable]
		end

		entities[entityIndex] = entityId
		entityRecords[entityId] = entityIndex
	end

	local View = {}
	View.__index = View

	local tuple = {}
	local function expand(entity)
		if queryLength == 1 then
			return components[1][entity]
		elseif queryLength == 2 then
			return components[1][entity], components[2][entity]
		elseif queryLength == 3 then
			return components[1][entity], components[2][entity], components[3][entity]
		elseif queryLength == 4 then
			return components[1][entity], components[2][entity], components[3][entity], components[4][entity]
		elseif queryLength == 5 then
			return components[1][entity],
				components[2][entity],
				components[3][entity],
				components[4][entity],
				components[5][entity]
		end

		for index, componentField in components do
			tuple[index] = componentField[entity]
		end

		return unpack(tuple)
	end

	function View:__iter()
		local index = 0
		return function()
			index += 1
			local entity = entities[index]
			if not entity then
				return
			end

			return entity, expand(entity)
		end
	end

	--[=[
		@within View
			Retrieve the query results to corresponding `entity`
		@param entity number - the entity ID
		@return ...ComponentInstance
	]=]
	function View:get(entity)
		if not self:contains(entity) then
			return
		end

		return expand(entity)
	end

	--[=[
		@within View
		Equivalent to `world:contains()`
		@param entity number - the entity ID
		@return boolean
	]=]

	function View:contains(entity)
		return entityRecords[entity] ~= nil
	end

	return setmetatable({}, View)
end

--[=[
	Performs a query against the entities in this World. Returns a [QueryResult](/api/QueryResult), which iterates over
	the results of the query.

	Order of iteration is not guaranteed.

	```lua
	for id, enemy, charge, model in world:query(Enemy, Charge, Model) do
		-- Do something
	end

	for id in world:query(Target):without(Model) do
		-- Again, with feeling
	end
	```

	@param ... Component -- The component types to query. Only entities with *all* of these components will be returned.
	@return QueryResult -- See [QueryResult](/api/QueryResult) docs.
]=]

function World:query(...)
	debug.profilebegin("World:query")
	assertValidComponent((...), 1)

	local metatables = { ... }
	local queryLength = select("#", ...)

	local archetype = archetypeOf(...)

	if self._queryCache[archetype] == nil then
		self:_newQueryArchetype(archetype)
	end

	local compatibleArchetypes = self._queryCache[archetype]

	debug.profileend()

	if next(compatibleArchetypes) == nil then
		-- If there are no compatible storages avoid creating our complicated iterator
		return noopQuery
	end

	local queryOutput = table.create(queryLength)

	local function expand(entityId, entityData)
		if not entityId then
			return
		end

		if queryLength == 1 then
			return entityId, entityData[metatables[1]]
		elseif queryLength == 2 then
			return entityId, entityData[metatables[1]], entityData[metatables[2]]
		elseif queryLength == 3 then
			return entityId, entityData[metatables[1]], entityData[metatables[2]], entityData[metatables[3]]
		elseif queryLength == 4 then
			return entityId,
				entityData[metatables[1]],
				entityData[metatables[2]],
				entityData[metatables[3]],
				entityData[metatables[4]]
		elseif queryLength == 5 then
			return entityId,
				entityData[metatables[1]],
				entityData[metatables[2]],
				entityData[metatables[3]],
				entityData[metatables[4]],
				entityData[metatables[5]]
		end

		for i, metatable in ipairs(metatables) do
			queryOutput[i] = entityData[metatable]
		end

		return entityId, unpack(queryOutput, 1, queryLength)
	end

	if self._pristineStorage == self._storages[1] then
		self:_markStorageDirty()
	end

	return QueryResult.new(self, expand, archetype, compatibleArchetypes, metatables)
end

local function cleanupQueryChanged(hookState)
	local world = hookState.world
	local componentToTrack = hookState.componentToTrack

	for index, object in world._changedStorage[componentToTrack] do
		if object == hookState.storage then
			table.remove(world._changedStorage[componentToTrack], index)
			break
		end
	end

	if next(world._changedStorage[componentToTrack]) == nil then
		world._changedStorage[componentToTrack] = nil
	end
end

--[=[
	@interface ChangeRecord
	@within World
	.new? ComponentInstance -- The new value of the component. Nil if just removed.
	.old? ComponentInstance -- The former value of the component. Nil if just added.
]=]

--[=[
	:::info Topologically-aware function
	This function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).
	:::

	Queries for components that have changed **since the last time your system ran `queryChanged`**.

	Only one changed record is returned per entity, even if the same entity changed multiple times. The order
	in which changed records are returned is not guaranteed to be the order that the changes occurred in.

	It should be noted that `queryChanged` does not have the same iterator invalidation concerns as `World:query`.

	:::tip
	The first time your system runs (i.e., on the first frame), all existing entities in the world that match your query
	are returned as "new" change records.
	:::

	:::info
	Calling this function from your system creates storage internally for your system. Then, changes meeting your
	criteria are pushed into your storage. Calling `queryChanged` again each frame drains this storage.

	If your system isn't called every frame, the storage will continually fill up and does not empty unless you drain
	it.

	If you stop calling `queryChanged` in your system, changes will stop being tracked.
	:::

	### Returns
	`queryChanged` returns an iterator function, so you call it in a for loop just like `World:query`.

	The iterator returns the entity ID, followed by a [`ChangeRecord`](#ChangeRecord).

	The `ChangeRecord` type is a table that contains two fields, `new` and `old`, respectively containing the new
	component instance, and the old component instance. `new` and `old` will never be the same value.

	`new` will be nil if the component was removed (or the entity was despawned), and `old` will be nil if the
	component was just added.

	The `old` field will be the value of the component the last time this system observed it, not
	necessarily the value it changed from most recently.

	The `ChangeRecord` table is potentially shared with multiple systems tracking changes for this component, so it
	cannot be modified.

	```lua
	for id, record in world:queryChanged(Model) do
		if record.new == nil then
			-- Model was removed

			if enemy.type == "this is a made up example" then
				world:remove(id, Enemy)
			end
		end
	end
	```

	@param componentToTrack Component -- The component you want to listen to changes for.
	@return () -> (id, ChangeRecord) -- Iterator of entity ID and change record
]=]
function World:queryChanged(componentToTrack, ...: nil)
	if ... then
		error("World:queryChanged does not take any additional parameters", 2)
	end

	local hookState = topoRuntime.useHookState(componentToTrack, cleanupQueryChanged)

	if hookState.storage then
		return function(): any
			local entityId, record = next(hookState.storage)

			if entityId then
				hookState.storage[entityId] = nil

				return entityId, record
			end
			return
		end
	end

	if not self._changedStorage[componentToTrack] then
		self._changedStorage[componentToTrack] = {}
	end

	local storage = {}
	hookState.storage = storage
	hookState.world = self
	hookState.componentToTrack = componentToTrack

	table.insert(self._changedStorage[componentToTrack], storage)

	local queryResult = self:query(componentToTrack)

	return function(): any
		local entityId, component = queryResult:next()

		if entityId then
			return entityId, table.freeze({ new = component })
		end
		return
	end
end

function World:_trackChanged(metatable, id, old, new)
	if not self._changedStorage[metatable] then
		return
	end

	if old == new then
		return
	end

	local record = table.freeze({
		old = old,
		new = new,
	})

	for _, storage in ipairs(self._changedStorage[metatable]) do
		-- If this entity has changed since the last time this system read it,
		-- we ensure that the "old" value is whatever the system saw it as last, instead of the
		-- "old" value we have here.
		if storage[id] then
			storage[id] = table.freeze({ old = storage[id].old, new = new })
		else
			storage[id] = record
		end
	end
end

--[=[
	Inserts a component (or set of components) into an existing entity.

	If another instance of a given component already exists on this entity, it is replaced.

	```lua
	world:insert(
		entityId,
		ComponentA({
			foo = "bar"
		}),
		ComponentB({
			baz = "qux"
		})
	)
	```

	@param id number -- The entity ID
	@param ... ComponentInstance -- The component values to insert
]=]
function World:insert(id, ...)
	debug.profilebegin("insert")

	assertWorldOperationIsValid(self, id, ...)

	local entity = self:_getEntity(id)

	local wasNew = false
	for i = 1, select("#", ...) do
		local newComponent = select(i, ...)

		assertValidComponentInstance(newComponent, i)

		local metatable = getmetatable(newComponent)

		local oldComponent = entity[metatable]

		if not oldComponent then
			wasNew = true

			table.insert(self._entityMetatablesCache[id], metatable)
		end

		self:_trackChanged(metatable, id, oldComponent, newComponent)

		entity[metatable] = newComponent
	end

	if wasNew then -- wasNew
		self:_transitionArchetype(id, entity)
	end

	debug.profileend()
end

--[=[
	Removes a component (or set of components) from an existing entity.

	```lua
	local removedA, removedB = world:remove(entityId, ComponentA, ComponentB)
	```

	@param id number -- The entity ID
	@param ... Component -- The components to remove
	@return ...ComponentInstance -- Returns the component instance values that were removed in the order they were passed.
]=]
function World:remove(id, ...)
	assertWorldOperationIsValid(self, id, ...)

	local entity = self:_getEntity(id)

	local length = select("#", ...)
	local removed = {}

	for i = 1, length do
		local metatable = select(i, ...)

		assertValidComponent(metatable, i)

		local oldComponent = entity[metatable]

		removed[i] = oldComponent

		self:_trackChanged(metatable, id, oldComponent, nil)

		entity[metatable] = nil
	end

	-- Rebuild entity metatable cache
	local metatables = {}

	for metatable in pairs(entity) do
		table.insert(metatables, metatable)
	end

	self._entityMetatablesCache[id] = metatables

	self:_transitionArchetype(id, entity)

	return unpack(removed, 1, length)
end

--[=[
	Returns the number of entities currently spawned in the world.
]=]
function World:size()
	return self._size
end

--[=[
	:::tip
	[Loop] automatically calls this function on your World(s), so there is no need to call it yourself if you're using
	a Loop.
	:::

	If you are not using a Loop, you should call this function at a regular interval (i.e., once per frame) to optimize
	the internal storage for queries.

	This is part of a strategy to eliminate iterator invalidation when modifying the World while inside a query from
	[World:query]. While inside a query, any changes to the World are stored in a separate location from the rest of
	the World. Calling this function combines the separate storage back into the main storage, which speeds things up
	again.
]=]
function World:optimizeQueries()
	if #self._storages == 1 then
		return
	end

	local firstStorage = self._storages[1]

	for i = 2, #self._storages do
		local storage = self._storages[i]

		for archetype, entities in storage do
			if firstStorage[archetype] == nil then
				firstStorage[archetype] = entities
			else
				for entityId, entityData in entities do
					if firstStorage[archetype][entityId] then
						error("Entity ID already exists in first storage...")
					end
					firstStorage[archetype][entityId] = entityData
				end
			end
		end
	end

	table.clear(self._storages)

	self._storages[1] = firstStorage
	self._pristineStorage = firstStorage
end

return World
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="205">
                <Properties>
                  <string name="Name">World.spec</string>
                  <string name="Source"><![CDATA[local World = require(script.Parent.World)
local Loop = require(script.Parent.Loop)
local component = require(script.Parent).component
local BindableEvent = require(script.Parent.mock.BindableEvent)

local function deepEquals(a, b)
	if type(a) ~= "table" or type(b) ~= "table" then
		return a == b
	end

	for k in pairs(a) do
		local av = a[k]
		local bv = b[k]
		if type(av) == "table" and type(bv) == "table" then
			local result = deepEquals(av, bv)
			if not result then
				return false
			end
		elseif av ~= bv then
			return false
		end
	end

	-- extra keys in b
	for k in pairs(b) do
		if a[k] == nil then
			return false
		end
	end

	return true
end

local function assertDeepEqual(a, b)
	if not deepEquals(a, b) then
		print("EXPECTED:", b)
		print("GOT:", a)
		error("Tables were not deep-equal")
	end
end

return function()
	describe("World", function()
		it("should be iterable", function()
			local world = World.new()
			local A = component()
			local B = component()

			local eA = world:spawn(A())
			local eB = world:spawn(B())
			local eAB = world:spawn(A(), B())

			local count = 0
			for id, data in world do
				count += 1
				if id == eA then
					expect(data[A]).to.be.ok()
					expect(data[B]).to.never.be.ok()
				elseif id == eB then
					expect(data[B]).to.be.ok()
					expect(data[A]).to.never.be.ok()
				elseif id == eAB then
					expect(data[A]).to.be.ok()
					expect(data[B]).to.be.ok()
				else
					error("unknown entity", id)
				end
			end

			expect(count).to.equal(3)
		end)

		it("should have correct size", function()
			local world = World.new()
			world:spawn()
			world:spawn()
			world:spawn()

			local id = world:spawn()
			world:despawn(id)

			expect(world:size()).to.equal(3)

			world:clear()

			expect(world:size()).to.equal(0)
		end)

		it("should report contains correctly", function()
			local world = World.new()
			local id = world:spawn()

			expect(world:contains(id)).to.equal(true)
			expect(world:contains(1234124124124124124124)).to.equal(false)
		end)

		it("should allow spawning entities at a specific ID", function()
			local world = World.new()

			local A = component()
			local id = world:spawnAt(5, A())

			expect(function()
				world:spawnAt(5, A())
			end).to.throw()

			expect(id).to.equal(5)

			local nextId = world:spawn(A())
			expect(nextId).to.equal(6)
		end)

		it("should allow inserting and removing components from existing entities", function()
			local world = World.new()

			local Player = component()
			local Health = component()
			local Poison = component()

			local id = world:spawn(Player(), Poison())

			expect(world:query(Player):next()).to.be.ok()
			expect(world:query(Health):next()).to.never.be.ok()

			world:insert(id, Health())

			expect(world:query(Player):next()).to.be.ok()
			expect(world:query(Health):next()).to.be.ok()
			expect(world:size()).to.equal(1)

			local player, poison = world:remove(id, Player, Poison)

			expect(getmetatable(player)).to.equal(Player)
			expect(getmetatable(poison)).to.equal(Poison)

			expect(world:query(Player):next()).to.never.be.ok()
			expect(world:query(Health):next()).to.be.ok()
			expect(world:size()).to.equal(1)
		end)

		it("should not find any entities", function()
			local world = World.new()

			local Hello = component()
			local Bob = component()
			local Shirley = component()

			local _helloBob = world:spawn(Hello(), Bob())
			local _helloShirley = world:spawn(Hello(), Shirley())

			local withoutCount = 0
			for _ in world:query(Hello):without(Bob, Shirley) do
				withoutCount += 1
			end

			expect(withoutCount).to.equal(0)
		end)

		it("should be queryable", function()
			local world = World.new()

			local Player = component()
			local Health = component()
			local Poison = component()

			local one = world:spawn(
				Player({
					name = "alice",
				}),
				Health({
					value = 100,
				}),
				Poison()
			)

			world:spawn( -- Spawn something we don't want to get back
				component()(),
				component()()
			)

			local two = world:spawn(
				Player({
					name = "bob",
				}),
				Health({
					value = 99,
				})
			)

			local found = {}
			local foundCount = 0

			for entityId, player, health in world:query(Player, Health) do
				foundCount += 1
				found[entityId] = {
					[Player] = player,
					[Health] = health,
				}
			end

			expect(foundCount).to.equal(2)

			expect(found[one]).to.be.ok()
			expect(found[one][Player].name).to.equal("alice")
			expect(found[one][Health].value).to.equal(100)

			expect(found[two]).to.be.ok()
			expect(found[two][Player].name).to.equal("bob")
			expect(found[two][Health].value).to.equal(99)

			local count = 0
			for id, player in world:query(Player) do
				expect(type(player.name)).to.equal("string")
				expect(type(id)).to.equal("number")
				count += 1
			end
			expect(count).to.equal(2)

			local withoutCount = 0
			for _id, _player in world:query(Player):without(Poison) do
				withoutCount += 1
			end

			expect(withoutCount).to.equal(1)
		end)

		it("should return an empty query with the same methods", function()
			local world = World.new()

			local Player = component()
			local Enemy = component()

			expect(world:query(Player):next()).to.equal(nil)
			expect(#world:query(Player):snapshot()).to.equal(0)

			expect(world:query(Player):without(Enemy):next()).to.equal(world:query(Player):next())

			expect(world:query(Player):view():get()).to.equal(nil)
			expect(world:query(Player):view():contains()).to.equal(false)

			local viewCount = 0
			for _ in world:query(Player):view() do
				viewCount += 1
			end

			expect(viewCount).to.equal(0)
		end)

		it("should allow getting single components", function()
			local world = World.new()

			local Player = component()
			local Health = component()
			local Other = component()

			local id = world:spawn(Other({ a = 1 }), Player({ b = 2 }), Health({ c = 3 }))

			expect(world:get(id, Player).b).to.equal(2)
			expect(world:get(id, Health).c).to.equal(3)

			local one, two = world:get(id, Health, Player)

			expect(one.c).to.equal(3)
			expect(two.b).to.equal(2)
		end)

		it("should return existing entities when creating queryChanged", function()
			local world = World.new()

			local loop = Loop.new(world)

			local A = component()

			local initial = {
				world:spawn(A({
					a = 1,
				})),
				world:spawn(A({
					b = 2,
				})),
			}

			local third

			local runCount = 0
			loop:scheduleSystem(function(world)
				runCount += 1

				local map = {}
				local count = 0

				for entityId, record in world:queryChanged(A) do
					count += 1
					map[entityId] = record
				end

				if runCount == 1 then
					expect(count).to.equal(2)
					expect(map[initial[1]].new.a).to.equal(1)
					expect(map[initial[1]].old).to.equal(nil)
					expect(map[initial[2]].new.b).to.equal(2)
				else
					expect(count).to.equal(1)
					expect(map[third].new.c).to.equal(3)
				end
			end)

			local defaultBindable = BindableEvent.new()

			loop:begin({ default = defaultBindable.Event })

			defaultBindable:Fire()

			expect(runCount).to.equal(1)

			third = world:spawn(A({
				c = 3,
			}))

			defaultBindable:Fire()
			expect(runCount).to.equal(2)
		end)

		it("should find entity without and with component", function()
			local world = World.new()

			local Character = component("Character")
			local LocalOwned = component("LocalOwned")

			local _helloBob = world:spawn(Character(), LocalOwned())

			local withoutCount = 0
			for _ in world:query(Character):without(LocalOwned) do
				withoutCount += 1
			end

			expect(withoutCount).to.equal(0)

			world:remove(_helloBob, LocalOwned)

			local withoutCount = 0
			for _ in world:query(Character):without(LocalOwned) do
				withoutCount += 1
			end

			expect(withoutCount).to.equal(1)

			world:insert(_helloBob, LocalOwned())

			local withoutCount = 0
			for _ in world:query(Character):without(LocalOwned) do
				withoutCount += 1
			end

			expect(withoutCount).to.equal(0)
		end)

		it("should track changes", function()
			local world = World.new()

			local loop = Loop.new(world)

			local A = component()
			local B = component()
			local C = component()

			local expectedResults = {
				nil,
				{
					1,
					{
						new = {
							generation = 1,
						},
					},
				},
				{
					1,
					{
						new = {
							generation = 2,
						},
						old = {
							generation = 1,
						},
					},
				},
				{
					2,
					{
						new = {
							generation = 1,
						},
					},
				},
				nil,
				{
					1,
					{
						old = {
							generation = 2,
						},
					},
				},
				{
					2,
					{
						old = {
							generation = 1,
						},
					},
				},
			}

			local resultIndex = 0

			local additionalQuery = C
			loop:scheduleSystem(function(w)
				local ran = false

				for entityId, record in w:queryChanged(A) do
					if additionalQuery then
						if w:get(entityId, additionalQuery) == nil then
							continue
						end
					end

					ran = true
					resultIndex += 1

					expect(entityId).to.equal(expectedResults[resultIndex][1])

					assertDeepEqual(record, expectedResults[resultIndex][2])
				end

				if not ran then
					resultIndex += 1
					expect(expectedResults[resultIndex]).to.equal(nil)
				end
			end)

			local infrequentCount = 0
			loop:scheduleSystem({
				system = function(w)
					infrequentCount += 1

					local count = 0
					local results = {}
					for entityId, record in w:queryChanged(A) do
						count += 1
						results[entityId - 1] = record
					end

					if count == 0 then
						expect(infrequentCount).to.equal(1)
					else
						if infrequentCount == 2 then
							expect(count).to.equal(2)

							expect(results[0].old).to.equal(nil)
							expect(results[0].new.generation).to.equal(2)
							expect(results[1].old).to.equal(nil)
							expect(results[1].new).to.equal(nil)
						elseif infrequentCount == 3 then
							expect(results[0].old.generation).to.equal(2)
							expect(results[0].new).to.equal(nil)
							expect(count).to.equal(1)
						else
							error("infrequentCount too high")
						end
					end
				end,
				event = "infrequent",
			})

			local defaultBindable = BindableEvent.new()
			local infrequentBindable = BindableEvent.new()

			loop:begin({ default = defaultBindable.Event, infrequent = infrequentBindable.Event })

			defaultBindable:Fire()
			infrequentBindable:Fire()

			local entityId = world:spawn(
				A({
					generation = 1,
				}),
				C()
			)

			defaultBindable:Fire()

			additionalQuery = nil

			world:insert(
				entityId,
				A({
					generation = 2,
				})
			)

			world:insert(
				entityId,
				B({
					foo = "bar",
				})
			)

			local secondEntityId = world:spawn(
				A({
					generation = 1,
				}),
				C()
			)

			defaultBindable:Fire()
			defaultBindable:Fire()

			world:replace(secondEntityId, B())

			infrequentBindable:Fire()

			world:despawn(entityId)

			defaultBindable:Fire()

			infrequentBindable:Fire()
		end)

		it("should error when passing nil to query", function()
			expect(function()
				World.new():query(nil)
			end).to.throw()
		end)

		it("should error when passing an invalid table", function()
			local world = World.new()
			local id = world:spawn()

			expect(function()
				world:insert(id, {})
			end).to.throw()
		end)

		it("should error when passing a Component instead of Component instance", function()
			expect(function()
				World.new():spawn(component())
			end).to.throw()
		end)

		it("should error when no components are passed to world:get", function()
			expect(function()
				local world = World.new()
				local id = world:spawn()
				world:get(id)
			end).to.throw()
		end)

		it("should error when no components are passed to world:insert", function()
			expect(function()
				local world = World.new()
				local id = world:spawn()
				world:insert(id)
			end).to.throw()
		end)

		it("should error when no components are passed to world:replace", function()
			expect(function()
				local world = World.new()
				local id = world:spawn()
				world:replace(id)
			end).to.throw()
		end)

		it("should error when no components are passed to world:remove", function()
			expect(function()
				local world = World.new()
				local id = world:spawn()
				world:remove(id)
			end).to.throw()
		end)

		it("should error when entity does not exist (get, insert, replace, remove)", function()
			expect(function()
				local world = World.new()

				world:get(2000)
				world:insert(2000)
				world:replace(2000)
				world:remove(2000)

				world:get()
				world:insert()
				world:replace()
				world:remove()
			end).to.throw()
		end)

		it("should allow snapshotting a query", function()
			local world = World.new()

			local Player = component()
			local Health = component()
			local Poison = component()

			local one = world:spawn(
				Player({
					name = "alice",
				}),
				Health({
					value = 100,
				}),
				Poison()
			)

			world:spawn( -- Spawn something we don't want to get back
				component()(),
				component()()
			)

			local two = world:spawn(
				Player({
					name = "bob",
				}),
				Health({
					value = 99,
				})
			)

			local query = world:query(Health, Player)
			local snapshot = query:snapshot()

			for entityId, health, player in snapshot do
				expect(type(entityId)).to.equal("number")
				expect(type(player.name)).to.equal("string")
				expect(type(health.value)).to.equal("number")
			end

			world:remove(two, Health)
			world:despawn(one)

			if snapshot[2][1] == 3 then
				expect(snapshot[1][1]).to.equal(1)
			else
				expect(snapshot[2][1]).to.equal(1)
			end

			expect(#world:query(Player):without(Poison):snapshot()).to.equal(1)
		end)

		it("should contain entity in view", function()
			local ComponentA = component("ComponentA")
			local ComponentB = component("ComponentB")

			local world = World.new()

			local entityA = world:spawn(ComponentA())
			local entityB = world:spawn(ComponentB())

			local viewA = world:query(ComponentA):view()
			local viewB = world:query(ComponentB):view()

			expect(viewA:contains(entityA)).to.equal(true)
			expect(viewA:contains(entityB)).to.equal(false)
			expect(viewB:contains(entityB)).to.equal(true)
			expect(viewB:contains(entityA)).to.equal(false)
		end)

		it("should get entity data from view", function()
			local numComponents = 20
			local components = {}

			for i = 1, numComponents do
				table.insert(components, component("Component" .. i))
			end

			local world = World.new()

			local componentInstances = {}

			for _, componentFn in components do
				table.insert(componentInstances, componentFn())
			end

			local entityA = world:spawn(table.unpack(componentInstances))

			local viewA = world:query(table.unpack(components)):view()
			local viewB = world:query(components[1]):view()

			expect(select("#", viewA:get(entityA))).to.equal(numComponents)
			expect(select("#", viewB:get(entityA))).to.equal(1)

			local viewAEntityAData = { viewA:get(entityA) }

			for index, componentData in viewAEntityAData do
				expect(getmetatable(componentData)).to.equal(components[index])
			end

			local viewBEntityAData = { viewB:get(entityA) }

			expect(getmetatable(viewBEntityAData[1])).to.equal(components[1])
		end)

		it("should return view results in query order", function()
			local Parent = component("Parent")
			local Transform = component("Transform")
			local Root = component("Root")

			local world = World.new()

			local root = world:spawn(Transform({ pos = Vector2.new(3, 4) }), Root())
			local _otherRoot = world:spawn(Transform({ pos = Vector2.new(1, 2) }), Root())

			local child = world:spawn(
				Parent({
					entity = root,
					fromChild = Transform({ pos = Vector2.one }),
				}),
				Transform.new({ pos = Vector2.zero })
			)

			local _otherChild = world:spawn(
				Parent({
					entity = root,
					fromChild = Transform({ pos = Vector2.new(0, 0) }),
				}),
				Transform.new({ pos = Vector2.zero })
			)

			local _grandChild = world:spawn(
				Parent({
					entity = child,
					fromChild = Transform({ pos = Vector2.new(-1, 0) }),
				}),
				Transform.new({ pos = Vector2.zero })
			)

			local parents = world:query(Parent):view()
			local roots = world:query(Transform, Root):view()

			expect(parents:contains(root)).to.equal(false)

			local orderOfIteration = {}

			for id in world:query(Transform, Parent) do
				table.insert(orderOfIteration, id)
			end

			local view = world:query(Transform, Parent):view()
			local i = 0
			for id in view do
				i += 1
				expect(orderOfIteration[i]).to.equal(id)
			end

			for id, absolute, parent in world:query(Transform, Parent) do
				local relative = parent.fromChild.pos
				local ancestor = parent.entity
				local current = parents:get(ancestor)
				while current do
					relative = current.fromChild.pos * relative
					ancestor = current.entity
					current = parents:get(ancestor)
				end

				local pos = roots:get(ancestor).pos

				world:insert(id, absolute:patch({ pos = Vector2.new(pos.x + relative.x, pos.y + relative.y) }))
			end

			expect(world:get(child, Transform).pos).to.equal(Vector2.new(4, 5))
		end)

		it("should not invalidate iterators", function()
			local world = World.new()
			local A = component()
			local B = component()
			local C = component()

			for _ = 1, 10 do
				world:spawn(A(), B())
			end

			local count = 0
			for id in world:query(A) do
				count += 1
				world:insert(id, C())
				world:remove(id, B)
			end
			expect(count).to.equal(10)
		end)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="206">
                <Properties>
                  <string name="Name">archetype</string>
                  <string name="Source"><![CDATA[local toSet = require(script.Parent.immutable).toSet

local valueIds = {}
local nextValueId = 0
local compatibilityCache = {}
local archetypeCache = {}

local function getValueId(value)
	local valueId = valueIds[value]
	if valueId == nil then
		valueIds[value] = nextValueId
		valueId = nextValueId
		nextValueId += 1
	end

	return valueId
end

function archetypeOf(...)
	debug.profilebegin("archetypeOf")

	local length = select("#", ...)

	local currentNode = archetypeCache

	for i = 1, length do
		local nextNode = currentNode[select(i, ...)]

		if not nextNode then
			nextNode = {}
			currentNode[select(i, ...)] = nextNode
		end

		currentNode = nextNode
	end

	if currentNode._archetype then
		debug.profileend()
		return currentNode._archetype
	end

	local list = table.create(length)

	for i = 1, length do
		list[i] = getValueId(select(i, ...))
	end

	table.sort(list)

	local archetype = table.concat(list, "_")

	currentNode._archetype = archetype

	debug.profileend()

	return archetype
end

function negateArchetypeOf(...)
	return string.gsub(archetypeOf(...), "_", "x")
end

function areArchetypesCompatible(queryArchetype, targetArchetype)
	local archetypes = string.split(queryArchetype, "x")
	local baseArchetype = table.remove(archetypes, 1)

	local cachedCompatibility = compatibilityCache[queryArchetype .. "-" .. targetArchetype]
	if cachedCompatibility ~= nil then
		return cachedCompatibility
	end
	debug.profilebegin("areArchetypesCompatible")

	local queryIds = string.split(baseArchetype, "_")
	local targetIds = toSet(string.split(targetArchetype, "_"))
	local excludeIds = toSet(archetypes)

	for _, queryId in ipairs(queryIds) do
		if targetIds[queryId] == nil then
			compatibilityCache[queryArchetype .. "-" .. targetArchetype] = false
			debug.profileend()
			return false
		end
	end

	for excludeId in excludeIds do
		if targetIds[excludeId] then
			compatibilityCache[queryArchetype .. "-" .. targetArchetype] = false
			debug.profileend()
			return false
		end
	end

	compatibilityCache[queryArchetype .. "-" .. targetArchetype] = true

	debug.profileend()
	return true
end

return {
	archetypeOf = archetypeOf,
	negateArchetypeOf = negateArchetypeOf,
	areArchetypesCompatible = areArchetypesCompatible,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="207">
                <Properties>
                  <string name="Name">archetype.spec</string>
                  <string name="Source"><![CDATA[local archetype = require(script.Parent.archetype)
local component = require(script.Parent).component

return function()
	describe("archetype", function()
		it("should report same sets as same archetype", function()
			local a = component()
			local b = component()
			expect(archetype.archetypeOf(a, b)).to.equal(archetype.archetypeOf(b, a))
		end)
		it("should identify compatible archetypes", function()
			local a = component()
			local b = component()
			local c = component()

			local archetypeA = archetype.archetypeOf(a, b, c)
			local archetypeB = archetype.archetypeOf(a, b)
			local archetypeC = archetype.archetypeOf(b, c)

			expect(archetype.areArchetypesCompatible(archetypeA, archetypeB)).to.equal(false)
			expect(archetype.areArchetypesCompatible(archetypeB, archetypeA)).to.equal(true)

			expect(archetype.areArchetypesCompatible(archetypeC, archetypeA)).to.equal(true)
			expect(archetype.areArchetypesCompatible(archetypeB, archetypeC)).to.equal(false)
		end)
		it("should identify compatible archetypes with negations", function()
			local a = component()
			local b = component()
			local c = component()

			local archetypeAB = archetype.archetypeOf(a, b)
			local negativeArchetypeBC = archetype.negateArchetypeOf(b, c)

			expect(archetype.areArchetypesCompatible(negativeArchetypeBC, archetypeAB)).to.equal(true)
		end)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="208">
                <Properties>
                  <string name="Name">component</string>
                  <string name="Source"><![CDATA[local merge = require(script.Parent.immutable).merge

--[=[
	@class Component

	A component is a named piece of data that exists on an entity.
	Components are created and removed in the [World](/api/World).

	In the docs, the terms "Component" and "ComponentInstance" are used:
	- **"Component"** refers to the base class of a specific type of component you've created.
		This is what [`Matter.component`](/api/Matter#component) returns.
	- **"Component Instance"** refers to an actual piece of data that can exist on an entity.
		The metatable of a component instance table is its respective Component table.

	Component instances are *plain-old data*: they do not contain behaviors or methods.

	Since component instances are immutable, one helper function exists on all component instances, `patch`,
	which allows reusing data from an existing component instance to make up for the ergonomic loss of mutations.
]=]

--[=[
	@within Component
	@type ComponentInstance {}

	The `ComponentInstance` type refers to an actual piece of data that can exist on an entity.
	The metatable of the component instance table is set to its particular Component table.

	A component instance can be created by calling the Component table:

	```lua
	-- Component:
	local MyComponent = Matter.component("My component")

	-- component instance:
	local myComponentInstance = MyComponent({
		some = "data"
	})

	print(getmetatable(myComponentInstance) == MyComponent) --> true
	```
]=]

-- This is a special value we set inside the component's metatable that will allow us to detect when
-- a Component is accidentally inserted as a Component Instance.
-- It should not be accessible through indexing into a component instance directly.
local DIAGNOSTIC_COMPONENT_MARKER = {}

local function newComponent(name, defaultData)
	name = name or debug.info(2, "s") .. "@" .. debug.info(2, "l")

	assert(
		defaultData == nil or type(defaultData) == "table",
		"if component default data is specified, it must be a table"
	)

	local component = {}
	component.__index = component

	function component.new(data)
		data = data or {}

		if defaultData then
			data = merge(defaultData, data)
		end

		return table.freeze(setmetatable(data, component))
	end

	--[=[
	@within Component

	```lua
	for id, target in world:query(Target) do
		if shouldChangeTarget(target) then
			world:insert(id, target:patch({ -- modify the existing component
				currentTarget = getNewTarget()
			}))
		end
	end
	```

	A utility function used to immutably modify an existing component instance. Key/value pairs from the passed table
	will override those of the existing component instance.

	As all components are immutable and frozen, it is not possible to modify the existing component directly.

	You can use the `Matter.None` constant to remove a value from the component instance:

	```lua
	target:patch({
		currentTarget = Matter.None -- sets currentTarget to nil
	})
	```

	@param partialNewData {} -- The table to be merged with the existing component data.
	@return ComponentInstance -- A copy of the component instance with values from `partialNewData` overriding existing values.
	]=]
	function component:patch(partialNewData)
		debug.profilebegin("patch")
		local patch = getmetatable(self).new(merge(self, partialNewData))
		debug.profileend()
		return patch
	end

	setmetatable(component, {
		__call = function(_, ...)
			return component.new(...)
		end,
		__tostring = function()
			return name
		end,
		[DIAGNOSTIC_COMPONENT_MARKER] = true,
	})

	return component
end

local function assertValidType(value, position)
	if typeof(value) ~= "table" then
		error(string.format("Component #%d is invalid: not a table", position), 3)
	end

	local metatable = getmetatable(value)

	if metatable == nil then
		error(string.format("Component #%d is invalid: has no metatable", position), 3)
	end
end

local function assertValidComponent(value, position)
	assertValidType(value, position)

	local metatable = getmetatable(value)

	if getmetatable(metatable) ~= nil and getmetatable(metatable)[DIAGNOSTIC_COMPONENT_MARKER] then
		error(
			string.format(
				"Component #%d is invalid: Component Instance %s was passed instead of the Component itself!",
				position,
				tostring(metatable)
			),
			3
		)
	end
end

local function assertValidComponentInstance(value, position)
	assertValidType(value, position)

	if getmetatable(value)[DIAGNOSTIC_COMPONENT_MARKER] ~= nil then
		error(
			string.format(
				"Component #%d is invalid: passed a Component instead of a Component instance; "
					.. "did you forget to call it as a function?",
				position
			),
			3
		)
	end
end

local function assertComponentArgsProvided(...)
	if not (...) then
		error(`No components passed to world:{debug.info(3, "n")}, at least one component is required`, 2)
	end
end

return {
	newComponent = newComponent,
	assertValidComponentInstance = assertValidComponentInstance,
	assertValidComponent = assertValidComponent,
	assertComponentArgsProvided = assertComponentArgsProvided,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="209">
                <Properties>
                  <string name="Name">component.spec</string>
                  <string name="Source"><![CDATA[local Component = require(script.Parent.component)
local None = require(script.Parent.immutable).None
local component = Component.newComponent
local assertValidComponentInstance = Component.assertValidComponentInstance
local assertValidComponent = Component.assertValidComponent

return function()
	describe("Component", function()
		it("should create components", function()
			local a = component()
			local b = component()

			expect(getmetatable(a)).to.be.ok()

			expect(getmetatable(a)).to.never.equal(getmetatable(b))

			expect(typeof(a.new)).to.equal("function")
		end)

		it("should allow calling the table to construct", function()
			local a = component()

			expect(getmetatable(a())).to.equal(getmetatable(a.new()))
		end)

		it("should allow patching into a new component", function()
			local A = component()

			local a = A({
				foo = "bar",
				unset = true,
			})

			local a2 = a:patch({
				baz = "qux",
				unset = None,
			})

			expect(a2.foo).to.equal("bar")
			expect(a2.unset).to.equal(nil)
			expect(a2.baz).to.equal("qux")
		end)

		it("should allow specifying default data", function()
			local Foo = component("Foo", {
				a = 53,
			})

			local foo = Foo()

			expect(foo.a).to.equal(53)

			local bar = Foo({
				a = 42,
				b = 54,
			})

			expect(bar.a).to.equal(42)
			expect(bar.b).to.equal(54)

			local baz = Foo({
				b = 100,
			})

			expect(baz.a).to.equal(53)
			expect(baz.b).to.equal(100)
		end)
	end)

	describe("assertValidComponentInstance", function()
		it("should throw on invalid components", function()
			expect(function()
				assertValidComponentInstance({})
			end).to.throw()

			expect(function()
				assertValidComponentInstance(55)
			end).to.throw()

			expect(function()
				assertValidComponentInstance(component())
			end).to.throw()

			expect(function()
				assertValidComponentInstance(component().new())
			end).never.to.throw()
		end)
	end)

	describe("assertValidComponent", function()
		it("should throw on invalid components", function()
			expect(function()
				assertValidComponent(component().new())
			end).to.throw()

			expect(function()
				assertValidComponent(55)
			end).to.throw()

			expect(function()
				assertValidComponent(component())
			end).never.to.throw()
		end)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="210">
                <Properties>
                  <string name="Name">debugger</string>
                </Properties>
                <Item class="ModuleScript" referent="211">
                  <Properties>
                    <string name="Name">EventBridge</string>
                    <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local EventBridge = {}
EventBridge.__index = EventBridge

local debouncedEvents = {
	InputChanged = true,
}

local debounce = {}

local function serialize(...)
	local first = ...

	if first and typeof(first) == "Instance" and first:IsA("InputObject") then
		return {
			Delta = first.Delta,
			KeyCode = first.KeyCode,
			Position = first.Position,
			UserInputState = first.UserInputState,
			UserInputType = first.UserInputType,
		}
	end

	return ...
end

local clientConnections = {}
EventBridge.clientActions = {
	connect = function(fire, instance, event)
		local instanceFromServer = instance

		if type(instance) == "string" then
			instance = game:GetService(instance)
		end

		if clientConnections[instance] == nil then
			clientConnections[instance] = {}
		end

		clientConnections[instance][event] = instance[event]:Connect(function(...)
			if debouncedEvents[event] and not RunService:IsStudio() then
				local args = table.pack(serialize(...))

				if debounce[instance] and debounce[instance][event] then
					debounce[instance][event] = args
				else
					if debounce[instance] == nil then
						debounce[instance] = {}
					end

					debounce[instance][event] = args

					task.delay(0.25, function()
						local args = debounce[instance][event]

						fire("event", instanceFromServer, event, unpack(args, 1, args.n))

						debounce[instance][event] = nil

						if next(debounce[instance]) == nil then
							debounce[instance] = nil
						end
					end)
				end

				return
			end

			fire("event", instanceFromServer, event, serialize(...))
		end)
	end,

	disconnect = function(_fire, instance, event)
		if type(instance) == "string" then
			instance = game:GetService(instance)
		end

		if clientConnections[instance] and clientConnections[instance][event] then
			clientConnections[instance][event]:Disconnect()
			clientConnections[instance][event] = nil
		end
	end,
}

function EventBridge.new(fire)
	return setmetatable({
		_fire = fire,
		_storage = {},
		players = {},
	}, EventBridge)
end

function EventBridge:connect(instance, event, handler)
	if RunService:IsClient() then
		return instance[event]:Connect(handler)
	end

	if not game:IsAncestorOf(instance) then
		local connection

		connection = instance.AncestryChanged:Connect(function()
			if connection == nil then
				return
			end

			if game:IsAncestorOf(instance) then
				connection:Disconnect()
				connection = nil
				self:connect(instance, event, handler)
			end
		end)

		return
	end

	if self._storage[instance] == nil then
		self._storage[instance] = {}

		instance.Destroying:Connect(function()
			for event in self._storage[instance] do
				self:_disconnect(instance, event)
			end
		end)
	end

	self._storage[instance][event] = handler

	for _, player in self.players do
		self:_connectPlayerEvent(player, instance, event)
	end

	return {
		Disconnect = function()
			self:_disconnect(instance, event)
		end,
	}
end

function EventBridge:_connectPlayerEvent(player, instance, event)
	if instance.Parent == game then
		instance = instance.ClassName
	end

	self._fire(player, "connect", instance, event)
end

function EventBridge:_disconnectPlayerEvent(player, instance, event)
	if instance.Parent == game then
		instance = instance.ClassName
	end

	self._fire(player, "disconnect", instance, event)
end

function EventBridge:connectPlayer(player)
	for instance, events in self._storage do
		for event in events do
			self:_connectPlayerEvent(player, instance, event)
		end
	end

	table.insert(self.players, player)
end

function EventBridge:disconnectPlayer(player)
	local index = table.find(self.players, player)

	if not index then
		return
	end

	table.remove(self.players, index)

	for instance, events in self._storage do
		for event in events do
			self:_disconnectPlayerEvent(player, instance, event)
		end
	end
end

function EventBridge:_disconnect(instance, event)
	self._storage[instance][event] = nil

	for _, player in self.players do
		self:_disconnectPlayerEvent(player, instance, event)
	end
end

function EventBridge:fireEventFromPlayer(player, instance, event, ...)
	if not table.find(self.players, player) then
		warn(player, "fired a debugger event but they aren't authorized")
		return
	end

	if type(instance) == "string" then
		instance = game:GetService(instance)
	end

	if not self._storage[instance] or not self._storage[instance][event] then
		-- warn(player, "fired a debugger event but the instance has no connections")
		return
	end

	self._storage[instance][event](...)
end

return EventBridge
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="212">
                  <Properties>
                    <string name="Name">clientBindings</string>
                    <string name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")
local CollectionService = game:GetService("CollectionService")

local tags = {
	system = "MatterDebuggerTooltip_System",
	altHover = "MatterDebuggerTooltip_AltHover",
}

local function getOffset(mousePos: Vector2, tag: string): UDim2
	if tag == tags.altHover then
		return UDim2.fromOffset(mousePos.X + 20, mousePos.Y)
	elseif tag == tags.system then
		return UDim2.fromOffset(mousePos.X + 20, mousePos.Y + 10)
	end

	return UDim2.fromOffset(mousePos.X, mousePos.Y + 10)
end

local function clientBindings(debugger)
	local connections = {}

	table.insert(
		connections,
		CollectionService:GetInstanceAddedSignal("MatterDebuggerSwitchToClientView"):Connect(function(instance)
			instance.Activated:Connect(function()
				debugger:switchToClientView()
			end)
		end)
	)

	table.insert(
		connections,
		UserInputService.InputChanged:Connect(function(input)
			if input.UserInputType ~= Enum.UserInputType.MouseMovement then
				return
			end

			local mousePosition = UserInputService:GetMouseLocation()

			for _, tag in tags do
				for _, gui in CollectionService:GetTagged(tag) do
					gui.Position = getOffset(mousePosition, tag)
				end
			end
		end)
	)

	for _, tag in tags do
		table.insert(
			connections,
			CollectionService:GetInstanceAddedSignal(tag):Connect(function(gui)
				local mousePosition = UserInputService:GetMouseLocation()
				gui.Position = getOffset(mousePosition, tag)
			end)
		)
	end

	return connections
end

return clientBindings
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="213">
                  <Properties>
                    <string name="Name">debugger</string>
                    <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local hookWidgets = require(script.Parent.hookWidgets)
local World = require(script.Parent.Parent.World)
local EventBridge = require(script.Parent.EventBridge)
local ui = require(script.Parent.ui)
local mouseHighlight = require(script.Parent.mouseHighlight)
local clientBindings = require(script.Parent.clientBindings)
local hookWorld = require(script.Parent.hookWorld)

local customWidgetConstructors: { [string]: any } = {
	panel = require(script.Parent.widgets.panel),
	selectionList = require(script.Parent.widgets.selectionList),
	container = require(script.Parent.widgets.container),
	frame = require(script.Parent.widgets.frame),
	link = require(script.Parent.widgets.link),
	realmSwitch = require(script.Parent.widgets.realmSwitch),
	valueInspect = require(script.Parent.widgets.valueInspect),
	worldInspect = require(script.Parent.widgets.worldInspect),
	entityInspect = require(script.Parent.widgets.entityInspect),
	tooltip = require(script.Parent.widgets.tooltip),
	hoverInspect = require(script.Parent.widgets.hoverInspect),
	queryInspect = require(script.Parent.widgets.queryInspect),
	codeText = require(script.Parent.widgets.codeText),
	errorInspect = require(script.Parent.widgets.errorInspect),
}

local IS_SERVER = RunService:IsServer()
local IS_CLIENT = RunService:IsClient()

local remoteEvent, clientBindingConnections

-- Assert plasma is compatible via feature detection
local function assertCompatiblePlasma(plasma)
	if not plasma.highlight then
		error("Plasma passed to Matter debugger is out of date, please update it to use the debugger.")
	end
end

--[=[
	@class Debugger

	Attaches a Debugger to the Matter instance, allowing you to create debug widgets in your systems.

	```lua
	local debugger = Matter.Debugger.new(Plasma)

	local widgets = debugger:getWidgets()
	local loop = Matter.Loop.new(world, widgets) -- pass the widgets to your systems

	debugger:autoInitialize(loop)

	if IS_CLIENT then
		debugger:show()
	end
	```

	When the debugger is not open, the widgets do not render.
]=]
local Debugger = {}
Debugger.__index = Debugger

--[=[
	@prop authorize (player: Player) -> boolean
	@within Debugger

	Create this property in Debugger to specify a function that will be called to determine if a player should be
	allowed to connect to the server-side debugger. In Studio, this property is ignored.

	If not specified, the default behavior is to allow anyone in Studio and disallow everyone in a live game.

	```lua
	debugger.authorize = function(player)
		if player:GetRankInGroup(372) > 250 then -- etc
			return true
		end
	end
	```
]=]

--[=[
	@prop findInstanceFromEntity (entityId: number) -> Instance?
	@within Debugger

	Create this property in Debugger to specify a function that will be called to determine what Instance is associated
	with an entity. This is used for the in-world highlight in the World inspector.

	If not specified, the in-world highlight will not work.

	```lua
	debugger.findInstanceFromEntity = function(id)
		if not world:contains(id) then
			return
		end

		local model = world:get(id, components.Model)

		return model and model.model or nil
	end
	```
]=]

--[=[
	@prop componentRefreshFrequency number
	@within Debugger

	Create this property in Debugger to specify the frequency (in seconds) that the unique component list will refresh.

	If not specified, it will use a default time of 3 seconds.

	```lua
	debugger.componentRefreshFrequency = 1
	```
]=]

--[=[
	@prop loopParameterNames {string}
	@within Debugger

	Create this property in Debugger to specify the names of the parameters to your Loop constructor. This is used to
	display a more accurate name in the debugger.

	If not specified, the default behavior is to label Worlds as "World" and tables as "table", followed by its index.

	```lua
	debugger.loopParameterNames = {"World", "State", "Widgets"}
	```
]=]

--[=[
	Creates a new Debugger.

	You need to depend on [Plasma](https://matter-ecs.github.io/plasma/) in your project and pass a handle to it here.

	@param plasma Plasma -- The instance of Plasma used in your game.
	@return Debugger
]=]
function Debugger.new(plasma)
	assertCompatiblePlasma(plasma)

	if not remoteEvent then
		if IS_SERVER then
			remoteEvent = Instance.new("RemoteEvent")
			remoteEvent.Name = "MatterDebuggerRemote"
			remoteEvent.Parent = ReplicatedStorage
		else
			remoteEvent = ReplicatedStorage:WaitForChild("MatterDebuggerRemote")

			remoteEvent.OnClientEvent:Connect(function(action, ...)
				if not EventBridge.clientActions[action] then
					return
				end

				EventBridge.clientActions[action](function(...)
					remoteEvent:FireServer(...)
				end, ...)
			end)
		end
	end

	local self = setmetatable({
		plasma = plasma,
		loop = nil,
		loopParameterNames = {},
		enabled = false,
		componentRefreshFrequency = 3,
		_windowCount = 0,
		_queries = {},
		_queryDurationSamples = {},
		_seenEvents = {},
		_eventOrder = {},
		_eventBridge = EventBridge.new(function(...)
			remoteEvent:FireClient(...)
		end),
		_playersUsingDebugger = {},
		_customWidgets = {},
	}, Debugger)

	for name, create in customWidgetConstructors do
		self._customWidgets[name] = create(plasma)
	end

	if IS_SERVER then
		self:_connectRemoteEvent()
	else
		if not clientBindingConnections then
			clientBindingConnections = clientBindings(self)
		end
	end

	return self
end

function Debugger:_connectRemoteEvent()
	remoteEvent.OnServerEvent:Connect(function(player, action, instance, event, ...)
		if action == "event" then
			self._eventBridge:fireEventFromPlayer(player, instance, event, ...)
		elseif action == "start" then
			if not RunService:IsStudio() then
				if self.authorize then
					if not self.authorize(player) then
						return
					end
				else
					warn("Player attempted to connect to matter debugger but no authorize function is configured.")
					return
				end
			end
			self:connectPlayer(player)
		elseif action == "stop" then
			self:disconnectPlayer(player)
		elseif action == "inspect" then
			self.debugEntity = instance
		elseif action == "hover" then
			self.hoverEntity = instance
		end
	end)
end

--[=[
	@client

	Shows the debugger panel
]=]
function Debugger:show()
	if not IS_CLIENT then
		error("show can only be called from the client")
	end

	self:_enable()
end

--[=[
	@client

	Hides the debugger panel
]=]
function Debugger:hide()
	if not IS_CLIENT then
		error("hide can only be called from the client")
	end

	self:_disable()

	if self:_isServerView() then
		self:switchToClientView()
	end
end

--[=[
	@client

	Toggles visibility of the debugger panel
]=]
function Debugger:toggle()
	if not IS_CLIENT then
		error("toggle can only be called from the client")
	end

	if self.enabled then
		self:_disable()
	else
		self:_enable()
	end
end

function Debugger:_enable()
	if self.enabled then
		return
	end

	-- TODO: Find a better way for the user to specify the world.
	if not self.debugWorld then
		for _, object in self.loop._state do
			if getmetatable(object) == World then
				self.debugWorld = object
				break
			end
		end
	end

	self.enabled = true
	self.loop.profiling = self.loop.profiling or {}

	hookWorld.hookWorld(self)
end

function Debugger:_disable()
	self.enabled = false
	self.debugSystem = nil
	self.loop.profiling = nil
	hookWorld.unhookWorld()

	if self.plasmaNode then
		self.plasma.start(self.plasmaNode, function() end)
	end
end

function Debugger:connectPlayer(player)
	if not IS_SERVER then
		error("connectClient can only be called from the server")
	end

	if not self.enabled then
		print("Matter server debugger started")
		self:_enable()
	end

	self._eventBridge:connectPlayer(player)
	self._playersUsingDebugger[player] = true
end

function Debugger:disconnectPlayer(player)
	if not IS_SERVER then
		error("disconnectClient can only be called from the server")
	end

	self._eventBridge:disconnectPlayer(player)
	self._playersUsingDebugger[player] = nil

	if #self._eventBridge.players == 0 then
		self:_disable()
		self.debugSystem = nil
		print("Matter server debugger stopped")
	end
end

--[=[
	Adds middleware to your Loop to set up the debugger every frame.

	:::tip
	The debugger must also be shown on a client with [Debugger:show] or [Debugger:toggle] to be used.
	:::

	:::caution
	[Debugger:autoInitialize] should be called before [Loop:begin] to function as expected.
	:::

	If you also want to use Plasma for more than just the debugger, you can opt to not call this function and instead
	do what it does yourself.

	@param loop Loop
]=]
function Debugger:autoInitialize(loop)
	self.loop = loop
	loop._debugger = self

	self.loop.trackErrors = true

	local parent = Instance.new("ScreenGui")
	parent.Name = "MatterDebugger"
	parent.DisplayOrder = 2 ^ 31 - 1
	parent.ResetOnSpawn = false
	parent.IgnoreGuiInset = true
	parent.AutoLocalize = false

	if IS_CLIENT then
		parent.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
	else
		parent.Parent = ReplicatedStorage
	end

	local plasmaNode = self.plasma.new(parent)
	self.plasmaNode = plasmaNode

	self.loop:addMiddleware(function(nextFn, eventName)
		return function()
			if not self._seenEvents[eventName] then
				self._seenEvents[eventName] = true
				table.insert(self._eventOrder, eventName)
			end

			if not self.enabled then
				nextFn()
				return
			end

			if eventName == self._eventOrder[1] then
				self._continueHandle = self.plasma.beginFrame(plasmaNode, function()
					self.plasma.setEventCallback(function(...)
						return self._eventBridge:connect(...)
					end)

					self:update()

					nextFn()
				end)
			elseif self._continueHandle then
				self.plasma.continueFrame(self._continueHandle, function()
					self.plasma.setEventCallback(function(...)
						return self._eventBridge:connect(...)
					end)

					nextFn()
				end)
			end

			if eventName == self._eventOrder[#self._eventOrder] then
				self.plasma.finishFrame(plasmaNode)
			end
		end
	end)

	if IS_CLIENT then
		self.plasma.hydrateAutomaticSize()
	end
end

--[=[
	Alert the debugger when a system is hot reloaded.

	@param old System
	@param new System
]=]
function Debugger:replaceSystem(old, new)
	if self.debugSystem == old then
		self.debugSystem = new
	end
end

--[=[
	@client

	Switch the client to server view. This starts the server debugger if it isn't already started.
]=]
function Debugger:switchToServerView()
	if not IS_CLIENT then
		error("switchToServerView may only be called from the client.")
	end

	self.debugSystem = nil

	if not self.serverGui then
		self.serverGui = ReplicatedStorage:WaitForChild("MatterDebugger")

		self.serverGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
	end

	remoteEvent:FireServer("start")

	self.serverGui.Enabled = true
end

--[=[
	Switch the client to client view. This stops the server debugger if there are no other players connected.
]=]
function Debugger:switchToClientView()
	if not IS_CLIENT then
		error("switchToClientView may only be called from the client.")
	end

	if not self.serverGui then
		return
	end

	remoteEvent:FireServer("stop")

	self.serverGui.Enabled = false
end

function Debugger:_isServerView()
	return self.serverGui and self.serverGui.Enabled
end

--[=[
	This should be called to draw the debugger UI.

	This is automatically set up when you call [Debugger:autoInitialize], so you don't need to call this yourself unless
	you didn't call `autoInitialize`.
]=]
function Debugger:update()
	ui(self, self.loop)

	table.clear(self._queries)

	if IS_CLIENT then
		mouseHighlight(self, remoteEvent)
	end
end

--[=[
	Returns a handle to the debug widgets you can pass to your systems.

	All [plasma widgets](https://matter-ecs.github.io/plasma/api/Plasma#widgets) are available under this namespace.

	```lua
	-- ...
	local debugger = Debugger.new(Plasma)

	local loop = Loop.new(world, state, debugger:getWidgets())
	```

	When the Debugger is not open, calls to widgets are no-ops.

	If the widget normally returns a handle (e.g., button returns a table with `clicked`), it returns a static dummy
	handle that always returns a default value:

	- `checkbox`
		- `clicked`: false
		- `checked`: false
	- `button`
		- `clicked`: false
	- `slider`: 0

	@return {[string]: Widget}
]=]
function Debugger:getWidgets()
	return hookWidgets(self)
end

return Debugger
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="214">
                  <Properties>
                    <string name="Name">formatTable</string>
                    <string name="Source"><![CDATA[local stringColor = "#dcdcaa"
local numberColor = "#b0c4de"
local keywordColor = "#c586c0"

function colorize(value, color)
	if type(value) == "number" then
		value = string.format("%.1f", value)
	end

	return `<font color="{color}">{value}</font>`
end

function colorizeMany(color, ...)
	local values = { ... }

	for i, value in ipairs(values) do
		values[i] = colorize(value, color)
	end

	return table.unpack(values)
end

function wrap(name, value)
	return `{colorize(name, keywordColor)}({value})`
end

function commaSeparate(dots, ...)
	local str = table.concat({ ... }, ", ")

	if dots then
		str ..= ", .."
	end

	return str
end

local FormatMode = {
	Short = "Short",
	Long = "Long",
}
local function formatTable(object, mode, _padLength, _depth)
	mode = mode or FormatMode.Short
	_padLength = _padLength or 0
	_depth = _depth or 1

	local max = if mode == FormatMode.Short then 7 else 1000

	local str = ""

	if mode == FormatMode.Short or _depth > 1 then
		str ..= "{"
	end

	local values = {}

	for key, value in pairs(object) do
		table.insert(values, {
			key = key,
			value = value,
		})
	end

	table.sort(values, function(a, b)
		return tostring(a.key) < tostring(b.key)
	end)

	local count = 0
	for _, entry in values do
		local key = entry.key
		local value = entry.value

		local part = ""

		if count > 0 then
			part ..= ", "
		end

		if mode == FormatMode.Long and (if count == 0 then _depth > 1 else true) then
			part ..= `\n{string.rep("  ", _depth - 1)}`
		end

		count += 1
		if type(key) == "string" then
			part ..= key .. (if mode == FormatMode.Short then "=" else " = ")
		elseif type(key) == "table" then
			if mode == FormatMode.Short then
				part ..= "[{..}]="
			else
				part ..= "["
				part ..= formatTable(key, FormatMode.Short, #str + #part + _padLength, _depth + 1)
				part ..= "] = "
			end
		end

		local luaType = type(value)
		local robloxType = typeof(value)

		local valueStr = tostring(value)

		if luaType == "string" then
			part ..= colorize(`"{value:sub(1, max)}"`, stringColor)
		elseif luaType == "number" then
			part ..= colorize(valueStr, numberColor)
		elseif luaType == "boolean" then
			part ..= colorize(valueStr, keywordColor)
		elseif luaType == "table" then
			if mode == FormatMode.Short then
				part ..= "{..}"
			else
				part ..= formatTable(value, FormatMode.Long, #str + #part + _padLength, _depth + 1)
			end
		elseif mode == FormatMode.Long and (luaType == "userdata" or luaType == "vector") then
			if robloxType == "CFrame" then
				local x, y, z = value:components()
				local separated = commaSeparate(true, colorizeMany(numberColor, x, y, z))
				part ..= wrap("CFrame", separated)
			elseif robloxType == "Vector3" then
				local separated = commaSeparate(false, colorizeMany(numberColor, value.X, value.Y, value.Z))
				part ..= wrap("Vector3", separated)
			elseif robloxType == "Vector2" then
				local separated = commaSeparate(false, colorizeMany(numberColor, value.X, value.Y))
				part ..= wrap("Vector2", separated)
			else
				part ..= wrap(robloxType, valueStr)
			end
		else
			part ..= valueStr:sub(1, max)
		end

		if mode == FormatMode.Short and #str + #part + _padLength > 30 then
			if count > 1 then
				str ..= ", "
			end

			str ..= ".."

			break
		else
			str ..= part
		end

		if mode == FormatMode.Short and #part + _padLength > 30 then
			part ..= ", .."
			break
		end
	end

	if mode == FormatMode.Long and _depth > 1 and #values > 0 then
		str ..= `\n{string.rep("  ", _depth - 2)}`
	end

	if mode == FormatMode.Short or _depth > 1 then
		str ..= "}"
	end

	return str
end

return {
	formatTable = formatTable,
	FormatMode = FormatMode,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="215">
                  <Properties>
                    <string name="Name">hookWidgets</string>
                    <string name="Source"><![CDATA[local useCurrentSystem = require(script.Parent.Parent.topoRuntime).useCurrentSystem

local widgets = {
	"arrow",
	"blur",
	"button",
	"checkbox",
	"error",
	"portal",
	"row",
	"slider",
	"spinner",
	"window",
	"label",
	"heading",
	"space",
	"table",
}

local dummyHandles = {
	checkbox = {
		clicked = function()
			return false
		end,
		checked = function()
			return false
		end,
	},

	button = {
		clicked = function()
			return false
		end,
	},

	slider = function(config)
		if type(config) == "table" then
			config = config.initial
		end
		return config
	end,

	window = {
		closed = function()
			return false
		end,
	},

	table = {
		selected = function() end,
		hovered = function() end,
	},
}

local function hookWidgets(debugger)
	local hookedWidgets = {}

	for _, name in widgets do
		local widget = debugger.plasma[name]

		hookedWidgets[name] = function(...)
			local debugSystem = debugger.debugSystem

			if debugSystem == nil or debugSystem ~= useCurrentSystem() then
				local dummyHandle = dummyHandles[name]
				if type(dummyHandle) == "function" then
					dummyHandle = dummyHandle(...)
				end
				return dummyHandle
			end

			if debugger._windowCount > 0 then
				return widget(...)
			end

			local args = table.pack(...)

			local parent = if name == "window" then debugger.parent else debugger.frame

			local returnValue
			debugger.plasma.portal(parent, function()
				returnValue = widget(unpack(args, 1, args.n))
			end)

			return returnValue
		end
	end

	local window = hookedWidgets.window
	hookedWidgets.window = function(title, fn)
		return window(title, function()
			debugger._windowCount += 1
			fn()
			debugger._windowCount -= 1
		end)
	end

	return hookedWidgets
end

return hookWidgets
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="216">
                  <Properties>
                    <string name="Name">hookWorld</string>
                    <string name="Source"><![CDATA[--#selene:allow(empty_loop)
local useCurrentSystem = require(script.Parent.Parent.topoRuntime).useCurrentSystem
local World = require(script.Parent.Parent.World)
local rollingAverage = require(script.Parent.Parent.rollingAverage)

local originalQuery = World.query

local function hookWorld(debugger)
	World.query = function(world, ...)
		if useCurrentSystem() == debugger.debugSystem then
			local start = os.clock()

			-- while this seems like a mistake, it is necessary!
			-- we duplicate the query to avoid draining the original one.
			-- we iterate through so we can calculate the query's budget
			-- see https://github.com/matter-ecs/matter/issues/106
			-- and https://github.com/matter-ecs/matter/pull/107
			for _ in originalQuery(world, ...) do
			end

			local file, line = debug.info(2, "sl")

			local key = file .. line
			local samples = debugger._queryDurationSamples
			local sample = samples[key]
			if not sample then
				sample = {}
				samples[key] = sample
			end

			local componentNames = {}
			for i = 1, select("#", ...) do
				table.insert(componentNames, tostring((select(i, ...))))
			end

			local duration = os.clock() - start
			rollingAverage.addSample(sample, duration)

			local averageDuration = rollingAverage.getAverage(debugger._queryDurationSamples[file .. line])

			table.insert(debugger._queries, {
				averageDuration = averageDuration,
				componentNames = componentNames,
			})
		end

		return originalQuery(world, ...)
	end
end

local function unhookWorld()
	World.query = originalQuery
end

return {
	hookWorld = hookWorld,
	unhookWorld = unhookWorld,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="217">
                  <Properties>
                    <string name="Name">mouseHighlight</string>
                    <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

function getInstanceOnMouse()
	local camera = workspace.CurrentCamera
	if not camera then
		return
	end

	local mouseLocation = UserInputService:GetMouseLocation()
	local ray = camera:ViewportPointToRay(mouseLocation.X, mouseLocation.Y)

	local result = workspace:Raycast(ray.Origin, ray.Direction * 1000)
	return result and result.Instance
end

local function mouseHighlight(debugger, remoteEvent)
	if not RunService:IsClient() then
		error("Hovering can only be checked on the client")
	end

	local lastSent, setLastSent = debugger.plasma.useState()

	if UserInputService:IsKeyDown(Enum.KeyCode.LeftAlt) then
		local instance = getInstanceOnMouse()

		if instance then
			local id
			while instance.Parent do
				id = instance:GetAttribute(debugger:_isServerView() and "serverEntityId" or "clientEntityId")

				if id then
					break
				end

				instance = instance.Parent
			end

			if id then
				if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
					if debugger:_isServerView() then
						remoteEvent:FireServer("inspect", id)
					else
						debugger.debugEntity = id
					end
				else
					debugger.plasma.highlight(instance, {
						fillColor = Color3.fromRGB(218, 62, 62),
					})

					if debugger:_isServerView() then
						if lastSent ~= id then
							setLastSent(id)
							remoteEvent:FireServer("hover", id)
						end
					else
						debugger.hoverEntity = id
					end
				end

				return
			end
		end
	end

	if debugger:_isServerView() then
		if lastSent ~= nil then
			remoteEvent:FireServer("hover", nil)
			setLastSent(nil)
		end
	else
		debugger.hoverEntity = nil
	end
end

return mouseHighlight
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="218">
                  <Properties>
                    <string name="Name">ui</string>
                    <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local World = require(script.Parent.Parent.World)
local rollingAverage = require(script.Parent.Parent.rollingAverage)

local function systemName(system)
	local systemFn = if type(system) == "table" then system.system else system
	local name = debug.info(systemFn, "n")

	if name ~= "" and name ~= "system" then
		return name
	end

	local source = debug.info(systemFn, "s")
	local segments = string.split(source, ".")

	return segments[#segments]
end

local timeUnits = { "s", "ms", "μs", "ns" }
local function formatDuration(duration)
	local unit = 1
	while duration < 1 and unit < #timeUnits do
		duration *= 1000
		unit += 1
	end

	return duration, timeUnits[unit]
end

local IS_SERVER = RunService:IsServer()
local IS_CLIENT = RunService:IsClient()
local LONG_SYSTEM_NAME = 24

local function ui(debugger, loop)
	local plasma = debugger.plasma
	local custom = debugger._customWidgets
	local skipSystems = loop._skipSystems

	plasma.setStyle({
		primaryColor = Color3.fromHex("bd515c"),
	})

	local objectStack = plasma.useState({})
	local worldViewOpen, setWorldViewOpen = plasma.useState(false)
	local worldExists = debugger.debugWorld ~= nil

	if debugger.hoverEntity and worldExists then
		if debugger.debugWorld:contains(debugger.hoverEntity) then
			custom.hoverInspect(debugger.debugWorld, debugger.hoverEntity, custom)
		end
	end

	local hoveredSystem

	custom.container(function()
		if debugger:_isServerView() then
			return
		end

		custom.panel(function()
			if
				custom
					.realmSwitch({
						left = "client",
						right = "server",
						isRight = IS_SERVER,
						tag = if IS_SERVER then "MatterDebuggerSwitchToClientView" else nil,
					})
					:clicked()
			then
				if IS_CLIENT then
					debugger:switchToServerView()
				end
			end

			plasma.space(15)
			plasma.heading("STATE")
			plasma.space(10)

			local items = {}

			for index, object in loop._state do
				if type(object) ~= "table" then
					continue
				end

				local isWorld = getmetatable(object) == World

				local selected = (#objectStack > 0 and object == objectStack[#objectStack].value)
					or (debugger.debugWorld == object and worldViewOpen)

				local name = debugger.loopParameterNames[index]
				local defaultName = (if isWorld then "World" else "table") .. " " .. index

				table.insert(items, {
					text = if name then name else defaultName,
					icon = if isWorld then "🌐" else "{}",
					object = object,
					selected = selected,
					isWorld = isWorld,
				})
			end

			local selectedState = custom.selectionList(items):selected()

			if selectedState then
				if selectedState.isWorld then
					if worldViewOpen and debugger.debugWorld == selectedState.object then
						debugger.debugWorld = nil
						setWorldViewOpen(false)
					else
						debugger.debugWorld = selectedState.object
						setWorldViewOpen(true)
					end
				else
					local previousFirstValue = if objectStack[1] then objectStack[1].value else nil
					table.clear(objectStack)

					if selectedState.object ~= previousFirstValue then
						objectStack[1] = {
							key = selectedState.text,
							icon = selectedState.icon,
							value = selectedState.object,
						}
					end
				end
			end

			plasma.space(15)
			plasma.heading("SYSTEMS")
			plasma.space(10)

			local durations = {}
			local longestDuration = 0

			for _, eventName in debugger._eventOrder do
				local systems = loop._orderedSystemsByEvent[eventName]

				if not systems then
					continue
				end

				plasma.heading(eventName, {
					font = Enum.Font.Gotham,
				})
				plasma.space(5)

				local listOfSystems = {}

				for _, system in systems do
					local samples = loop.profiling[system]
					if samples then
						local duration = rollingAverage.getAverage(samples)
						durations[system] = duration
						longestDuration = math.max(longestDuration, duration)
					end
				end

				for index, system in systems do
					local averageFrameTime = ""
					local icon

					local duration = durations[system] or 0
					local humanDuration, unit = formatDuration(duration)
					averageFrameTime = string.format("%.0f%s", humanDuration, unit)

					if duration > 0.004 then -- 4ms
						icon = "\xe2\x9a\xa0\xef\xb8\x8f"
					end

					if loop._systemErrors[system] then
						icon = "\xf0\x9f\x92\xa5"
					end

					local barWidth
					if longestDuration == 0 then
						barWidth = 0
					else
						barWidth = duration / longestDuration
					end

					local systemIsDisabled = skipSystems[system]
					local systemName = systemName(system)
					local length = string.len(systemName)

					if systemIsDisabled then
						length += 4
					end

					table.insert(listOfSystems, {
						text = if systemIsDisabled then `<i><s>{systemName}</s></i>` else systemName,
						sideText = if systemIsDisabled then `<b>{"(disabled)"}</b>` else averageFrameTime,
						selected = debugger.debugSystem == system,
						system = system,
						icon = icon,
						barWidth = barWidth,
						index = index,
					})
				end

				local systemList = custom.selectionList(listOfSystems, custom)
				local selected = systemList:selected()
				local rightClicked = systemList:rightClicked()
				hoveredSystem = systemList:hovered()

				if selected then
					local selectedSystem = selected.system
					if selectedSystem == debugger.debugSystem then
						debugger.debugSystem = nil
					else
						debugger.debugSystem = selectedSystem
					end
				elseif rightClicked then
					local rightClickedSystem = rightClicked.system
					if rightClickedSystem then
						skipSystems[rightClickedSystem] = not skipSystems[rightClickedSystem]
					end
				end

				if debugger.debugSystem then
					debugger.debugSystemRuntime = durations[debugger.debugSystem]
				else
					debugger.debugSystemRuntime = nil
				end

				plasma.space(10)
			end
		end)

		debugger.parent = custom.container(function()
			if debugger.debugWorld and worldViewOpen then
				local closed = custom.worldInspect(debugger, objectStack)

				if closed then
					setWorldViewOpen(false)
				end
			end

			if debugger.debugWorld and debugger.debugEntity then
				custom.entityInspect(debugger)
			end

			if #objectStack > 0 then
				custom.valueInspect(objectStack, custom)
			end

			if debugger.debugSystem then
				local queriesOpen, setQueriesOpen = plasma.useState(false)
				local logsOpen, setLogsOpen = plasma.useState(true)

				if loop._systemLogs[debugger.debugSystem] == nil then
					loop._systemLogs[debugger.debugSystem] = {}
				end

				local numLogs = #loop._systemLogs[debugger.debugSystem]

				local name = systemName(debugger.debugSystem)

				local closed = plasma
					.window({
						title = "System",
						closable = true,
					}, function()
						plasma.useKey(name)

						if plasma.button(string.format("View queries (%d)", #debugger._queries)):clicked() then
							setQueriesOpen(true)
						end

						if numLogs > 0 then
							if plasma.button(string.format("View logs (%d)", numLogs)):clicked() then
								setLogsOpen(true)
							end
						end

						local currentlyDisabled = skipSystems[debugger.debugSystem]

						if
							plasma
								.checkbox("<font size='13'>Disable System</font>", {
									checked = currentlyDisabled,
								})
								:clicked()
						then
							skipSystems[debugger.debugSystem] = not currentlyDisabled
						end
					end)
					:closed()

				if queriesOpen then
					local closed = custom.queryInspect(debugger)

					if closed then
						setQueriesOpen(false)
					end
				end

				if loop._systemErrors[debugger.debugSystem] then
					custom.errorInspect(debugger, custom)
				end

				plasma.useKey(name)

				if numLogs > 0 and logsOpen then
					local closed = plasma
						.window({
							closable = true,
							title = "Logs",
						}, function()
							local items = {}
							for i = numLogs, 1, -1 do
								table.insert(items, { loop._systemLogs[debugger.debugSystem][i] })
							end
							plasma.table(items, {
								font = Enum.Font.Code,
							})
						end)
						:closed()

					if closed then
						setLogsOpen(false)
					end
				end

				if closed then
					debugger.debugSystem = nil
				end
			end

			plasma.useKey(nil)
			debugger.frame = custom.frame()
		end, {
			marginTop = 46,
			marginLeft = 10,
			direction = Enum.FillDirection.Horizontal,
		})
	end, {
		direction = Enum.FillDirection.Horizontal,
		padding = 0,
	})

	if hoveredSystem and hoveredSystem.system then
		local hoveredSystemName = systemName(hoveredSystem.system)
		local length = string.len(hoveredSystemName)
		local systemDisabled = skipSystems[hoveredSystem.system]

		if systemDisabled then
			length += 2
		end

		if length >= LONG_SYSTEM_NAME then
			custom.tooltip(`<b>{hoveredSystemName}{if systemDisabled then " (disabled)" else ""}</b>`, {
				tag = "MatterDebuggerTooltip_System",
				backgroundTransparency = 0,
			})
		end
	end
end

return ui
]]></string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="219">
                  <Properties>
                    <string name="Name">widgets</string>
                  </Properties>
                  <Item class="ModuleScript" referent="220">
                    <Properties>
                      <string name="Name">codeText</string>
                      <string name="Source"><![CDATA[return function(Plasma)
	local create = Plasma.create

	return Plasma.widget(function(text, options)
		options = options or {}

		local refs = Plasma.useInstance(function(ref)
			return create("TextButton", {
				[ref] = "label",
				BackgroundTransparency = 1,
				Text = "",
				AutomaticSize = Enum.AutomaticSize.Y,
				Font = Enum.Font.Code,
				TextSize = 18,
				TextStrokeTransparency = 0.5,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				TextWrapped = true,
				TextColor3 = Color3.new(1, 1, 1),
				Size = UDim2.new(0, 800, 0, 0),

				create("UIPadding", {
					PaddingBottom = UDim.new(0, 8),
					PaddingLeft = UDim.new(0, 8),
					PaddingRight = UDim.new(0, 8),
					PaddingTop = UDim.new(0, 8),
				}),
			})
		end)

		refs.label.Text = text
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="221">
                    <Properties>
                      <string name="Name">container</string>
                      <string name="Source"><![CDATA[return function(Plasma)
	local create = Plasma.create

	return Plasma.widget(function(fn, options)
		options = options or {}

		local padding = options.padding or 5

		local refs = Plasma.useInstance(function(ref)
			return create("Frame", {
				[ref] = "frame",
				BackgroundTransparency = 1,
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(1, 0, 1, 0),
				AutoLocalize = false,

				create("UIPadding", {
					PaddingTop = UDim.new(0, options.marginTop or 0),
					PaddingLeft = UDim.new(0, options.marginLeft or 0),
				}),

				create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
					FillDirection = options.direction or Enum.FillDirection.Vertical,
					Padding = UDim.new(0, padding),
				}),
			})
		end)

		Plasma.scope(fn)

		return refs.frame
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="222">
                    <Properties>
                      <string name="Name">entityInspect</string>
                      <string name="Source"><![CDATA[local formatTableModule = require(script.Parent.Parent.formatTable)
local formatTable = formatTableModule.formatTable
local FormatMode = formatTableModule.FormatMode

return function(plasma)
	return plasma.widget(function(debugger)
		local style = plasma.useStyle()

		local closed = plasma
			.window({
				title = string.format("Entity %d", debugger.debugEntity),
				closable = true,
			}, function()
				if not debugger.debugWorld:contains(debugger.debugEntity) then
					debugger.debugEntity = nil
					return
				end

				if debugger.findInstanceFromEntity then
					local model = debugger.findInstanceFromEntity(debugger.debugEntity)

					if model then
						plasma.highlight(model, {
							fillColor = style.primaryColor,
						})
					end
				end

				plasma.row(function()
					if plasma.button("despawn"):clicked() then
						debugger.debugWorld:despawn(debugger.debugEntity)
						debugger.debugEntity = nil
					end
				end)

				if not debugger.debugEntity then
					return
				end

				local items = { { "Component", "Data" } }

				for component, data in debugger.debugWorld:_getEntity(debugger.debugEntity) do
					table.insert(items, {
						tostring(component),
						formatTable(data, FormatMode.Long),
					})
				end

				plasma.useKey(debugger.debugEntity)
				plasma.table(items, {
					headings = true,
					font = Enum.Font.Code,
				})
			end)
			:closed()

		if closed then
			debugger.debugEntity = nil
		end
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="223">
                    <Properties>
                      <string name="Name">errorInspect</string>
                      <string name="Source"><![CDATA[return function(plasma)
	return plasma.widget(function(debugger, custom)
		local loop = debugger.loop

		plasma.window("\xf0\x9f\x92\xa5 Errors", function()
			local text, setText = plasma.useState("")

			custom.codeText(text)

			local items = {}
			for index, errorData in loop._systemErrors[debugger.debugSystem] do
				local preview =
					errorData.error:gsub("^(.-):", ""):gsub("^%s?[%w%.]+%.(%w+:)", "%1"):gsub("\n", " "):sub(1, 60)

				items[index] = {
					DateTime.fromUnixTimestamp(errorData.when):ToIsoDate(),
					preview,

					errorData = errorData,
					selected = errorData.error == text,
				}
			end

			plasma.row(function()
				local selected = plasma
					.table(items, {
						selectable = true,
						font = Enum.Font.Code,
					})
					:selected()

				if selected then
					setText(selected.errorData.error)
				end

				if plasma.button("Clear"):clicked() then
					loop._systemErrors[debugger.debugSystem] = nil
				end
			end)
		end)
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="224">
                    <Properties>
                      <string name="Name">frame</string>
                      <string name="Source"><![CDATA[return function(Plasma)
	return Plasma.widget(function()
		local refs = Plasma.useInstance(function(ref)
			local style = Plasma.useStyle()

			local Frame = Instance.new("Frame")
			Frame.BackgroundColor3 = style.bg2
			Frame.Position = UDim2.new(0.5, 0, 0.5, 0)
			Frame.AnchorPoint = Vector2.new(0.5, 0.5)
			Frame.Size = UDim2.new(0, 50, 0, 40)
			Frame.Visible = false
			Frame.AutoLocalize = false

			local UICorner = Instance.new("UICorner")
			UICorner.Parent = Frame

			local UIPadding = Instance.new("UIPadding")
			UIPadding.PaddingBottom = UDim.new(0, 10)
			UIPadding.PaddingLeft = UDim.new(0, 10)
			UIPadding.PaddingRight = UDim.new(0, 10)
			UIPadding.PaddingTop = UDim.new(0, 10)
			UIPadding.Parent = Frame

			local UIStroke = Instance.new("UIStroke")
			UIStroke.Parent = Frame

			local UIListLayout = Instance.new("UIListLayout")
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
			UIListLayout.Parent = Frame

			local numChildren = #Frame:GetChildren()

			Plasma.automaticSize(Frame)

			local function updateVisibility()
				Frame.Visible = #Frame:GetChildren() > numChildren
			end

			Frame.ChildAdded:Connect(updateVisibility)
			Frame.ChildRemoved:Connect(updateVisibility)

			ref.frame = Frame

			return Frame
		end)

		return refs.frame
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="225">
                    <Properties>
                      <string name="Name">hoverInspect</string>
                      <string name="Source"><![CDATA[local formatTableModule = require(script.Parent.Parent.formatTable)
local formatTable = formatTableModule.formatTable
local FormatMode = formatTableModule.FormatMode

return function(plasma)
	return plasma.widget(function(world, id, custom)
		local entityData = world:_getEntity(id)

		local str = "<b>Entity " .. id .. "</b>\n\n"

		for component, componentData in pairs(entityData) do
			str ..= tostring(component) .. " "

			if next(componentData) == nil then
				str ..= "{ }\n"
			else
				str ..= (formatTable(componentData, FormatMode.Long, 0, 2) .. "\n")
			end
		end

		custom.tooltip(str, {
			tag = "MatterDebuggerTooltip_AltHover",
			backgroundTransparency = 0.15,
		})
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="226">
                    <Properties>
                      <string name="Name">link</string>
                      <string name="Source"><![CDATA[return function(Plasma)
	local create = Plasma.create

	return Plasma.widget(function(text, options)
		options = options or {}

		local clicked, setClicked = Plasma.useState(false)
		local style = Plasma.useStyle()

		local refs = Plasma.useInstance(function(ref)
			local colorHover = style.textColor

			local darker = colorHover.R * 255 * 0.8 -- 20% darker
			local color = Color3.fromRGB(darker, darker, darker)

			local button = create("TextButton", {
				[ref] = "button",
				BackgroundTransparency = 1,
				Text = "",

				create("UIPadding", {
					PaddingBottom = UDim.new(0, 0),
					PaddingLeft = UDim.new(0, 8),
					PaddingRight = UDim.new(0, 8),
					PaddingTop = UDim.new(0, 0),
				}),

				create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
					FillDirection = Enum.FillDirection.Horizontal,
				}),

				create("TextLabel", {
					Name = "Icon",
					BackgroundTransparency = 1,
					Size = UDim2.new(0, 30, 1, 0),
					Text = options.icon,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextSize = 16,
					TextColor3 = style.textColor,
					Font = Enum.Font.GothamBold,
				}),

				create("TextLabel", {
					[ref] = "mainText",
					Name = "MainText",
					BackgroundTransparency = 1,
					Size = UDim2.new(0, 0, 1, 0),
					Text = text,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextColor3 = color,
					TextSize = 14,
				}),

				Activated = function()
					if options.disabled then
						return
					end

					setClicked(true)
				end,

				MouseEnter = function()
					if options.disabled then
						return
					end

					ref.button.MainText.TextColor3 = colorHover
				end,

				MouseLeave = function()
					ref.button.MainText.TextColor3 = color
				end,
			})

			Plasma.automaticSize(button)
			Plasma.automaticSize(ref.mainText, {
				axis = Enum.AutomaticSize.X,
			})

			return button
		end)

		refs.button.MainText.Text = text

		refs.button.Icon.Text = options.icon or ""
		refs.button.Icon.Visible = not not options.icon

		refs.mainText.Font = options.font or Enum.Font.Gotham

		return {
			clicked = function()
				if clicked then
					setClicked(false)
					return true
				end

				return false
			end,
		}
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="227">
                    <Properties>
                      <string name="Name">panel</string>
                      <string name="Source"><![CDATA[return function(Plasma)
	local create = Plasma.create
	return Plasma.widget(function(children, options)
		options = options or {}

		Plasma.useInstance(function()
			local style = Plasma.useStyle()

			local frame = create("Frame", {
				Name = "Panel",
				BackgroundColor3 = style.bg2,
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(0, 260, 1, 0),

				create("Frame", {
					-- Account for GUI inset
					-- GuiService:GetGuiInset returns wrong info on the server :(
					Size = UDim2.new(1, 0, 0, 46),
					BackgroundColor3 = Color3.new(0, 0, 0),
					BackgroundTransparency = 0.5,

					create("ImageLabel", {
						Position = UDim2.new(1, -20, 0.5, 0),
						AnchorPoint = Vector2.new(1, 0.5),
						BackgroundTransparency = 1,
						Size = UDim2.new(0, 120, 0, 26),
						Image = "rbxassetid://10111567777",
					}),
				}),

				create("UIStroke", {}),

				create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
					HorizontalAlignment = Enum.HorizontalAlignment.Center,
				}),

				create("ScrollingFrame", {
					BackgroundTransparency = 1,
					Name = "Container",
					VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar,
					HorizontalScrollBarInset = Enum.ScrollBarInset.ScrollBar,
					BorderSizePixel = 0,
					ScrollBarThickness = 6,
					Size = UDim2.new(1, -40, 0, 0),

					create("UIPadding", {
						PaddingTop = UDim.new(0, 20),
					}),

					create("UIListLayout", {
						SortOrder = Enum.SortOrder.LayoutOrder,
					}),
				}),
			})

			Plasma.automaticSize(frame.Container, {
				axis = Enum.AutomaticSize.Y,
				maxSize = UDim2.new(1, 0, 1, -46),
			})

			return frame, frame.Container
		end)

		Plasma.scope(children)
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="228">
                    <Properties>
                      <string name="Name">queryInspect</string>
                      <string name="Source"><![CDATA[local function getColorForBudget(color: Color3): string
	local r = math.floor(color.R * 255)
	local g = math.floor(color.G * 255)
	local b = math.floor(color.B * 255)

	return `{r},{g},{b}`
end

return function(Plasma)
	return Plasma.widget(function(debugger)
		local queryWindow = Plasma.window({
			title = "Query Resource Usage (%)",
			closable = true,
		}, function()
			if #debugger._queries == 0 then
				return Plasma.label("No queries.")
			end

			-- Plasma windows do not respect the title, so we need to
			-- fill the content frame to extend the width of the widget
			Plasma.heading("---------------------------------------------          ")

			for i, query in debugger._queries do
				if query.changedComponent then
					Plasma.label(string.format("Query Changed %d", i))
					Plasma.heading(tostring(query.changedComponent))

					continue
				end

				local budgetUsed =
					math.clamp(math.floor((query.averageDuration / debugger.debugSystemRuntime) * 100), 0, 100)

				local color = Color3.fromRGB(135, 255, 111)
				if budgetUsed >= 75 then
					color = Color3.fromRGB(244, 73, 73)
				elseif budgetUsed >= 50 then
					color = Color3.fromRGB(255, 157, 0)
				elseif budgetUsed >= 25 then
					color = Color3.fromRGB(230, 195, 24)
				end

				Plasma.label(`<font color="rgb({getColorForBudget(color)})"><b>Query {i} - {budgetUsed}%</b></font>`)
				Plasma.heading(table.concat(query.componentNames, ", "))
			end
			return nil
		end)

		return queryWindow:closed()
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="229">
                    <Properties>
                      <string name="Name">realmSwitch</string>
                      <string name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")

return function(Plasma)
	local create = Plasma.create

	return Plasma.widget(function(options)
		local style = Plasma.useStyle()

		options = options or {}
		local left = options.left
		local right = options.right
		local isRight = options.isRight

		local clicked, setClicked = Plasma.useState(false)
		local refs = Plasma.useInstance(function(ref)
			ref.corner = create("UICorner")

			local style = Plasma.useStyle()

			create("TextButton", {
				[ref] = "button",
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 0, 25),
				Text = "",

				create("UICorner"),

				create("UIListLayout", {
					FillDirection = Enum.FillDirection.Horizontal,
				}),

				create("TextLabel", {
					[ref] = "left",
					Text = left,
					Size = UDim2.new(0.5, 0, 1, 0),
					BackgroundColor3 = style.primaryColor,
					BorderSizePixel = 0,
					TextColor3 = style.textColor,
					Font = Enum.Font.GothamMedium,
					TextSize = 14,
				}),

				create("TextLabel", {
					[ref] = "right",
					Text = right,
					Size = UDim2.new(0.5, 0, 1, 0),
					BackgroundColor3 = style.bg1,
					BorderSizePixel = 0,
					TextColor3 = style.textColor,
					Font = Enum.Font.GothamMedium,
					TextSize = 14,
				}),

				MouseEnter = function()
					local other = isRight and ref.left or ref.right
					other.BackgroundTransparency = 0.5
				end,

				MouseLeave = function()
					local other = isRight and ref.left or ref.right
					other.BackgroundTransparency = 0
				end,

				Activated = function()
					setClicked(true)
				end,
			})

			if options.tag then
				CollectionService:AddTag(ref.button, options.tag)
			end

			return ref.button
		end)

		refs.left.BackgroundColor3 = isRight and style.bg1 or style.primaryColor
		refs.right.BackgroundColor3 = isRight and style.primaryColor or style.bg1

		refs.corner.Parent = isRight and refs.right or refs.left

		local handle = {
			clicked = function()
				if clicked then
					setClicked(false)
					return true
				end

				return false
			end,
		}

		return handle
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="230">
                    <Properties>
                      <string name="Name">selectionList</string>
                      <string name="Source"><![CDATA[return function(Plasma)
	local create = Plasma.create

	local Item = Plasma.widget(function(text, selected, icon, sideText, barWidth, index)
		local clicked, setClicked = Plasma.useState(false)
		local rightClicked, setRightClicked = Plasma.useState(false)
		local hovered, setHovered = Plasma.useState(false)
		local style = Plasma.useStyle()

		local refs = Plasma.useInstance(function(ref)
			local button = create("TextButton", {
				[ref] = "button",
				AutoButtonColor = false,
				Size = UDim2.new(1, 0, 0, 25),
				Text = "",

				create("UICorner", {
					CornerRadius = UDim.new(0, 8),
				}),

				create("UIPadding", {
					PaddingBottom = UDim.new(0, 0),
					PaddingLeft = UDim.new(0, 8),
					PaddingRight = UDim.new(0, 8),
					PaddingTop = UDim.new(0, 0),
				}),

				create("Frame", {
					[ref] = "container",
					BackgroundTransparency = 1,
					Size = UDim2.new(1, 0, 1, 0),

					create("UIListLayout", {
						SortOrder = Enum.SortOrder.LayoutOrder,
						FillDirection = Enum.FillDirection.Horizontal,
						Padding = UDim.new(0, 10),
					}),

					create("TextLabel", {
						[ref] = "index",
						Name = "index",
						AutomaticSize = Enum.AutomaticSize.X,
						Size = UDim2.new(0, 0, 1, 0),
						BackgroundTransparency = 1,
						Text = index,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextSize = 11,
						TextColor3 = style.mutedTextColor,
						Font = Enum.Font.Gotham,
						Visible = index ~= nil,
					}),

					create("TextLabel", {
						Name = "Icon",
						BackgroundTransparency = 1,
						Size = UDim2.new(0, 22, 1, 0),
						Text = icon,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextSize = 16,
						TextColor3 = style.textColor,
						Font = Enum.Font.GothamBold,
					}),

					create("TextLabel", {
						[ref] = "mainText",
						AutomaticSize = Enum.AutomaticSize.X,
						BackgroundTransparency = 1,
						Size = UDim2.new(0, 0, 1, 0),
						Text = text,
						RichText = true,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextSize = 13,
						TextColor3 = style.textColor,
						Font = Enum.Font.Gotham,
						TextTruncate = Enum.TextTruncate.AtEnd,

						create("UISizeConstraint", {
							MaxSize = Vector2.new(165, math.huge),
						}),
					}),

					create("TextLabel", {
						[ref] = "sideText",
						BackgroundTransparency = 1,
						AutomaticSize = Enum.AutomaticSize.X,
						Size = UDim2.new(0, 0, 1, 0),
						Text = "",
						TextXAlignment = Enum.TextXAlignment.Left,
						TextSize = 11,
						RichText = true,
						TextColor3 = style.mutedTextColor,
						Font = Enum.Font.Gotham,
					}),
				}),

				create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
				}),

				create("Frame", {
					[ref] = "bar",
					BackgroundColor3 = style.mutedTextColor,
					BorderSizePixel = 0,
					LayoutOrder = 1,
					ZIndex = 2,
				}),

				InputBegan = function(input: InputObject)
					if input.UserInputType == Enum.UserInputType.MouseButton1 then
						setClicked(true)
					elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
						setRightClicked(true)
					end
				end,

				MouseEnter = function()
					setHovered(true)
				end,

				MouseLeave = function()
					setHovered(false)
				end,
			})

			return button
		end)

		Plasma.useEffect(function()
			refs.mainText.Text = text
			refs.button.container.Icon.Text = icon or ""
			refs.button.container.Icon.Visible = icon ~= nil
		end, text, icon)

		refs.button.container.sideText.Visible = sideText ~= nil
		refs.button.container.sideText.Text = if sideText ~= nil then sideText else ""
		refs.button.container.sideText.TextColor3 = if selected then style.textColor else style.mutedTextColor
		refs.mainText.TextTruncate = sideText and Enum.TextTruncate.AtEnd or Enum.TextTruncate.None

		refs.button.bar.Size = UDim2.new(barWidth or 0, 0, 0, 1)

		Plasma.useEffect(function()
			refs.button.BackgroundColor3 = if selected
				then style.primaryColor
				elseif hovered then style.bg1
				else style.bg2

			refs.index.TextColor3 = if selected or hovered then style.textColor else style.mutedTextColor
		end, selected, hovered)

		return {
			clicked = function()
				if clicked then
					setClicked(false)
					return true
				end

				return false
			end,
			rightClicked = function()
				if rightClicked then
					setRightClicked(false)
					return true
				end

				return false
			end,
			hovered = function()
				return hovered
			end,
		}
	end)

	return Plasma.widget(function(items)
		Plasma.useInstance(function()
			local frame = create("Frame", {
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 0, 0),

				create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
					Padding = UDim.new(0, 2),
				}),
			})

			Plasma.automaticSize(frame, {
				axis = Enum.AutomaticSize.Y,
			})

			return frame
		end)

		local selected
		local rightClicked
		local hovered

		for _, item in items do
			local buttonInList = Item(item.text, item.selected, item.icon, item.sideText, item.barWidth, item.index)

			if buttonInList:clicked() then
				selected = item
			end

			if buttonInList:rightClicked() then
				rightClicked = item
			end

			if buttonInList:hovered() then
				hovered = item
			end
		end

		return {
			selected = function()
				return selected
			end,
			rightClicked = function()
				return rightClicked
			end,
			hovered = function()
				return hovered
			end,
		}
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="231">
                    <Properties>
                      <string name="Name">tooltip</string>
                      <string name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")

type Options = {
	tag: string,
	backgroundTransparency: number?,
}

return function(plasma)
	local create = plasma.create

	return plasma.widget(function(text, options: Options)
		local refs = plasma.useInstance(function(ref)
			local style = plasma.useStyle()

			create("TextLabel", {
				[ref] = "label",
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				TextSize = 13,
				RichText = true,
				BorderSizePixel = 0,
				Font = Enum.Font.Code,
				TextStrokeTransparency = 0.5,
				TextColor3 = Color3.new(1, 1, 1),
				BackgroundTransparency = options.backgroundTransparency or 0.2,
				BackgroundColor3 = style.bg1,
				AutomaticSize = Enum.AutomaticSize.XY,
				ZIndex = 100,

				create("UIPadding", {
					PaddingBottom = UDim.new(0, 4),
					PaddingLeft = UDim.new(0, 4),
					PaddingRight = UDim.new(0, 4),
					PaddingTop = UDim.new(0, 4),
				}),

				create("UICorner"),

				create("UIStroke", {
					ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				}),
			})

			CollectionService:AddTag(ref.label, options.tag)

			return ref.label
		end)

		refs.label.Text = text
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="232">
                    <Properties>
                      <string name="Name">valueInspect</string>
                      <string name="Source"><![CDATA[local formatTableModule = require(script.Parent.Parent.formatTable)
local formatTable = formatTableModule.formatTable

return function(plasma)
	return plasma.widget(function(objectStack, custom)
		local closed = plasma
			.window({
				title = "Inspect",
				closable = true,
			}, function()
				plasma.row({ padding = 5 }, function()
					for i, object in objectStack do
						if
							custom
								.link(object.key, {
									icon = object.icon or "{}",
								})
								:clicked()
						then
							local difference = #objectStack - i

							for _ = 1, difference do
								table.remove(objectStack, #objectStack)
							end
						end

						if i < #objectStack then
							custom.link("▶", {
								disabled = true,
							})
						end
					end
				end)

				local items = {}

				for key, value in pairs(objectStack[#objectStack].value) do
					local valueItem

					if type(value) == "table" then
						valueItem = function()
							if
								custom
									.link(formatTable(value), {
										font = Enum.Font.Code,
									})
									:clicked()
							then
								table.insert(objectStack, {
									key = if type(key) == "table" then formatTable(key) else tostring(key),
									value = value,
								})
							end
						end
					else
						valueItem = tostring(value)
					end

					table.insert(items, {
						tostring(key),
						valueItem,
					})
				end

				plasma.useKey(tostring(objectStack[#objectStack].key) .. ":" .. #objectStack)

				if #items == 0 then
					return plasma.label("(empty table)")
				end

				plasma.table(items, {
					font = Enum.Font.Code,
				})
				return nil
			end)
			:closed()

		if closed then
			table.clear(objectStack)
		end
	end)
end
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="233">
                    <Properties>
                      <string name="Name">worldInspect</string>
                      <string name="Source"><![CDATA[local formatTableModule = require(script.Parent.Parent.formatTable)
local formatTable = formatTableModule.formatTable

local BY_COMPONENT_NAME = "ComponentName"
local BY_ENTITY_COUNT = "EntityCount"

return function(plasma)
	return plasma.widget(function(debugger, objectStack)
		local style = plasma.useStyle()

		local world = debugger.debugWorld

		local cache, setCache = plasma.useState()

		local sortType, setSortType = plasma.useState(BY_COMPONENT_NAME)
		local isAscendingOrder, setIsAscendingOrder = plasma.useState(true)

		local skipIntersections, setSkipIntersections = plasma.useState(true)
		local debugComponent, setDebugComponent = plasma.useState()

		local closed = plasma
			.window({
				title = "World inspect",
				closable = true,
			}, function()
				if not cache or os.clock() - cache.createdTime > debugger.componentRefreshFrequency then
					cache = {
						createdTime = os.clock(),
						uniqueComponents = {},
						emptyEntities = 0,
					}

					setCache(cache)

					for _, entityData in world do
						if next(entityData) == nil then
							cache.emptyEntities += 1
						else
							for component in entityData do
								cache.uniqueComponents[component] = (cache.uniqueComponents[component] or 0) + 1
							end
						end
					end
				end

				plasma.row({
					verticalAlignment = Enum.VerticalAlignment.Center,
				}, function()
					plasma.heading("SIZE:")
					plasma.label(
						`{world:size()} {if cache.emptyEntities > 0 then `({cache.emptyEntities} empty)` else ""}`
					)

					if plasma.button("View Raw"):clicked() then
						table.clear(objectStack)
						objectStack[1] = {
							value = world,
							key = "Raw World",
						}
					end
				end)

				plasma.row({ padding = 15 }, function()
					if plasma.checkbox("Show intersections", { checked = not skipIntersections }):clicked() then
						setSkipIntersections(not skipIntersections)
					end
				end)

				local items = {}
				for component, count in cache.uniqueComponents do
					table.insert(items, {
						count,
						tostring(component),
						selected = debugComponent == component,
						component = component,
					})
				end

				local indexForSort = if sortType == BY_ENTITY_COUNT then 1 else 2

				table.sort(items, function(a, b)
					if isAscendingOrder then
						return a[indexForSort] < b[indexForSort]
					end

					return a[indexForSort] > b[indexForSort]
				end)

				local arrow = if isAscendingOrder then "▲" else "▼"
				local countHeading = `{if sortType == BY_ENTITY_COUNT then arrow else ""} Count `
				local componentHeading = `{if sortType == BY_COMPONENT_NAME then arrow else ""} Component`
				local headings = { countHeading, componentHeading }
				table.insert(items, 1, headings)

				plasma.row({ padding = 30 }, function()
					local worldInspectTable = plasma.table(items, {
						width = 200,
						headings = true,
						selectable = true,
						font = Enum.Font.Code,
					})

					local selectedHeading = worldInspectTable:selectedHeading()

					if headings[selectedHeading] == headings[1] then
						if sortType == BY_ENTITY_COUNT then
							setIsAscendingOrder(not isAscendingOrder)
						else
							setSortType(BY_ENTITY_COUNT)
						end
					elseif headings[selectedHeading] == headings[2] then
						if sortType == BY_COMPONENT_NAME then
							setIsAscendingOrder(not isAscendingOrder)
						else
							setSortType(BY_COMPONENT_NAME)
						end
					end

					local selectedRow = worldInspectTable:selected()

					if selectedRow then
						setDebugComponent(selectedRow.component)
					end

					if debugComponent then
						local items = { { "Entity ID", tostring(debugComponent) } }
						local intersectingComponents = {}

						local intersectingData = {}

						for entityId, data in world:query(debugComponent) do
							table.insert(items, {
								entityId,
								formatTable(data),

								selected = debugger.debugEntity == entityId,
							})

							intersectingData[entityId] = {}

							if skipIntersections then
								continue
							end

							for component, value in world:_getEntity(entityId) do
								if component == debugComponent then
									continue
								end

								local index = table.find(intersectingComponents, component)

								if not index then
									table.insert(intersectingComponents, component)

									index = #intersectingComponents
								end

								intersectingData[entityId][index] = value
							end
						end

						for i, item in items do
							if i == 1 then
								for _, component in intersectingComponents do
									table.insert(item, tostring(component))
								end

								continue
							end

							for i = 1, #intersectingComponents do
								local data = intersectingData[item[1]][i]

								table.insert(item, if data then formatTable(data) else "")
							end
						end

						plasma.useKey(tostring(debugComponent))

						local tableWidget = plasma.table(items, {
							font = Enum.Font.Code,
							selectable = true,
							headings = true,
						})

						local selectedRow = tableWidget:selected()
						local hovered = tableWidget:hovered()

						if selectedRow then
							debugger.debugEntity = selectedRow[1]
						end

						if hovered then
							local entityId = hovered[1]

							if debugger.debugEntity == entityId or not world:contains(entityId) then
								return
							end

							if debugger.findInstanceFromEntity then
								local model = debugger.findInstanceFromEntity(entityId)

								if model then
									plasma.highlight(model, {
										fillColor = style.primaryColor,
									})
								end
							end
						end
					end
				end)
			end)
			:closed()

		if closed then
			return closed
		end
		return nil
	end)
end
]]></string>
                    </Properties>
                  </Item>
                </Item>
              </Item>
              <Item class="Folder" referent="234">
                <Properties>
                  <string name="Name">hooks</string>
                </Properties>
                <Item class="ModuleScript" referent="235">
                  <Properties>
                    <string name="Name">log</string>
                    <string name="Source"><![CDATA[local topoRuntime = require(script.Parent.Parent.topoRuntime)
local format = require(script.Parent.Parent.debugger.formatTable)

--[=[
	@within Matter

	:::info Topologically-aware function
	This function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).
	:::

	@param ... any

	Logs some text. Readable in the Matter debugger.
]=]
local function log(...)
	local state = topoRuntime.useFrameState()

	if state.logs == nil then
		return
	end

	local segments = {}

	for i = 1, select("#", ...) do
		local value = select(i, ...)

		if type(value) == "table" then
			segments[i] = format.formatTable(value)
		else
			segments[i] = tostring(value)
		end
	end

	table.insert(state.logs, table.concat(segments, " "))

	if #state.logs > 100 then
		table.remove(state.logs, 1)
	end
end

return log
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="236">
                  <Properties>
                    <string name="Name">useDeltaTime</string>
                    <string name="Source"><![CDATA[local topoRuntime = require(script.Parent.Parent.topoRuntime)

--[=[
	@within Matter

	:::info Topologically-aware function
	This function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).
	:::

	Returns the `os.clock()` time delta between the start of this and last frame.
]=]
local function useDeltaTime(): number
	local state = topoRuntime.useFrameState()

	return state.deltaTime
end

return useDeltaTime
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="237">
                  <Properties>
                    <string name="Name">useEvent</string>
                    <string name="Source"><![CDATA[local topoRuntime = require(script.Parent.Parent.topoRuntime)
local Queue = require(script.Parent.Parent.Queue)

local EVENT_CONNECT_METHODS = { "Connect", "on", "connect" }
local CONNECTION_DISCONNECT_METHODS = { "Disconnect", "Destroy", "disconnect", "destroy" }

local function connect(object, callback, event)
	local eventObject = object

	if typeof(event) == "RBXScriptSignal" or type(event) == "table" then
		eventObject = event
	elseif type(event) == "string" then
		eventObject = object[event]
	end

	if type(eventObject) == "function" then
		return eventObject(object)
	elseif typeof(eventObject) == "RBXScriptSignal" then
		return eventObject:Connect(callback)
	end

	if type(eventObject) == "table" then
		for _, method in EVENT_CONNECT_METHODS do
			if type(eventObject[method]) ~= "function" then
				continue
			end

			return eventObject[method](eventObject, callback)
		end
	end

	error(
		"Couldn't connect to event as no valid connect methods were found! Ensure the passed event has a 'Connect' or an 'on' method!"
	)
end

local function disconnect(connection)
	if connection == nil then
		return
	end

	if type(connection) == "function" then
		connection()
		return
	end

	for _, method in CONNECTION_DISCONNECT_METHODS do
		if type(connection[method]) ~= "function" then
			continue
		end

		connection[method](connection)
		break
	end
end

local function validateConnection(connection)
	if typeof(connection) == "function" or typeof(connection) == "RBXScriptConnection" then
		return
	end

	for _, method in CONNECTION_DISCONNECT_METHODS do
		if type(connection) ~= "table" or connection[method] == nil then
			continue
		end

		return
	end

	error("Ensure passed event returns a cleanup function, or a table with a 'Disconnect' or a 'Destroy' method!")
end

local function cleanup(storage)
	disconnect(storage.connection)
	storage.queue = nil
end

--[=[
	@type ConnectionObject {Disconnect: (() -> ())?, Destroy: (() - >())?, disconnect: (() -> ())?, destroy: (() -> ())?} | () -> ()
	@within Matter

	A connection object returned by a custom event must be either a table with any of the following methods, or a cleanup function.
]=]

--[=[
	@interface CustomEvent
	@within Matter
	.Connect ((...) -> ConnectionObject)?
	.on ((...) -> ConnectionObject)?
	.connect ((...) -> ConnectionObject)?

	A custom event must have any of these 3 methods.
]=]

--[=[
	@within Matter
	:::info Topologically-aware function
	This function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).
	:::

	Collects events that fire during the frame and allows iteration over event arguments.

	```lua
	for _, player in ipairs(Players:GetPlayers()) do
		for i, character in useEvent(player, "CharacterAdded") do
			world:spawn(
				Components.Target(),
				Components.Model({
					model = character,
				})
			)
		end
	end
	```

	Returns an iterator function that returns an ever-increasing number, starting at 1, followed by any event arguments
	from the specified event.

	Events are returned in the order that they were fired.

	:::caution
	`useEvent` keys storage uniquely identified by **the script and line number** `useEvent` was called from, and the
	first parameter (instance). If the second parameter, `event`, is not equal to the event passed in for this unique
	storage last frame, the old event is disconnected from and the new one is connected in its place.

	Tl;dr: on a given line, you should hard-code a single event to connect to. Do not dynamically change the event with
	a variable. Dynamically changing the first parameter (instance) is fine.

	```lua
	for _, instance in pairs(someTable) do
		for i, arg1, arg2 in useEvent(instance, "Touched") do -- This is ok
		end
	end

	for _, instance in pairs(someTable) do
		local event = getEventSomehow()
		for i, arg1, arg2 in useEvent(instance, event) do -- PANIC! This is NOT OK
		end
	end
	```
	:::

	If `useEvent` ceases to be called on the same line with the same instance and event, the event connection is
	disconnected from automatically.

	You can also pass the actual event object instead of its name as the second parameter:

	```lua
	useEvent(instance, instance.Touched)
	useEvent(instance, instance:GetPropertyChangedSignal("Name"))
	```

	`useEvent` supports custom events as well, so you can pass in an object with a `Connect`, `connect` or an `on` method.
	The object returned by any event must either be a cleanup function, or a table with a `Disconnect` or a `Destroy`
	method so that `useEvent` can later clean the event up when needed.	See [ConnectionObject] for more information.

	@param instance Instance | { [string]: CustomEvent } | CustomEvent -- The instance or the custom event, or a table that has the event you want to connect to
	@param event string | RBXScriptSignal | CustomEvent -- The name of, or the actual event that you want to connect to
]=]
local function useEvent(instance, event): () -> (number, ...any)
	assert(instance ~= nil, "Instance is nil")
	assert(event ~= nil, "Event is nil")

	local storage = topoRuntime.useHookState(instance, cleanup)

	if storage.event ~= event then
		if storage.event then
			disconnect(storage.connection)
			warn("useEvent event changed:", storage.event, "->", event)
			table.clear(storage)
		end

		local queue = Queue.new()
		storage.queue = queue
		storage.event = event

		local connection = connect(instance, function(...)
			queue:pushBack(table.pack(...))
		end, event)

		validateConnection(connection)
		storage.connection = connection
	end

	local index = 0
	return function(): any
		index += 1

		local arguments = storage.queue:popFront()

		if arguments then
			return index, unpack(arguments, 1, arguments.n)
		end
		return
	end
end

return useEvent
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="238">
                  <Properties>
                    <string name="Name">useEvent.spec</string>
                    <string name="Source"><![CDATA[local BindableEvent = require(script.Parent.Parent.mock.BindableEvent)
local topoRuntime = require(script.Parent.Parent.topoRuntime)
local useEvent = require(script.Parent.useEvent)

return function()
	describe("useEvent", function()
		it("should queue up events until useEvent is called again", function()
			local node = {
				system = {},
			}

			local event = BindableEvent.new()

			local a, b, c
			local shouldCall = true
			local shouldCount = 0
			local fn = function()
				if shouldCall then
					local count = 0
					for index, fa, fb, fc in useEvent(event, event.Event) do
						expect(index).to.equal(count + 1)
						count += 1
						a = fa
						b = fb
						c = fc
					end
					expect(count).to.equal(shouldCount)
				end
			end

			topoRuntime.start(node, fn)

			event:Fire(3, 4, 5)

			shouldCount = 1
			topoRuntime.start(node, fn)

			expect(a).to.equal(3)
			expect(b).to.equal(4)
			expect(c).to.equal(5)

			shouldCount = 3

			event:Fire()
			event:Fire()
			event:Fire()

			topoRuntime.start(node, fn)

			shouldCount = 0

			topoRuntime.start(node, fn)

			event:Fire()
			event:Fire()

			shouldCall = false

			topoRuntime.start(node, fn)

			shouldCall = true

			-- Count should still be 0 as last frame didn't call useEvent
			topoRuntime.start(node, fn)
		end)

		it("should cleanup if the event changes", function()
			local node = {
				system = {},
			}

			local event1 = BindableEvent.new()
			local event2 = BindableEvent.new()

			local event = event1
			local shouldCount = 0
			local fn = function()
				local count = 0
				for _ in useEvent(event, "Event") do
					count += 1
				end
				expect(count).to.equal(shouldCount)
			end

			topoRuntime.start(node, fn)

			event1:Fire()
			event1:Fire()

			shouldCount = 2
			topoRuntime.start(node, fn)

			event1:Fire()
			event1:Fire()
			event = event2

			shouldCount = 0
			topoRuntime.start(node, fn)

			event2:Fire()

			shouldCount = 1
			topoRuntime.start(node, fn)
		end)

		it("should support custom events", function()
			local disconnected = false
			local eventHandler

			local node = {
				system = {},
			}

			local event = {
				connect = function(_, handler)
					eventHandler = handler

					return {
						destroy = function()
							disconnected = true
						end,
					}
				end,
			}

			local object = {
				event = event,
			}

			local shouldRun = true
			local count = 0
			local function run()
				if shouldRun then
					for _ in useEvent(object, "event") do
						count += 1
					end
				end
			end

			topoRuntime.start(node, run)

			expect(count).to.equal(0)
			expect(eventHandler).to.be.ok()
			expect(disconnected).to.equal(false)

			eventHandler()
			eventHandler()

			topoRuntime.start(node, run)

			expect(count).to.equal(2)
			expect(eventHandler).to.be.ok()
			expect(disconnected).to.equal(false)

			shouldRun = false
			topoRuntime.start(node, run)

			expect(count).to.equal(2)
			expect(disconnected).to.equal(true)
		end)
	end)
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="239">
                  <Properties>
                    <string name="Name">useThrottle</string>
                    <string name="Source"><![CDATA[local topoRuntime = require(script.Parent.Parent.topoRuntime)

local function cleanup(storage)
	return os.clock() < storage.expiry
end

--[=[
	@within Matter

	:::info Topologically-aware function
	This function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).
	:::

	Utility for easy time-based throttling.

	Accepts a duration, and returns `true` if it has been that long since the last time this function returned `true`.
	Always returns `true` the first time.

	This function returns unique results keyed by script and line number. Additionally, uniqueness can be keyed by a
	unique value, which is passed as a second parameter. This is useful when iterating over a query result, as you can
	throttle doing something to each entity individually.

	```lua
	if useThrottle(1) then -- Keyed by script and line number only
		print("only prints every second")
	end

	for id, enemy in world:query(Enemy) do
		if useThrottle(5, id) then -- Keyed by script, line number, and the entity id
			print("Recalculate target...")
		end
	end
	```

	@param seconds number -- The number of seconds to throttle for
	@param discriminator? any -- A unique value to additionally key by
	@return boolean -- returns true every x seconds, otherwise false
]=]
local function useThrottle(seconds, discriminator)
	local storage = topoRuntime.useHookState(discriminator, cleanup)

	if storage.time == nil or os.clock() - storage.time >= seconds then
		storage.time = os.clock()
		storage.expiry = os.clock() + seconds
		return true
	end

	return false
end

return useThrottle
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="240">
                <Properties>
                  <string name="Name">immutable</string>
                  <string name="Source"><![CDATA[local None = {}

local function merge(one, two)
	local new = table.clone(one)

	for key, value in two do
		if value == None then
			new[key] = nil
		else
			new[key] = value
		end
	end

	return new
end

-- https://github.com/freddylist/llama/blob/master/src/List/toSet.luau
local function toSet(list)
	local set = {}

	for _, v in ipairs(list) do
		set[v] = true
	end

	return set
end

-- https://github.com/freddylist/llama/blob/master/src/Dictionary/values.luau
local function values(dictionary)
	local valuesList = {}

	local index = 1

	for _, value in pairs(dictionary) do
		valuesList[index] = value
		index = index + 1
	end

	return valuesList
end

return {
	None = None,
	merge = merge,
	toSet = toSet,
	values = values,
}
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="241">
                <Properties>
                  <string name="Name">mock</string>
                </Properties>
                <Item class="ModuleScript" referent="242">
                  <Properties>
                    <string name="Name">BindableEvent</string>
                    <string name="Source"><![CDATA[local BindableEvent = {}
BindableEvent.__index = BindableEvent

function BindableEvent.new()
	local self = setmetatable({
		_listeners = {},
		_locked = false,
	}, BindableEvent)

	self.Event = self

	return self
end

function BindableEvent:Connect(listener)
	table.insert(self._listeners, listener)

	return {
		Disconnect = function()
			local index = table.find(self._listeners, listener)

			if index then
				table.remove(self._listeners, index)
			end
		end,
	}
end

function BindableEvent:Fire(...)
	if self._locked then
		error("Cannot fire while firing")
	end

	self._locked = true
	for _, listener in self._listeners do
		local ok, errors = pcall(listener, ...)

		if not ok then
			warn(errors)
		end
	end
	self._locked = false
end

return BindableEvent
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="243">
                <Properties>
                  <string name="Name">rollingAverage</string>
                  <string name="Source"><![CDATA[local MAX_SAMPLES = 60

local function addSample(samples, value)
	samples[samples.index or 1] = value
	samples.index = if samples.index then (samples.index % MAX_SAMPLES) + 1 else 1
end

local function getAverage(samples)
	local sum = 0

	for i = 1, #samples do
		sum += samples[i]
	end

	return sum / #samples
end

return {
	addSample = addSample,
	getAverage = getAverage,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="244">
                <Properties>
                  <string name="Name">topoRuntime</string>
                  <string name="Source"><![CDATA[local stack = {}

local function newStackFrame(node)
	return {
		node = node,
		accessedKeys = {},
	}
end

local function cleanup()
	local currentFrame = stack[#stack]

	for baseKey, state in pairs(currentFrame.node.system) do
		for key, value in pairs(state.storage) do
			if not currentFrame.accessedKeys[baseKey] or not currentFrame.accessedKeys[baseKey][key] then
				local cleanupCallback = state.cleanupCallback

				if cleanupCallback then
					local shouldAbortCleanup = cleanupCallback(value)

					if shouldAbortCleanup then
						continue
					end
				end

				state.storage[key] = nil
			end
		end
	end
end

local function start(node, fn)
	table.insert(stack, newStackFrame(node))
	fn()
	cleanup()
	table.remove(stack, #stack)
end

local function withinTopoContext()
	return #stack ~= 0
end

local function useFrameState()
	return stack[#stack].node.frame
end

local function useCurrentSystem()
	if #stack == 0 then
		return
	end

	return stack[#stack].node.currentSystem
end

--[=[
	@within Matter

	:::tip
	**Don't use this function directly in your systems.**

	This function is used for implementing your own topologically-aware functions. It should not be used in your
	systems directly. You should use this function to implement your own utilities, similar to `useEvent` and
	`useThrottle`.
	:::

	`useHookState` does one thing: it returns a table. An empty, pristine table. Here's the cool thing though:
	it always returns the *same* table, based on the script and line where *your function* (the function calling
	`useHookState`) was called.

	### Uniqueness

	If your function is called multiple times from the same line, perhaps within a loop, the default behavior of
	`useHookState` is to uniquely identify these by call count, and will return a unique table for each call.

	However, you can override this behavior: you can choose to key by any other value. This means that in addition to
	script and line number, the storage will also only return the same table if the unique value (otherwise known as the
	"discriminator") is the same.

	### Cleaning up
	As a second optional parameter, you can pass a function that is automatically invoked when your storage is about
	to be cleaned up. This happens when your function (and by extension, `useHookState`) ceases to be called again
	next frame (keyed by script, line number, and discriminator).

	Your cleanup callback is passed the storage table that's about to be cleaned up. You can then perform cleanup work,
	like disconnecting events.

	*Or*, you could return `true`, and abort cleaning up altogether. If you abort cleanup, your storage will stick
	around another frame (even if your function wasn't called again). This can be used when you know that the user will
	(or might) eventually call your function again, even if they didn't this frame. (For example, caching a value for
	a number of seconds).

	If cleanup is aborted, your cleanup function will continue to be called every frame, until you don't abort cleanup,
	or the user actually calls your function again.

	### Example: useThrottle

	This is the entire implementation of the built-in `useThrottle` function:

	```lua
	local function cleanup(storage)
		return os.clock() < storage.expiry
	end

	local function useThrottle(seconds, discriminator)
		local storage = useHookState(discriminator, cleanup)

		if storage.time == nil or os.clock() - storage.time >= seconds then
			storage.time = os.clock()
			storage.expiry = os.clock() + seconds
			return true
		end

		return false
	end
	```

	A lot of talk for something so simple, right?

	@param discriminator? any -- A unique value to additionally key by
	@param cleanupCallback (storage: {}) -> boolean? -- A function to run when the storage for this hook is cleaned up
]=]
local function useHookState(discriminator, cleanupCallback): {}
	local file, line = debug.info(3, "sl")
	local fn = debug.info(2, "f")

	local baseKey = string.format("%s:%s:%d", tostring(fn), file, line)

	local currentFrame = stack[#stack]

	if currentFrame == nil then
		error("Attempt to access topologically-aware storage outside of a Loop-system context.", 3)
	end

	if not currentFrame.accessedKeys[baseKey] then
		currentFrame.accessedKeys[baseKey] = {}
	end

	local accessedKeys = currentFrame.accessedKeys[baseKey]

	local key = #accessedKeys

	if discriminator ~= nil then
		if type(discriminator) == "number" then
			discriminator = tostring(discriminator)
		end

		key = discriminator
	end

	accessedKeys[key] = true

	if not currentFrame.node.system[baseKey] then
		currentFrame.node.system[baseKey] = {
			storage = {},
			cleanupCallback = cleanupCallback,
		}
	end

	local storage = currentFrame.node.system[baseKey].storage

	if not storage[key] then
		storage[key] = {}
	end

	return storage[key]
end

return {
	start = start,
	useHookState = useHookState,
	useFrameState = useFrameState,
	useCurrentSystem = useCurrentSystem,
	withinTopoContext = withinTopoContext,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="245">
                <Properties>
                  <string name="Name">topoRuntime.spec</string>
                  <string name="Source"><![CDATA[local topoRuntime = require(script.Parent.topoRuntime)

return function()
	describe("TopoRuntime", function()
		it("should restore state", function()
			local function useHook()
				local storage = topoRuntime.useHookState()

				storage.counter = (storage.counter or 0) + 1

				return storage.counter
			end

			local node = {
				system = {},
			}

			local ranCount = 0
			local function fn()
				ranCount += 1
				expect(useHook()).to.equal(ranCount)
			end

			topoRuntime.start(node, fn)

			topoRuntime.start(node, fn)

			expect(ranCount).to.equal(2)
		end)

		it("should cleanup", function()
			local shouldCleanup = false
			local cleanedUpCount = 0
			local function useHook()
				local storage = topoRuntime.useHookState(nil, function()
					if shouldCleanup then
						cleanedUpCount += 1
					else
						return true
					end
				end)

				storage.counter = (storage.counter or 0) + 1

				return storage.counter
			end

			local node = {
				system = {},
			}

			local shouldRunHook = true
			local function fn()
				if shouldRunHook then
					expect(useHook()).to.equal(1)
				end
			end

			topoRuntime.start(node, fn)

			expect(cleanedUpCount).to.equal(0)

			shouldRunHook = false

			topoRuntime.start(node, fn)

			expect(cleanedUpCount).to.equal(0)

			shouldCleanup = true

			topoRuntime.start(node, fn)

			expect(cleanedUpCount).to.equal(1)

			shouldRunHook = true

			topoRuntime.start(node, fn)

			expect(cleanedUpCount).to.equal(1)
		end)

		it("should allow keying by unique values", function()
			local function useHook(unique)
				local storage = topoRuntime.useHookState(unique)

				storage.counter = (storage.counter or 0) + 1

				return storage.counter
			end

			local node = {
				system = {},
			}

			local ranCount = 0
			local function fn()
				ranCount += 1
				expect(useHook("a value")).to.equal(ranCount)
			end

			topoRuntime.start(node, fn)

			topoRuntime.start(node, fn)

			expect(ranCount).to.equal(2)

			topoRuntime.start(node, function()
				fn()
				fn()
			end)

			expect(ranCount).to.equal(4)
		end)
	end)
end
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="246">
            <Properties>
              <string name="Name">net</string>
            </Properties>
            <Item class="ModuleScript" referent="247">
              <Properties>
                <string name="Name">out</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local NetServerContext = TS.import(script, script, "server")
local NetClientContext = TS.import(script, script, "client")
local NetDefinitions = TS.import(script, script, "definitions").default
local NetMiddleware = TS.import(script, script, "middleware").NetMiddleware
--[[
	*
	* Networking Library for Roblox
	* @version 3.0
]]
local Net = {}
do
	local _container = Net
	--[[
		*
		* Legacy client API for Net
		* @deprecated
	]]
	local Client = NetClientContext
	_container.Client = Client
	--[[
		*
		* Legacy server API for Net
		* @deprecated
	]]
	local Server = NetServerContext
	_container.Server = Server
	--[[
		*
		* The definitions API for Net
	]]
	local Definitions = NetDefinitions
	_container.Definitions = Definitions
	--[[
		*
		* Utility types for Net
	]]
	local DIST = "TS"
	_container.DIST = DIST
	--[[
		*
		* The version of RbxNet
	]]
	local VERSION = if "production" == "production" then "3.0.10" else "DEV " .. (DIST .. (")} " .. "3.0.10"))
	_container.VERSION = VERSION
	--[[
		*
		* Built-in middlewares
	]]
	local Middleware = NetMiddleware
	_container.Middleware = Middleware
	--[[
		*
		* Middleware function type for Net
	]]
	--[[
		*
		* Short-hand for `Net.Definitions.Create`
		* @see {@link Definitions.Create}
	]]
	local function CreateDefinitions(declarations, configuration)
		return Definitions.Create(declarations, configuration)
	end
	_container.CreateDefinitions = CreateDefinitions
end
local _ = nil
local _1 = nil
return Net
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="248">
                <Properties>
                  <string name="Name">client</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local AsyncFunction = TS.import(script, script, "ClientAsyncFunction").default
local Event = TS.import(script, script, "ClientEvent").default
local Function = TS.import(script, script, "ClientFunction").default
return {
	Event = Event,
	AsyncFunction = AsyncFunction,
	Function = Function,
}
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="249">
                  <Properties>
                    <string name="Name">ClientAsyncFunction</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local getRemoteOrThrow = _internal.getRemoteOrThrow
local IS_SERVER = _internal.IS_SERVER
local waitForRemote = _internal.waitForRemote
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")
--[[
	*
	* An event that behaves like a function
	* @rbxts client
]]
local ClientAsyncFunction
do
	ClientAsyncFunction = setmetatable({}, {
		__tostring = function()
			return "ClientAsyncFunction"
		end,
	})
	ClientAsyncFunction.__index = ClientAsyncFunction
	function ClientAsyncFunction.new(...)
		local self = setmetatable({}, ClientAsyncFunction)
		return self:constructor(...) or self
	end
	function ClientAsyncFunction:constructor(name, configuration)
		self.name = name
		self.configuration = configuration
		self.timeout = 60
		self.listeners = {}
		self.instance = getRemoteOrThrow("AsyncRemoteFunction", name)
		local _arg0 = not IS_SERVER
		assert(_arg0, "Cannot create a Net.ClientAsyncFunction on the Server!")
	end
	function ClientAsyncFunction:Wait(name, configuration)
		return TS.Promise.defer(TS.async(function(resolve)
			TS.await(waitForRemote("AsyncRemoteFunction", name, 60))
			resolve(ClientAsyncFunction.new(name, configuration))
		end))
	end
	function ClientAsyncFunction:SetCallTimeout(timeout)
		local _arg0 = timeout > 0
		assert(_arg0, "timeout must be a positive number")
		self.timeout = timeout
	end
	function ClientAsyncFunction:GetCallTimeout()
		return self.timeout
	end
	function ClientAsyncFunction:SetCallback(callback)
		if self.connector then
			self.connector:Disconnect()
			self.connector = nil
		end
		local remoteId = self.instance.Name
		local microprofile = self.configuration.MicroprofileCallbacks
		self.connector = self.instance.OnClientEvent:Connect(TS.async(function(...)
			local args = { ... }
			if microprofile then
				debug.profilebegin("Net: " .. remoteId)
			end
			local _binding = args
			local eventId = _binding[1]
			local data = _binding[2]
			if type(eventId) == "string" and type(data) == "table" then
				local result = callback(unpack(data))
				if TS.Promise.is(result) then
					local _arg0 = function(promiseResult)
						self.instance:FireServer(eventId, promiseResult)
					end
					result:andThen(_arg0):catch(function(err)
						warn("[rbx-net] Failed to send response to server: " .. err)
					end)
				else
					self.instance:FireServer(eventId, result)
				end
			else
				warn("Recieved message without eventId")
			end
		end))
	end
	ClientAsyncFunction.CallServerAsync = TS.async(function(self, ...)
		local args = { ... }
		if CollectionService:HasTag(self.instance, "NetDefaultListener") then
			error("Attempted to call AsyncFunction '" .. (self.name .. "' - which has no user defined callback"))
		end
		local id = HttpService:GenerateGUID(false)
		local _fn = self.instance
		local _object = {}
		for _k, _v in pairs(args) do
			_object[_k] = _v
		end
		_fn:FireServer(id, _object)
		return TS.Promise.new(function(resolve, reject)
			local startTime = tick()
			local connection
			connection = self.instance.OnClientEvent:Connect(function(...)
				local recvArgs = { ... }
				local _binding = recvArgs
				local eventId = _binding[1]
				local data = _binding[2]
				if type(eventId) == "string" then
					if eventId == id then
						connection:Disconnect()
						resolve(data)
					end
				end
			end)
			local _listeners = self.listeners
			local _arg1 = {
				connection = connection,
				timeout = self.timeout,
			}
			_listeners[id] = _arg1
			local warned = false
			local elapsedTime = 0
			repeat
				do
					elapsedTime += (RunService.Heartbeat:Wait())
					if elapsedTime >= 20 and not warned then
						warned = true
						warn("[rbx-net] CallServerAsync(...) - still waiting for result from remote '" .. (self.name .. "'"))
						print(debug.traceback("", 3))
					end
				end
			until not (connection.Connected and tick() < startTime + self.timeout)
			self.listeners[id] = nil
			if tick() >= startTime and connection.Connected then
				connection:Disconnect()
				reject("Request to server timed out after " .. tostring(self.timeout) .. " seconds")
			end
		end)
	end)
end
return {
	default = ClientAsyncFunction,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="250">
                  <Properties>
                    <string name="Name">ClientEvent</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local getRemoteOrThrow = _internal.getRemoteOrThrow
local IS_SERVER = _internal.IS_SERVER
local waitForRemote = _internal.waitForRemote
--[[
	*
	* Interface for client listening events
]]
--[[
	*
	* Interface for client sender events
]]
local ClientEvent
do
	ClientEvent = setmetatable({}, {
		__tostring = function()
			return "ClientEvent"
		end,
	})
	ClientEvent.__index = ClientEvent
	function ClientEvent.new(...)
		local self = setmetatable({}, ClientEvent)
		return self:constructor(...) or self
	end
	function ClientEvent:constructor(name, configuration)
		self.configuration = configuration
		self.instance = getRemoteOrThrow("RemoteEvent", name)
		local _arg0 = not IS_SERVER
		assert(_arg0, "Cannot fetch NetClientEvent on the server!")
	end
	function ClientEvent:GetInstance()
		return self.instance
	end
	function ClientEvent:Wait(name, configuration)
		return TS.Promise.defer(TS.async(function(resolve)
			TS.await(waitForRemote("RemoteEvent", name, 60))
			resolve(ClientEvent.new(name, configuration))
		end))
	end
	function ClientEvent:SendToServer(...)
		local args = { ... }
		self.instance:FireServer(unpack(args))
	end
	function ClientEvent:Connect(callback)
		local remoteId = self.instance.Name
		local microprofile = self.configuration.MicroprofileCallbacks
		if microprofile then
			return self.instance.OnClientEvent:Connect(function(...)
				local args = { ... }
				debug.profilebegin("Net: " .. remoteId)
				callback(unpack(args))
			end)
		else
			return self.instance.OnClientEvent:Connect(callback)
		end
	end
end
local default = ClientEvent
return {
	default = default,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="251">
                  <Properties>
                    <string name="Name">ClientFunction</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local getRemoteOrThrow = _internal.getRemoteOrThrow
local IS_SERVER = _internal.IS_SERVER
local waitForRemote = _internal.waitForRemote
local CollectionService = game:GetService("CollectionService")
local ClientFunction
do
	ClientFunction = setmetatable({}, {
		__tostring = function()
			return "ClientFunction"
		end,
	})
	ClientFunction.__index = ClientFunction
	function ClientFunction.new(...)
		local self = setmetatable({}, ClientFunction)
		return self:constructor(...) or self
	end
	function ClientFunction:constructor(name, configuration)
		self.name = name
		self.configuration = configuration
		self.instance = getRemoteOrThrow("RemoteFunction", name)
		local _arg0 = not IS_SERVER
		assert(_arg0, "Cannot create a Net.ClientFunction on the Server!")
	end
	function ClientFunction:Wait(name, configuration)
		return TS.Promise.defer(TS.async(function(resolve)
			TS.await(waitForRemote("RemoteFunction", name, 60))
			resolve(ClientFunction.new(name, configuration))
		end))
	end
	function ClientFunction:CallServer(...)
		local args = { ... }
		if CollectionService:HasTag(self.instance, "NetDefaultListener") then
			error("Attempted to call Function '" .. (self.name .. "' - which has no user defined callback"))
		end
		return self.instance:InvokeServer(unpack(args))
	end
	ClientFunction.CallServerAsync = TS.async(function(self, ...)
		local args = { ... }
		return TS.Promise.defer(function(resolve)
			local result = self.instance:InvokeServer(unpack(args))
			resolve(result)
		end)
	end)
end
return {
	default = ClientFunction,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="252">
                <Properties>
                  <string name="Name">definitions</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
-- eslint-disable @typescript-eslint/no-explicit-any
local DeclarationTypeCheck = TS.import(script, script, "Types").DeclarationTypeCheck
local ServerDefinitionBuilder = TS.import(script, script, "ServerDefinitionBuilder").ServerDefinitionBuilder
local ClientDefinitionBuilder = TS.import(script, script, "ClientDefinitionBuilder").ClientDefinitionBuilder
local NamespaceBuilder = TS.import(script, script, "NamespaceBuilder").NamespaceBuilder
local NetDefinitions = {}
do
	local _container = NetDefinitions
	--[[
		*
		* Validates the specified declarations to ensure they're valid before usage
		* @param declarations The declarations
	]]
	local function validateDeclarations(declarations)
		for _, declaration in pairs(declarations) do
			local _arg0 = DeclarationTypeCheck.check(declaration.Type)
			local _errorMessage = DeclarationTypeCheck.errorMessage
			assert(_arg0, _errorMessage)
		end
	end
	--[[
		*
		* Creates definitions for Remote instances that can be used on both the client and server.
		* @description https://docs.vorlias.com/rbx-net/docs/3.0/definitions#definitions-oh-my
		* @param declarations
	]]
	local function Create(declarations, configuration)
		if configuration == nil then
			configuration = {}
		end
		validateDeclarations(declarations)
		local _arg0 = {
			Server = ServerDefinitionBuilder.new(declarations, configuration),
			Client = ClientDefinitionBuilder.new(declarations, configuration),
		}
		return _arg0
	end
	_container.Create = Create
	--[[
		*
		* Defines a namespace of remote definitions, which can be retrieved via `GetNamespace(namespaceId)`
		*
		* E.g.
		* ```ts
		* const Remotes = Net.Definitions.Create({
		* 		ExampleGroup: Net.Definitions.Namespace({
		* 			ExampleGroupRemote: Net.Definitions.ServerToClientEvent<[message: string]>(),
		* 		}),
		* });
		* const ExampleGroupRemote = Remotes.Server.GetNamespace("ExampleGroup").Create("ExampleGroupRemote");
		* ```
		*
		* This is useful for categorizing remotes by feature.
	]]
	local function Namespace(declarations, configuration)
		return {
			Type = "Namespace",
			Definitions = NamespaceBuilder.new(declarations, configuration),
		}
	end
	_container.Namespace = Namespace
	--[[
		*
		* Defines a function in which strictly the client can call the server asynchronously
		*
		* `Client` [`Calls`] -> `Server` [`Recieves Call`]
		* ... (asynchronously) ...
		* `Server` [`Responds to Call`] -> `Client` [`Recieves Response`]
	]]
	local function ServerAsyncFunction(mw)
		return {
			Type = "AsyncFunction",
			ServerMiddleware = mw,
		}
	end
	_container.ServerAsyncFunction = ServerAsyncFunction
	--[[
		*
		* @version 3.0
		*
		* **_Note_: This uses {@link MessagingService}, and thus is subject to those quotas/limits.**
		*
		* **_Note_: Unlike other definitions in Net, this is only available on the server.**
		*
		* Defines an event in which allows broadcasting messages between servers in the experience.
		*
		* `Source Server` [`Broadcasts`] -> `Other Servers` [`Recieves Broadcast`]
		*
		* or at a target {@link DataModel.JobId JobId}
		*
		* `Source Server [`Broadcasts`] -> `Target Server` [`Recieves Broadcast`]
		*
	]]
	local function ExperienceBroadcastEvent()
		return {
			Type = "Messaging",
		}
	end
	_container.ExperienceBroadcastEvent = ExperienceBroadcastEvent
	--[[
		*
		* @version 3.0
		*
		* **_Note_: This uses {@link MessagingService}, and thus is subject to those quotas/limits.**
		*
		* Defines an event that allows a server to broadcast to all or specified _clients_ in the experience.
		*
		* `Source Server` [`Broadcasts`] -> `Other Servers` [`Recieves Broadcast`] -> `Client` [`Recieves Forwarded Broadcast`]
		*
		* @hidden Experimental API
		* @deprecated Not yet official API, could be changed or removed.
		* @internal
	]]
	local function EXPERIMENTAL_ExperienceReplicatedEvent()
		return {
			Type = "ExperienceEvent",
		}
	end
	_container.EXPERIMENTAL_ExperienceReplicatedEvent = EXPERIMENTAL_ExperienceReplicatedEvent
	--[[
		*
		* Defines a function in which strictly the server can call the client asynchronously
		*
		* `Server` [`Calls`] -> `Client` [`Recieves Call`]
		* ... (asynchronously) ...
		* `Client` [`Responds to Call`] -> `Server` [`Recieves Response`]
	]]
	local function ClientAsyncFunction()
		return {
			Type = "AsyncFunction",
		}
	end
	_container.ClientAsyncFunction = ClientAsyncFunction
	--[[
		*
		* Defines a regular function in which strictly the client can call the server synchronously
		*
		* (Synchronous) `Client` [`Calls`, `Recieves Response`] <- (yields for response) -> `Server` [`Recieves Call`, `Responds`]
	]]
	local function ServerFunction(mw)
		return {
			Type = "Function",
			ServerMiddleware = mw,
		}
	end
	_container.ServerFunction = ServerFunction
	--[[
		*
		* Defines an event in which strictly the server fires an event that is recieved by clients
		*
		* `Server` [`Sends`] => `Client(s)` [`Recieves`]
		*
		* On the client, this will give an event that can use `Connect`.
		*
		* On the server, this will give an event that can use `SendToPlayer`, `SendToAllPlayers`, `SendToAllPlayersExcept`
		*
	]]
	local function ServerToClientEvent()
		return {
			ServerMiddleware = {},
			Type = "Event",
		}
	end
	_container.ServerToClientEvent = ServerToClientEvent
	--[[
		*
		* Defines an event in which strictly clients fire an event that's recieved by the server
		*
		* `Client(s)` [`Sends`] => `Server` [`Recieves`]
		*
		* On the client, this will give an event that can use `SendToServer`.
		*
		* On the server, this will give an event that can use `Connect`.
		*
		* @param mw The middleware of this event.
	]]
	local function ClientToServerEvent(mw)
		return {
			Type = "Event",
			ServerMiddleware = mw,
		}
	end
	_container.ClientToServerEvent = ClientToServerEvent
	--[[
		*
		* Defines a remote event that can be fired both from the client and server
		*
		* This should only be required in rare use cases where `ClientToServerEvent` or `ServerToClientEvent` is not sufficient.
		*
		* Check to see if {@link ServerAsyncFunction} is more sufficient for your use case.
	]]
	local function BidirectionalEvent()
		return {
			Type = "Event",
			ServerMiddleware = {},
		}
	end
	_container.BidirectionalEvent = BidirectionalEvent
end
local default = NetDefinitions
return {
	default = default,
}
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="253">
                  <Properties>
                    <string name="Name">ClientDefinitionBuilder</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local ClientAsyncFunction = TS.import(script, script.Parent.Parent, "client", "ClientAsyncFunction").default
local ClientEvent = TS.import(script, script.Parent.Parent, "client", "ClientEvent").default
local ClientFunction = TS.import(script, script.Parent.Parent, "client", "ClientFunction").default
local _internal = TS.import(script, script.Parent.Parent, "internal")
local getGlobalRemote = _internal.getGlobalRemote
local NAMESPACE_ROOT = _internal.NAMESPACE_ROOT
local NAMESPACE_SEPARATOR = _internal.NAMESPACE_SEPARATOR
-- Keep the declarations fully isolated
local declarationMap = setmetatable({}, {
	__mode = "k",
})
local shouldYield = setmetatable({}, {
	__mode = "k",
})
local ClientDefinitionBuilder
do
	ClientDefinitionBuilder = setmetatable({}, {
		__tostring = function()
			return "ClientDefinitionBuilder"
		end,
	})
	ClientDefinitionBuilder.__index = ClientDefinitionBuilder
	function ClientDefinitionBuilder.new(...)
		local self = setmetatable({}, ClientDefinitionBuilder)
		return self:constructor(...) or self
	end
	function ClientDefinitionBuilder:constructor(declarations, configuration, namespace)
		if namespace == nil then
			namespace = NAMESPACE_ROOT
		end
		self.configuration = configuration
		self.namespace = namespace
		local _self = self
		declarationMap[_self] = declarations
		local _exp = self
		local _result = configuration
		if _result ~= nil then
			_result = _result.ClientGetShouldYield
		end
		local _condition = _result
		if _condition == nil then
			_condition = true
		end
		shouldYield[_exp] = _condition
	end
	function ClientDefinitionBuilder:toString()
		return "[" .. ("ClientDefinitionBuilder" .. "]")
	end
	function ClientDefinitionBuilder:Get(remoteId)
		local _self = self
		if shouldYield[_self] then
			return self:WaitFor(remoteId):expect()
		else
			return self:GetOrThrow(remoteId)
		end
	end
	function ClientDefinitionBuilder:GetNamespace(namespaceId)
		local _self = self
		local group = declarationMap[_self][namespaceId]
		local _arg1 = "Group " .. (namespaceId .. (" does not exist under namespace " .. self.namespace))
		assert(group, _arg1)
		local _arg0 = group.Type == "Namespace"
		assert(_arg0)
		local _fn = group.Definitions
		local _exp = group.Definitions:_CombineConfigurations(self.configuration or {})
		local _result
		if self.namespace ~= NAMESPACE_ROOT then
			-- ▼ ReadonlyArray.join ▼
			local _nAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR
			if _nAMESPACE_SEPARATOR == nil then
				_nAMESPACE_SEPARATOR = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_result = table.concat({ self.namespace, namespaceId }, _nAMESPACE_SEPARATOR)
		else
			_result = namespaceId
		end
		return _fn:_BuildClientDefinition(_exp, _result)
	end
	function ClientDefinitionBuilder:GetOrThrow(remoteId)
		local _self = self
		local item = declarationMap[_self][remoteId]
		local _result
		if self.namespace ~= NAMESPACE_ROOT then
			-- ▼ ReadonlyArray.join ▼
			local _nAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR
			if _nAMESPACE_SEPARATOR == nil then
				_nAMESPACE_SEPARATOR = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_result = (table.concat({ self.namespace, remoteId }, _nAMESPACE_SEPARATOR))
		else
			_result = remoteId
		end
		remoteId = _result
		local _arg0 = item and item.Type
		local _arg1 = "'" .. (remoteId .. "' is not defined in this definition.")
		assert(_arg0, _arg1)
		local _ = nil
		local _1 = nil
		local config = self.configuration or {}
		if item.Type == "Function" then
			return ClientFunction.new(remoteId, config)
		elseif item.Type == "Event" then
			return ClientEvent.new(remoteId, config)
		elseif item.Type == "AsyncFunction" then
			return ClientAsyncFunction.new(remoteId, config)
		elseif item.Type == "ExperienceEvent" then
			return ClientEvent.new(getGlobalRemote(remoteId), config)
		end
		error("Type '" .. (item.Type .. "' is not a valid client remote object type"))
	end
	ClientDefinitionBuilder.WaitFor = TS.async(function(self, remoteId)
		local _self = self
		local item = declarationMap[_self][remoteId]
		local _result
		if self.namespace ~= NAMESPACE_ROOT then
			-- ▼ ReadonlyArray.join ▼
			local _nAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR
			if _nAMESPACE_SEPARATOR == nil then
				_nAMESPACE_SEPARATOR = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_result = (table.concat({ self.namespace, remoteId }, _nAMESPACE_SEPARATOR))
		else
			_result = remoteId
		end
		remoteId = _result
		local _arg0 = item and item.Type
		local _arg1 = "'" .. (remoteId .. "' is not defined in this definition.")
		assert(_arg0, _arg1)
		local _ = nil
		local _1 = nil
		local config = self.configuration or {}
		if item.Type == "Function" then
			return ClientFunction:Wait(remoteId, config)
		elseif item.Type == "Event" then
			return ClientEvent:Wait(remoteId, config)
		elseif item.Type == "AsyncFunction" then
			return ClientAsyncFunction:Wait(remoteId, config)
		elseif item.Type == "ExperienceEvent" then
			return ClientEvent:Wait(getGlobalRemote(remoteId), config)
		end
		error("Type '" .. (item.Type .. "' is not a valid client remote object type"))
	end)
	ClientDefinitionBuilder.OnEvent = TS.async(function(self, name, fn)
		local result = (TS.await(self:WaitFor(name)))
		return result:Connect(fn)
	end)
	ClientDefinitionBuilder.OnFunction = TS.async(function(self, name, fn)
		local result = (TS.await(self:WaitFor(name)))
		result:SetCallback(fn)
	end)
	function ClientDefinitionBuilder:__tostring()
		return self:toString()
	end
end
return {
	ClientDefinitionBuilder = ClientDefinitionBuilder,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="254">
                  <Properties>
                    <string name="Name">NamespaceBuilder</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local ClientDefinitionBuilder = TS.import(script, script.Parent, "ClientDefinitionBuilder").ClientDefinitionBuilder
local ServerDefinitionBuilder = TS.import(script, script.Parent, "ServerDefinitionBuilder").ServerDefinitionBuilder
local RunService = game:GetService("RunService")
-- Isolate the definitions since we don't need to access them anywhere else.
local declarationMap = setmetatable({}, {
	__mode = "k",
})
--[[
	*
	* A namespace builder. Internally used to construct definition builders
]]
local NamespaceBuilder
do
	NamespaceBuilder = setmetatable({}, {
		__tostring = function()
			return "NamespaceBuilder"
		end,
	})
	NamespaceBuilder.__index = NamespaceBuilder
	function NamespaceBuilder.new(...)
		local self = setmetatable({}, NamespaceBuilder)
		return self:constructor(...) or self
	end
	function NamespaceBuilder:constructor(declarations, config)
		self.config = config
		local _self = self
		declarationMap[_self] = declarations
		local _ = declarations
	end
	function NamespaceBuilder:_CombineConfigurations(parentConfig)
		local _object = {}
		for _k, _v in pairs(parentConfig) do
			_object[_k] = _v
		end
		local _spread = self.config
		if type(_spread) == "table" then
			for _k, _v in pairs(_spread) do
				_object[_k] = _v
			end
		end
		local newConfig = _object
		return newConfig
	end
	function NamespaceBuilder:_BuildServerDefinition(configuration, namespace)
		local _arg0 = RunService:IsServer()
		assert(_arg0)
		local _ = nil
		local _1 = nil
		local _self = self
		return ServerDefinitionBuilder.new(declarationMap[_self], configuration, namespace)
	end
	function NamespaceBuilder:_BuildClientDefinition(configuration, namespace)
		local _arg0 = RunService:IsClient()
		assert(_arg0)
		local _ = nil
		local _1 = nil
		local _self = self
		return ClientDefinitionBuilder.new(declarationMap[_self], configuration, namespace)
	end
end
return {
	NamespaceBuilder = NamespaceBuilder,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="255">
                  <Properties>
                    <string name="Name">ServerDefinitionBuilder</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local ServerAsyncFunction = TS.import(script, script.Parent.Parent, "server", "ServerAsyncFunction").default
local ServerEvent = TS.import(script, script.Parent.Parent, "server", "ServerEvent").default
local ServerFunction = TS.import(script, script.Parent.Parent, "server", "ServerFunction").default
local _internal = TS.import(script, script.Parent.Parent, "internal")
local NAMESPACE_ROOT = _internal.NAMESPACE_ROOT
local NAMESPACE_SEPARATOR = _internal.NAMESPACE_SEPARATOR
local ExperienceBroadcastEvent = TS.import(script, script.Parent.Parent, "messaging", "ExperienceBroadcastEvent").default
local ServerMessagingEvent = TS.import(script, script.Parent.Parent, "server", "ServerMessagingEvent").default
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
-- Tidy up all the types here.
-- Keep the declarations fully isolated
local declarationMap = setmetatable({}, {
	__mode = "k",
})
local remoteEventCache = {}
local remoteAsyncFunctionCache = {}
local remoteFunctionCache = {}
local messagingEventCache = {}
local messagingServerEventCache = {}
local ServerDefinitionBuilder
do
	ServerDefinitionBuilder = setmetatable({}, {
		__tostring = function()
			return "ServerDefinitionBuilder"
		end,
	})
	ServerDefinitionBuilder.__index = ServerDefinitionBuilder
	function ServerDefinitionBuilder.new(...)
		local self = setmetatable({}, ServerDefinitionBuilder)
		return self:constructor(...) or self
	end
	function ServerDefinitionBuilder:constructor(declarations, config, namespace)
		if namespace == nil then
			namespace = NAMESPACE_ROOT
		end
		self.config = config
		self.namespace = namespace
		local _binding = config
		local AutoGenerateServerRemotes = _binding.ServerAutoGenerateRemotes
		if AutoGenerateServerRemotes == nil then
			AutoGenerateServerRemotes = true
		end
		local GlobalMiddleware = _binding.ServerGlobalMiddleware
		local _self = self
		declarationMap[_self] = declarations
		local _ = declarations
		-- We only run remote creation on the server
		if RunService:IsServer() and AutoGenerateServerRemotes then
			self:_InitServer()
		end
		self.globalMiddleware = GlobalMiddleware
	end
	function ServerDefinitionBuilder:_CreateOrGetInstance(id, declaration)
		local _arg0 = RunService:IsServer()
		assert(_arg0, "Can only create server instances on the server")
		--[[
			*
			* This is used to generate or fetch the specified remote from a declaration
			*
			* The generated remote id is based off the current namespace.
		]]
		local _result
		if self.namespace ~= NAMESPACE_ROOT then
			-- ▼ ReadonlyArray.join ▼
			local _nAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR
			if _nAMESPACE_SEPARATOR == nil then
				_nAMESPACE_SEPARATOR = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_result = table.concat({ self.namespace, id }, _nAMESPACE_SEPARATOR)
		else
			_result = id
		end
		local namespacedId = _result
		local config = self.config
		if declaration.Type == "Function" then
			local func
			if remoteFunctionCache[namespacedId] ~= nil then
				return remoteFunctionCache[namespacedId]
			else
				if declaration.ServerMiddleware then
					func = ServerFunction.new(namespacedId, declaration.ServerMiddleware, config)
				else
					func = ServerFunction.new(namespacedId, nil, config)
				end
				CollectionService:AddTag(func:GetInstance(), "NetDefinitionManaged")
				local _func = func
				remoteFunctionCache[namespacedId] = _func
				local _result_1 = self.globalMiddleware
				if _result_1 ~= nil then
					local _arg0_1 = function(mw)
						return func:_use(mw)
					end
					for _k, _v in ipairs(_result_1) do
						_arg0_1(_v, _k - 1, _result_1)
					end
				end
				return func
			end
		elseif declaration.Type == "AsyncFunction" then
			local asyncFunction
			-- This should make certain use cases cheaper
			if remoteAsyncFunctionCache[namespacedId] ~= nil then
				return remoteAsyncFunctionCache[namespacedId]
			else
				if declaration.ServerMiddleware then
					asyncFunction = ServerAsyncFunction.new(namespacedId, declaration.ServerMiddleware, config)
				else
					asyncFunction = ServerAsyncFunction.new(namespacedId, nil, config)
				end
				CollectionService:AddTag(asyncFunction:GetInstance(), "NetDefinitionManaged")
				local _asyncFunction = asyncFunction
				remoteAsyncFunctionCache[namespacedId] = _asyncFunction
			end
			local _result_1 = self.globalMiddleware
			if _result_1 ~= nil then
				local _arg0_1 = function(mw)
					return asyncFunction:_use(mw)
				end
				for _k, _v in ipairs(_result_1) do
					_arg0_1(_v, _k - 1, _result_1)
				end
			end
			return asyncFunction
		elseif declaration.Type == "Event" then
			local event
			-- This should make certain use cases cheaper
			if remoteEventCache[namespacedId] ~= nil then
				return remoteEventCache[namespacedId]
			else
				if declaration.ServerMiddleware then
					event = ServerEvent.new(namespacedId, declaration.ServerMiddleware, config)
				else
					event = ServerEvent.new(namespacedId, nil, config)
				end
				CollectionService:AddTag(event:GetInstance(), "NetDefinitionManaged")
				local _event = event
				remoteEventCache[namespacedId] = _event
			end
			local _result_1 = self.globalMiddleware
			if _result_1 ~= nil then
				local _arg0_1 = function(mw)
					return event:_use(mw)
				end
				for _k, _v in ipairs(_result_1) do
					_arg0_1(_v, _k - 1, _result_1)
				end
			end
			return event
		elseif declaration.Type == "Messaging" then
			local event
			if messagingEventCache[namespacedId] ~= nil then
				return messagingEventCache[namespacedId]
			else
				event = ExperienceBroadcastEvent.new(namespacedId)
				local _event = event
				messagingEventCache[namespacedId] = _event
			end
			return event
		elseif declaration.Type == "ExperienceEvent" then
			local event
			if messagingServerEventCache[namespacedId] ~= nil then
				return messagingServerEventCache[namespacedId]
			else
				event = ServerMessagingEvent.new(namespacedId, config)
				local _event = event
				messagingServerEventCache[namespacedId] = _event
			end
			return event
		else
			error("Unhandled type")
		end
	end
	function ServerDefinitionBuilder:_InitServer()
		--[[
			*
			* Used to generate all the remotes on the server-side straight away.
			*
			* So long as the remote declaration file is imported, and it's the server this _should_ run.
			*
			* This will fix https://github.com/roblox-aurora/rbx-net/issues/57, which is a long standing race-condition issue
			* I, as well as many other users have run into from time to time.
		]]
		local _ = nil
		local _1 = nil
		local _self = self
		local declarations = declarationMap[_self]
		for id, declaration in pairs(declarations) do
			local _exp = declaration.Type
			repeat
				local _fallthrough = false
				if _exp == "Event" then
					_fallthrough = true
				end
				if _fallthrough or _exp == "AsyncFunction" then
					_fallthrough = true
				end
				if _fallthrough or _exp == "Function" then
					_fallthrough = true
				end
				if _fallthrough or _exp == "Messaging" then
					self:_CreateOrGetInstance(id, declaration)
					break
				end
				if _exp == "Namespace" then
					self:GetNamespace(id)
					break
				end
			until true
		end
	end
	function ServerDefinitionBuilder:toString()
		return "[" .. ("ServerDefinitionBuilder" .. "]")
	end
	function ServerDefinitionBuilder:OnEvent(name, fn)
		local result = self:Get(name)
		return result:Connect(fn)
	end
	function ServerDefinitionBuilder:GetNamespace(namespaceId)
		local _self = self
		local group = declarationMap[_self][namespaceId]
		local _arg1 = "Group " .. (namespaceId .. (" does not exist under namespace " .. self.namespace))
		assert(group, _arg1)
		local _arg0 = group.Type == "Namespace"
		assert(_arg0)
		local _ = nil
		local _1 = nil
		local _fn = group.Definitions
		local _exp = group.Definitions:_CombineConfigurations(self.config)
		local _result
		if self.namespace ~= NAMESPACE_ROOT then
			-- ▼ ReadonlyArray.join ▼
			local _nAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR
			if _nAMESPACE_SEPARATOR == nil then
				_nAMESPACE_SEPARATOR = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_result = table.concat({ self.namespace, namespaceId }, _nAMESPACE_SEPARATOR)
		else
			_result = namespaceId
		end
		return _fn:_BuildServerDefinition(_exp, _result)
	end
	function ServerDefinitionBuilder:Get(remoteId)
		local _self = self
		local item = declarationMap[_self][remoteId]
		local _arg0 = item and item.Type
		local _arg1 = "'" .. (remoteId .. "' is not defined in this definition.")
		assert(_arg0, _arg1)
		if item.Type == "Function" or (item.Type == "AsyncFunction" or (item.Type == "Event" or item.Type == "Messaging")) then
			if remoteAsyncFunctionCache[remoteId] ~= nil then
				local _ = nil
				local _1 = nil
				return remoteAsyncFunctionCache[remoteId]
			else
				return self:_CreateOrGetInstance(remoteId, item)
			end
		else
			error("Invalid type for " .. remoteId)
		end
	end
	function ServerDefinitionBuilder:Create(remoteId)
		return self:Get(remoteId)
	end
	function ServerDefinitionBuilder:OnFunction(name, fn)
		local result = self:Get(name)
		result:SetCallback(fn)
	end
	function ServerDefinitionBuilder:__tostring()
		return self:toString()
	end
end
return {
	ServerDefinitionBuilder = ServerDefinitionBuilder,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="256">
                  <Properties>
                    <string name="Name">Types</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
--[[
	*
	* Types
	*
	* I will admit, this is a lot of type spaghetti. It makes the definitions work good though. :D
]]
local oneOf = TS.import(script, script.Parent.Parent, "internal", "validator").oneOf
--[[
	*
	* The DefinitionBuilders type
]]
--[[
	*
	* @deprecated
]]
--[[
	*
	* A declaration for an async client function
]]
--[[
	*
	* A declaration for an async server function
]]
-- * @deprecated
--[[
	*
	* A declaration for a client -> server event
]]
--[[
	*
	* A declaration for a server -> client event
]]
--[[
	*
	* A declaration for a server -> server event
]]
--[[
	*
	* A declaration for a server -> server event, that replicates to clients
]]
--[[
	*
	* A declaration for a Bidirectional event
]]
--[[
	*
	* A declaration group
]]
-- //////////////////////////////
-- * Inference Magic
-- /////////////////////////////
--[[
	*
	* This infers the client remote type based on the given value
]]
--[[
	*
	* This infers the server remote type based on the given value
]]
-- ///////////////////////////////////////
-- * Results
-- ///////////////////////////////////////
local DeclarationTypeCheck = oneOf("Event", "Function", "AsyncFunction", "Namespace", "Messaging", "ExperienceEvent")
return {
	DeclarationTypeCheck = DeclarationTypeCheck,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="257">
                <Properties>
                  <string name="Name">internal</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local HttpService = game:GetService("HttpService")
local runService = game:GetService("RunService")
local collectionService = game:GetService("CollectionService")
-- * @internal
local NAMESPACE_SEPARATOR = "/"
-- * @internal
local NAMESPACE_ROOT = "@"
-- * @internal
local IS_SERVER = not runService:IsRunning() or runService:IsServer()
-- * @internal
local IS_CLIENT = runService:IsRunning() and runService:IsClient()
local IS_RUNNING = runService:IsRunning()
-- * @internal
local MAX_CLIENT_WAITFORCHILD_TIMEOUT = 10
-- * @internal
local function getGlobalRemote(name)
	return ":\\" .. name
end
-- * @internal
local function isLuaTable(value)
	return type(value) == "table"
end
-- * @internal
local NetMiddlewareEvent
do
	NetMiddlewareEvent = setmetatable({}, {
		__tostring = function()
			return "NetMiddlewareEvent"
		end,
	})
	NetMiddlewareEvent.__index = NetMiddlewareEvent
	function NetMiddlewareEvent.new(...)
		local self = setmetatable({}, NetMiddlewareEvent)
		return self:constructor(...) or self
	end
	function NetMiddlewareEvent:constructor(netInstance)
		self.netInstance = netInstance
	end
	function NetMiddlewareEvent:GetInstance()
		return self.netInstance:GetInstance()
	end
end
local REMOTES_FOLDER_NAME = "_NetManaged"
-- * @internal
-- * @internal
local ServerTickFunctions = {}
-- * @internal
local function findOrCreateFolder(parent, name)
	local folder = parent:FindFirstChild(name)
	if folder then
		return folder
	else
		folder = Instance.new("Folder", parent)
		folder.Name = name
		return folder
	end
end
-- const dist = $env<"TS" | "Luau" | "TestTS">("TYPE", "TS");
local location = script.Parent
local _ = nil
local _1 = nil
local remoteFolder = findOrCreateFolder(location, REMOTES_FOLDER_NAME)
--[[
	*
	* Errors with variables formatted in a message
	* @param message The message
	* @param vars variables to pass to the error message
]]
local function errorft(message, vars)
	-- eslint-disable-next-line @typescript-eslint/ban-ts-comment
	-- @ts-ignore
	local _arg1 = function(token)
		local _condition = vars[token]
		if _condition == nil then
			_condition = token
		end
		return _condition
	end
	message = string.gsub(message, "{([%w_][%w%d_]*)}", _arg1)
	error(message, 2)
end
local traceSet = {}
local function warnOnce(message)
	local trace = debug.traceback()
	if traceSet[trace] ~= nil then
		return nil
	end
	traceSet[trace] = true
	warn("[rbx-net] " .. message)
end
local function format(message, vars)
	-- eslint-disable-next-line @typescript-eslint/ban-ts-comment
	-- @ts-ignore
	local _arg1 = function(token)
		local _condition = vars[token]
		if _condition == nil then
			_condition = token
		end
		return _condition
	end
	message = string.gsub(message, "{([%w_][%w%d_]*)}", _arg1)
	return message
end
-- * @internal
local findRemote, getTagFromRemoteType
local function waitForRemote(remoteType, name, timeout)
	return TS.Promise.defer(function(resolve, reject)
		-- First, check if remote already exists
		local result = findRemote(remoteType, name)
		if result then
			resolve(result)
			return nil
		end
		-- If not, wait for remote
		local searchStart = os.clock()
		local remote = remoteFolder:WaitForChild(name, timeout)
		local remoteTypeTag = getTagFromRemoteType(remoteType)
		if remote and table.find(collectionService:GetTags(remote), remoteTypeTag) ~= nil then
			resolve(remote)
			return nil
		end
		-- If result is not correct remote type, poll until correct remote is added
		local elapsed = os.clock() - searchStart
		while elapsed < timeout do
			elapsed += (runService.Heartbeat:Wait())
			result = findRemote(remoteType, name)
			if result then
				resolve(result)
				return nil
			end
		end
		reject("Timed out while waiting for " .. (remoteType .. (" '" .. (name .. ("' after " .. (tostring(elapsed) .. " seconds."))))))
	end)
end
-- * @internal
function findRemote(remoteType, name)
	local tag = getTagFromRemoteType(remoteType)
	local _exp = collectionService:GetTagged(tag)
	local _arg0 = function(f)
		return f.Name == name
	end
	-- ▼ ReadonlyArray.find ▼
	local _result
	for _i, _v in ipairs(_exp) do
		if _arg0(_v, _i - 1, _exp) == true then
			_result = _v
			break
		end
	end
	-- ▲ ReadonlyArray.find ▲
	return _result
end
-- * @internal
function getTagFromRemoteType(remoteType)
	repeat
		if remoteType == "AsyncRemoteFunction" then
			return "NetManagedAsyncFunction"
		end
		if remoteType == "RemoteEvent" then
			return "NetManagedEvent"
		end
		if remoteType == "RemoteFunction" then
			return "NetManagedLegacyFunction"
		end
	until true
	error("Invalid Remote Access")
end
-- * @internal
local function getRemoteOrThrow(remoteType, name)
	local existing = findRemote(remoteType, name)
	if existing then
		return existing
	else
		error("Could not find Remote of type " .. (remoteType .. (' called "' .. (name .. '"'))))
	end
end
-- * @internal
local function findOrCreateRemote(remoteType, name, onCreate)
	local existing = findRemote(remoteType, name)
	if existing then
		if collectionService:HasTag(existing, "NetDefinitionManaged") then
			warnOnce("Fetching " .. (remoteType .. (" '" .. (name .. "', which is a DefinitionsManaged instance from a non-definitions context. This is considered unsafe."))))
		end
		return existing
	else
		if not IS_SERVER then
			error("Creation of Events or Functions must be done on server!")
		end
		local remote
		if remoteType == "RemoteEvent" then
			remote = Instance.new("RemoteEvent")
			collectionService:AddTag(remote, "NetManagedEvent")
		elseif remoteType == "AsyncRemoteFunction" then
			remote = Instance.new("RemoteEvent")
			collectionService:AddTag(remote, "NetManagedAsyncFunction")
		elseif remoteType == "RemoteFunction" then
			remote = Instance.new("RemoteFunction")
			collectionService:AddTag(remote, "NetManagedLegacyFunction")
		else
			error("Invalid Remote Type: " .. remoteType)
		end
		remote.Name = name
		remote.Parent = remoteFolder
		local _2 = nil
		local _3 = nil
		local _result = onCreate
		if _result ~= nil then
			_result(remote)
		end
		return remote
	end
end
-- * @internal
local function checkArguments(types, args)
	if args == nil then
		warn("[net-types] Argument length is zero")
		return false
	end
	do
		local i = 0
		local _shouldIncrement = false
		while true do
			if _shouldIncrement then
				i += 1
			else
				_shouldIncrement = true
			end
			if not (i < #types) then
				break
			end
			local typeCheck = types[i + 1]
			local value = args[i + 1]
			if not typeCheck(value) then
				warn("[net-types] Argument at index " .. (tostring(i) .. " was invalid type."))
				return false
			end
		end
	end
	return true
end
if IS_SERVER then
	game:GetService("RunService").Stepped:Connect(function(time, step)
		for _2, f in ipairs(ServerTickFunctions) do
			f()
		end
	end)
end
return {
	getGlobalRemote = getGlobalRemote,
	isLuaTable = isLuaTable,
	findOrCreateFolder = findOrCreateFolder,
	errorft = errorft,
	warnOnce = warnOnce,
	format = format,
	waitForRemote = waitForRemote,
	findRemote = findRemote,
	getTagFromRemoteType = getTagFromRemoteType,
	getRemoteOrThrow = getRemoteOrThrow,
	findOrCreateRemote = findOrCreateRemote,
	checkArguments = checkArguments,
	NAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR,
	NAMESPACE_ROOT = NAMESPACE_ROOT,
	IS_SERVER = IS_SERVER,
	IS_CLIENT = IS_CLIENT,
	IS_RUNNING = IS_RUNNING,
	MAX_CLIENT_WAITFORCHILD_TIMEOUT = MAX_CLIENT_WAITFORCHILD_TIMEOUT,
	NetMiddlewareEvent = NetMiddlewareEvent,
	ServerTickFunctions = ServerTickFunctions,
}
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="258">
                  <Properties>
                    <string name="Name">tables</string>
                    <string name="Source">local function isMixed(t)
	assert(type(t) == "table")
	local mixed = false
	local _idxType

	for index, value in next, t do
		if _idxType and _idxType ~= type(index) then
			return true
		end

		_idxType = type(index)
		if type(value) == "table" then
			mixed = mixed and isMixed(value) and not (not getmetatable(value))
		end
	end

	return mixed
end

return {
	mixed = isMixed
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="259">
                  <Properties>
                    <string name="Name">validator</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local isMixed = TS.import(script, script.Parent, "tables").isMixed
local Workspace = game:GetService("Workspace")
local ServerStorage = game:GetService("ServerStorage")
local ServerScriptService = game:GetService("ServerScriptService")
-- * @internal
local isSerializable
local function validateArguments(...)
	local args = { ... }
	for index, value in ipairs(args) do
		if not isSerializable.check(value) then
			error(string.format(isSerializable.errorMessage, index), 2)
		end
		if typeof(value) == "Instance" then
			if value:IsDescendantOf(ServerStorage) or value:IsDescendantOf(ServerScriptService) then
				error("[rbx-net] Instance at argument #" .. (tostring(index) .. " is inside a server-only container and cannot be sent via remotes."))
			end
			if not value:IsDescendantOf(game) then
				error("[rbx-net] Instance at argument #" .. (tostring(index) .. " is not a valid descendant of game, and wont replicate"))
			end
		end
	end
end
-- * @internal
isSerializable = {
	errorMessage = "Argument #%d is not serializable. - see http://docs.vorlias.com/rbx-net/docs/2.0/serialization",
	check = function(value)
		-- Can't allow functions or threads
		if type(value) == "function" or type(value) == "thread" then
			return false
		end
		-- Can't allow metatabled objects
		if type(value) == "table" and getmetatable(value) ~= nil then
			return false
		end
		-- Ensure not a mixed table type
		if type(value) == "table" then
			return not isMixed(value)
		end
		return true
	end,
}
-- * @internal
local function oneOf(...)
	local values = { ... }
	return {
		errorMessage = "Expected one of: " .. table.concat(values, ", "),
		check = function(value)
			if not (type(value) == "string") then
				return false
			end
			for _, cmpValue in ipairs(values) do
				if value == cmpValue then
					return true
				end
			end
			return false
		end,
	}
end
return {
	validateArguments = validateArguments,
	oneOf = oneOf,
	isSerializable = isSerializable,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="260">
                <Properties>
                  <string name="Name">messaging</string>
                </Properties>
                <Item class="ModuleScript" referent="261">
                  <Properties>
                    <string name="Name">ExperienceBroadcastEvent</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local isLuaTable = _internal.isLuaTable
local ServerTickFunctions = _internal.ServerTickFunctions
-- const MessagingService = game.GetService("MessagingService");
local MessagingService = TS.import(script, script.Parent, "MessagingService")
local Players = game:GetService("Players")
local IS_STUDIO = game:GetService("RunService"):IsStudio()
--[[
	*
	* Checks if a value matches that of a subscription message
	* @param value The value
]]
local function isSubscriptionMessage(value)
	if isLuaTable(value) then
		local hasData = value.Data ~= nil
		return hasData
	else
		return false
	end
end
local function isJobTargetMessage(value)
	if isSubscriptionMessage(value) then
		if isLuaTable(value.Data) then
			return value.Data.jobId ~= nil
		end
	end
	return false
end
local globalMessageQueue = {}
local lastQueueTick = 0
local globalEventMessageCounter = 0
local globalSubscriptionCounter = 0
local ExperienceBroadcastEvent
local function processMessageQueue()
	if tick() >= lastQueueTick + 60 then
		globalEventMessageCounter = 0
		globalSubscriptionCounter = 0
		lastQueueTick = tick()
		while #globalMessageQueue > 0 do
			-- ▼ Array.pop ▼
			local _length = #globalMessageQueue
			local _result = globalMessageQueue[_length]
			globalMessageQueue[_length] = nil
			-- ▲ Array.pop ▲
			local message = _result
			MessagingService:PublishAsync(message.Name, message.Data)
			globalEventMessageCounter += 1
		end
		if globalEventMessageCounter >= ExperienceBroadcastEvent:GetMessageLimit() then
			warn("[rbx-net] Too many messages are being sent, any further messages will be queued!")
		end
	end
end
--[[
	*
	* Message Size: 1kB
	* MessagesPerMin: 150 + 60 * NUMPLAYERS
	* MessagesPerTopicMin: 30M
	* MessagesPerUniversePerMin: 30M
	* SubsPerServer: 5 + 2 * numPlayers
	* SubsPerUniverse: 10K
]]
--[[
	*
	* An event that works across all servers
	* @see https://developer.roblox.com/api-reference/class/MessagingService for limits, etc.
]]
do
	ExperienceBroadcastEvent = setmetatable({}, {
		__tostring = function()
			return "ExperienceBroadcastEvent"
		end,
	})
	ExperienceBroadcastEvent.__index = ExperienceBroadcastEvent
	function ExperienceBroadcastEvent.new(...)
		local self = setmetatable({}, ExperienceBroadcastEvent)
		return self:constructor(...) or self
	end
	function ExperienceBroadcastEvent:constructor(name)
		self.name = name
	end
	function ExperienceBroadcastEvent:GetMessageLimit()
		return 150 + 60 * #Players:GetPlayers()
	end
	function ExperienceBroadcastEvent:GetSubscriptionLimit()
		return 5 + 2 * #Players:GetPlayers()
	end
	function ExperienceBroadcastEvent:sendToAllServersOrQueue(data)
		local limit = ExperienceBroadcastEvent:GetMessageLimit()
		if globalEventMessageCounter >= limit then
			warn("[rbx-net] Exceeded message limit of " .. (tostring(limit) .. ", adding to queue..."))
			local _arg0 = {
				Name = self.name,
				Data = data,
			}
			table.insert(globalMessageQueue, _arg0)
		else
			globalEventMessageCounter += 1
			-- Since this yields
			MessagingService:PublishAsync(self.name, data)
		end
	end
	function ExperienceBroadcastEvent:SendToServer(serverJobId, sendData)
		self:sendToAllServersOrQueue({
			jobId = serverJobId,
			message = sendData,
		})
	end
	function ExperienceBroadcastEvent:SendToAllServers(sendData)
		self:sendToAllServersOrQueue(sendData)
	end
	function ExperienceBroadcastEvent:Connect(handler)
		local limit = ExperienceBroadcastEvent:GetSubscriptionLimit()
		if globalSubscriptionCounter >= limit then
			error("[rbx-net] Exceeded Subscription limit of " .. (tostring(limit) .. "!"))
		end
		globalSubscriptionCounter += 1
		return MessagingService:SubscribeAsync(self.name, function(message)
			local recieved = message
			local _binding = recieved
			local Sent = _binding.Sent
			if isJobTargetMessage(recieved) then
				local _binding_1 = recieved
				local Data = _binding_1.Data
				if game.JobId == Data.JobId then
					handler(Data.InnerData, Sent)
				end
			else
				handler(recieved.Data, Sent)
			end
		end)
	end
end
table.insert(ServerTickFunctions, processMessageQueue)
return {
	isSubscriptionMessage = isSubscriptionMessage,
	default = ExperienceBroadcastEvent,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="262">
                  <Properties>
                    <string name="Name">MessagingService</string>
                    <string name="Source">local RunService = game:GetService("RunService")
local MessagingService = game:GetService("MessagingService")

local MockMessagingService = {}
local topics = {}

function MockMessagingService:PublishAsync(topicName, message)
	local topic = topics[topicName]
	if topic then
		topic:Fire(
			{
				Sent = tick(),
				Data = message
			}
		)
	end
end

function MockMessagingService:SubscribeAsync(topicName, callback)
	local topic = topics[topicName]
	if not topic then
		topic = Instance.new("BindableEvent")
		topic.Parent = script
		topic.Name = topicName
		topics[topicName] = topic
	end

	return topic.Event:Connect(callback)
end

local service
if RunService:IsStudio() then
    service = MockMessagingService
else
    service = MessagingService
end


return service</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="263">
                <Properties>
                  <string name="Name">middleware</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local createLoggerMiddleware = TS.import(script, script, "LoggerMiddleware")
local createRateLimiter = TS.import(script, script, "RateLimitMiddleware").default
local NetTypeCheckingMiddleware = TS.import(script, script, "TypeCheckMiddleware")
local NetMiddleware = {}
do
	local _container = NetMiddleware
	local RateLimit = createRateLimiter
	_container.RateLimit = RateLimit
	local Logging = createLoggerMiddleware
	_container.Logging = Logging
	-- * The type checking middleware
	local TypeChecking = NetTypeCheckingMiddleware
	_container.TypeChecking = TypeChecking
	--[[
		*
		* Creates a global read-only middleware for use in `Net.Definitions` global middleware.
	]]
	local function Global(middleware)
		local _arg0 = function(processNext, event)
			return function(sender, ...)
				local args = { ... }
				middleware(event:GetInstance().Name, args, sender)
				return processNext(sender, unpack(args))
			end
		end
		return _arg0
	end
	_container.Global = Global
end
local createTypeChecker = NetTypeCheckingMiddleware
return {
	NetMiddleware = NetMiddleware,
	createRateLimiter = createRateLimiter,
	createTypeChecker = createTypeChecker,
}
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="264">
                  <Properties>
                    <string name="Name">LoggerMiddleware</string>
                    <string name="Source">local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local IS_STUDIO = RunService:IsStudio()

local function defaultLogger(name, args)
    if IS_STUDIO then
        local str = {};
        for _, arg in ipairs(args) do
            table.insert(str, HttpService:JSONEncode(arg))
        end
        print("[rbx-net] Called", name, "with arguments", "[ " .. table.concat(str, ", ") .. " ]")
    end
end

return function(options)
    options = options or {}
    local logger = options.Logger or defaultLogger

    return function (next, event)
        local name = options.Name or event:GetInstance().Name
        return function(player, ...)
            logger(name, {...})
            return next(player, ...)
        end
    end
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="265">
                  <Properties>
                    <string name="Name">RateLimitMiddleware</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local format = _internal.format
local IS_SERVER = _internal.IS_SERVER
local ServerTickFunctions = _internal.ServerTickFunctions
local throttler = TS.import(script, script, "throttle")
local throttles = {}
local function rateLimitWarningHandler(rateLimitError)
	warn("[rbx-net]", rateLimitError.Message)
end
local THROTTLE_RESET_TIMER = 60
--[[
	*
	* Creates a throttle middleware for this event
	*
	* Will limit the amount of requests a player can make to this event
	*
	* _NOTE: Must be used before **other** middlewares as it's not a type altering middleware_
	* @param maxRequestsPerMinute The maximum requests per minute
]]
local function createRateLimiter(options)
	local maxRequestsPerMinute = options.MaxRequestsPerMinute
	local errorHandler = options.ErrorHandler or rateLimitWarningHandler
	local _condition = options.ThrottleMessage
	if _condition == nil then
		_condition = "Request limit exceeded ({limit}) by {player} via {remote}"
	end
	local throttleMessage = _condition
	return function(processNext, event)
		local instance = event:GetInstance()
		local throttle = throttles[event]
		if throttle == nil then
			throttle = throttler:Get(instance:GetFullName())
		end
		return function(player, ...)
			local args = { ... }
			local count = throttle:Get(player)
			if count >= maxRequestsPerMinute then
				local _result = errorHandler
				if _result ~= nil then
					_result({
						Message = format(throttleMessage, {
							player = player.UserId,
							remote = instance.Name,
							limit = maxRequestsPerMinute,
						}),
						MaxRequestsPerMinute = maxRequestsPerMinute,
						RemoteId = instance.Name,
						UserId = player.UserId,
					})
				end
			else
				throttle:Increment(player)
				return processNext(player, unpack(args))
			end
		end
	end
end
if IS_SERVER then
	local lastTick = 0
	local _arg0 = function()
		if tick() > lastTick + THROTTLE_RESET_TIMER then
			lastTick = tick()
			throttler:Clear()
		end
	end
	table.insert(ServerTickFunctions, _arg0)
end
local default = createRateLimiter
return {
	rateLimitWarningHandler = rateLimitWarningHandler,
	default = default,
}
]]></string>
                  </Properties>
                  <Item class="ModuleScript" referent="266">
                    <Properties>
                      <string name="Name">throttle</string>
                      <string name="Source"><![CDATA[local Throttle = {
	counters = {}
}
local RequestCounter = {}
RequestCounter.__index = RequestCounter

function RequestCounter.new()
	local self = {
		counter = {}
	}

	return setmetatable(self, RequestCounter)
end

function RequestCounter:Get(player)
	local counter = self.counter
	local playerQueue = counter[player.UserId]
	return playerQueue or 0
end

function RequestCounter:Increment(player)
	local counter = self.counter
	local playerQueue = counter[player.UserId]

	if not counter[player.UserId] then
		counter[player.UserId] = 1
	else
		counter[player.UserId] = playerQueue + 1
	end
end

function RequestCounter:__tostring()
	return "RequestCounter"
end

function RequestCounter:ClearAll()
	self.counter = {}
end

function Throttle:Get(name)
	local existing = self.counters[name]
	if (existing) then
		return existing
	else
		local newCounter = RequestCounter.new()
		self.counters[name] = newCounter
		return newCounter
	end
end

function Throttle:Clear()
	for _, counter in pairs(self.counters) do
		counter:ClearAll()
	end
end

return Throttle
]]></string>
                    </Properties>
                  </Item>
                </Item>
                <Item class="ModuleScript" referent="267">
                  <Properties>
                    <string name="Name">TypeCheckMiddleware</string>
                    <string name="Source">local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local IS_STUDIO = RunService:IsStudio();

local function defaultErrorHandler(event, args, index)
    local name = event:GetInstance().Name
    if IS_STUDIO then
        warn("[TypeCheckMiddleware] Call to " .. name .. " failed")
        warn("\tRecieved: " .. HttpService:JSONEncode(args))
        warn("\tInvalid argument at index " .. tostring(index))
    end
end

local MiddlewareGlobal = {}
MiddlewareGlobal.__index = MiddlewareGlobal
MiddlewareGlobal.defaultErrorHandler = defaultErrorHandler

local function typeCheckMiddleware(...)
    local checks = {...}
    local MiddlewareInstance = {}
    MiddlewareInstance.__index = MiddlewareInstance;

    function MiddlewareInstance:next(next, event)
        local errorHandler = self.errorHandler or MiddlewareGlobal.defaultErrorHandler
        --  what's returned as callbackFn
        return function(player, ...)
            local args = {...}
            for index, check in ipairs(checks) do
                if not check(args[index]) then
                    pcall(errorHandler, event, args, index)
                    return false
                end
            end

            -- Invoke the next middleware OR the callback (if none left)
            return next(player, ...)
        end
    end

    function MiddlewareInstance.__tostring()
        return "TypeCheckMiddleware"
    end

    function MiddlewareInstance:WithErrorHandler(fn)
        self.errorHandler = fn
        return self
    end

    function MiddlewareInstance:__call(...)
        return self:next(...)
    end
    
    return setmetatable({}, MiddlewareInstance)
    -- ^ The middleware
end

function MiddlewareGlobal.__call(_, ...)
    return typeCheckMiddleware(...)
end

function MiddlewareGlobal.SetDefaultErrorHandler(_, fn)
    MiddlewareGlobal.defaultErrorHandler = fn
end

return setmetatable({}, MiddlewareGlobal)</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="268">
                <Properties>
                  <string name="Name">server</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local AsyncFunction = TS.import(script, script, "ServerAsyncFunction").default
local Event = TS.import(script, script, "ServerEvent").default
local MessagingEvent = TS.import(script, script, "ServerMessagingEvent").default
local Function = TS.import(script, script, "ServerFunction").default
return {
	Event = Event,
	AsyncFunction = AsyncFunction,
	Function = Function,
	MessagingEvent = MessagingEvent,
}
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="269">
                  <Properties>
                    <string name="Name">CreateServerListener</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local ServerEventV2 = TS.import(script, script.Parent, "ServerEvent").default
local function isMiddlewareArgument(args)
	local _condition = #args > 1
	if _condition then
		local _arg0 = args[1]
		_condition = type(_arg0) == "table"
	end
	return _condition
end
--[[
	*
	* Creates a server listening event
]]
local function createServerListener(id, ...)
	local args = { ... }
	local event
	if isMiddlewareArgument(args) then
		local _binding = args
		local middleware = _binding[1]
		local connect = _binding[2]
		event = ServerEventV2.new(id, middleware, {})
		return event:Connect(connect)
	else
		local _binding = args
		local connect = _binding[1]
		event = ServerEventV2.new(id, nil, {})
		return event:Connect(connect)
	end
end
return {
	default = createServerListener,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="270">
                  <Properties>
                    <string name="Name">MiddlewareEvent</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
-- * @internal
local MiddlewareEvent
do
	MiddlewareEvent = {}
	function MiddlewareEvent:constructor(middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		self.middlewares = middlewares
	end
	function MiddlewareEvent:_use(middleware)
		local _exp = (self.middlewares)
		table.insert(_exp, middleware)
	end
	function MiddlewareEvent:_processMiddleware(callback)
		local _binding = self
		local middlewares = _binding.middlewares
		local _exitType, _returns = TS.try(function()
			local _arg0 = type(middlewares) == "table"
			local _arg1 = "The middleware argument should be an array of middlewares not a " .. typeof(middlewares)
			assert(_arg0, _arg1)
			if #middlewares > 0 then
				local callbackFn = callback
				-- Run through each middleware
				for _, middleware in ipairs(middlewares) do
					callbackFn = middleware(callbackFn, self)
				end
				return TS.TRY_RETURN, { callbackFn }
			else
				return TS.TRY_RETURN, { callback }
			end
		end, function(e)
			warn("[rbx-net] " .. tostring(e))
		end)
		if _exitType then
			return unpack(_returns)
		end
	end
end
local default = MiddlewareEvent
return {
	default = default,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="271">
                  <Properties>
                    <string name="Name">MiddlewareFunction</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local MiddlewareFunction
do
	MiddlewareFunction = {}
	function MiddlewareFunction:constructor(middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		self.middlewares = middlewares
	end
	function MiddlewareFunction:_use(middleware)
		local _exp = (self.middlewares)
		table.insert(_exp, middleware)
	end
	function MiddlewareFunction:_processMiddleware(callback)
		local _binding = self
		local middlewares = _binding.middlewares
		local _exitType, _returns = TS.try(function()
			if #middlewares > 0 then
				local callbackFn = callback
				-- Run through each middleware
				for _, middleware in ipairs(middlewares) do
					callbackFn = middleware(callbackFn, self)
				end
				return TS.TRY_RETURN, { callbackFn }
			else
				return TS.TRY_RETURN, { callback }
			end
		end, function(e)
			warn("[rbx-net] " .. tostring(e))
		end)
		if _exitType then
			return unpack(_returns)
		end
	end
end
local default = MiddlewareFunction
return {
	default = default,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="272">
                  <Properties>
                    <string name="Name">NetServerScriptSignal</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
--[[
	*
	* A wrapper around a RBXScriptSignal for remotes, that always has a listener set.
]]
local NetServerScriptSignal
do
	NetServerScriptSignal = setmetatable({}, {
		__tostring = function()
			return "NetServerScriptSignal"
		end,
	})
	NetServerScriptSignal.__index = NetServerScriptSignal
	function NetServerScriptSignal.new(...)
		local self = setmetatable({}, NetServerScriptSignal)
		return self:constructor(...) or self
	end
	function NetServerScriptSignal:constructor(signalInstance, instance)
		self.signalInstance = signalInstance
		self.instance = instance
		self.connections = {}
		self.connectionRefs = setmetatable({}, {
			__mode = "k",
		})
		self.defaultConnectionDelegate = (function(player, ...)
			local args = { ... }
		end)
		self.defaultConnection = signalInstance:Connect(self.defaultConnectionDelegate)
		local sig
		sig = self.instance.AncestryChanged:Connect(function(child, parent)
			if child == instance and parent == nil then
				self:DisconnectAll()
				sig:Disconnect()
			end
		end)
	end
	function NetServerScriptSignal:Connect(callback)
		if self.defaultConnection then
			self.defaultConnection:Disconnect()
			self.defaultConnection = nil
		end
		local connection = self.signalInstance:Connect(callback)
		local _connections = self.connections
		table.insert(_connections, connection)
		local ref
		local _arg0 = {
			NetSignal = self,
			RBXSignal = connection,
			Connected = connection.Connected,
			Disconnect = function(self)
				local _connections_1 = self.NetSignal.connections
				local _arg0_1 = function(f)
					return f == ref
				end
				-- ▼ ReadonlyArray.findIndex ▼
				local _result = -1
				for _i, _v in ipairs(_connections_1) do
					if _arg0_1(_v, _i - 1, _connections_1) == true then
						_result = _i - 1
						break
					end
				end
				-- ▲ ReadonlyArray.findIndex ▲
				local idx = _result
				if idx ~= -1 then
					self.NetSignal:DisconnectAt(idx)
					self.Connected = false
				end
			end,
		}
		ref = _arg0
		self.connectionRefs[ref] = true
		return ref
	end
	function NetServerScriptSignal:Wait()
		return self.signalInstance:Wait()
	end
	function NetServerScriptSignal:WaitAsync()
		return TS.Promise.defer(function(resolve)
			local result = { self.signalInstance:Wait() }
			resolve(result)
		end)
	end
	function NetServerScriptSignal:GetCount()
		return #self.connections
	end
	function NetServerScriptSignal:DisconnectAt(index)
		local connection = self.connections[index + 1]
		if connection then
			connection:Disconnect()
			table.remove(self.connections, index + 1)
		end
		if #self.connections == 0 then
			self.defaultConnection = self.signalInstance:Connect(self.defaultConnectionDelegate)
		end
	end
	function NetServerScriptSignal:DisconnectAll()
		for _, connection in ipairs(self.connections) do
			connection:Disconnect()
		end
		table.clear(self.connections)
		for ref in pairs(self.connectionRefs) do
			ref.Connected = false
		end
		table.clear(self.connectionRefs)
		self.defaultConnection = self.signalInstance:Connect(self.defaultConnectionDelegate)
	end
end
return {
	NetServerScriptSignal = NetServerScriptSignal,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="273">
                  <Properties>
                    <string name="Name">ServerAsyncFunction</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local findOrCreateRemote = _internal.findOrCreateRemote
local IS_CLIENT = _internal.IS_CLIENT
local MiddlewareEvent = TS.import(script, script.Parent, "MiddlewareEvent").default
local CollectionService = game:GetService("CollectionService")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local function isEventArgs(value)
	if #value < 2 then
		return false
	end
	local _binding = value
	local eventId = _binding[1]
	local data = _binding[2]
	return type(eventId) == "string" and type(data) == "table"
end
--[[
	*
	* An asynchronous function for two way communication between the client and server
]]
local ServerAsyncFunction
do
	local super = MiddlewareEvent
	ServerAsyncFunction = setmetatable({}, {
		__tostring = function()
			return "ServerAsyncFunction"
		end,
		__index = super,
	})
	ServerAsyncFunction.__index = ServerAsyncFunction
	function ServerAsyncFunction.new(...)
		local self = setmetatable({}, ServerAsyncFunction)
		return self:constructor(...) or self
	end
	function ServerAsyncFunction:constructor(name, middlewares, configuration)
		if middlewares == nil then
			middlewares = {}
		end
		super.constructor(self, middlewares)
		self.configuration = configuration
		self.timeout = 10
		self.listeners = {}
		self.instance = findOrCreateRemote("AsyncRemoteFunction", name, function(instance)
			-- Default connection
			self.defaultHook = instance.OnServerEvent:Connect(ServerAsyncFunction.DefaultEventHook)
			CollectionService:AddTag(instance, "NetDefaultListener")
		end)
		local _arg0 = not IS_CLIENT
		assert(_arg0, "Cannot create a NetServerAsyncFunction on the client!")
	end
	function ServerAsyncFunction:GetInstance()
		return self.instance
	end
	function ServerAsyncFunction:SetCallTimeout(timeout)
		local _arg0 = timeout > 0
		assert(_arg0, "timeout must be a positive number")
		self.timeout = timeout
		return self
	end
	function ServerAsyncFunction:GetCallTimeout()
		return self.timeout
	end
	function ServerAsyncFunction:SetCallback(callback)
		if self.defaultHook ~= nil then
			self.defaultHook:Disconnect()
			self.defaultHook = nil
			CollectionService:RemoveTag(self.instance, "NetDefaultListener")
		end
		if self.connector then
			self.connector:Disconnect()
			self.connector = nil
		end
		local remoteId = self.instance.Name
		local microprofile = self.configuration.MicroprofileCallbacks
		self.connector = self.instance.OnServerEvent:Connect(TS.async(function(player, ...)
			local args = { ... }
			if microprofile then
				debug.profilebegin("Net: " .. remoteId)
			end
			if isEventArgs(args) then
				local _binding = args
				local eventId = _binding[1]
				local data = _binding[2]
				local _result = self:_processMiddleware(callback)
				if _result ~= nil then
					_result = _result(player, unpack(data))
				end
				local result = _result
				if TS.Promise.is(result) then
					local _arg0 = function(promiseResult)
						self.instance:FireClient(player, eventId, promiseResult)
					end
					result:andThen(_arg0):catch(function(err)
						warn("[rbx-net] Failed to send response to client: " .. err)
					end)
				else
					self.instance:FireClient(player, eventId, result)
				end
			else
				warn("[rbx-net-async] Recieved message without eventId")
			end
		end))
	end
	ServerAsyncFunction.CallPlayerAsync = TS.async(function(self, player, ...)
		local args = { ... }
		local id = HttpService:GenerateGUID(false)
		local _fn = self.instance
		local _object = {}
		for _k, _v in pairs(args) do
			_object[_k] = _v
		end
		_fn:FireClient(player, id, _object)
		return TS.Promise.new(function(resolve, reject)
			local startTime = tick()
			local connection
			connection = self.instance.OnServerEvent:Connect(function(fromPlayer, ...)
				local recvArgs = { ... }
				local _binding = recvArgs
				local eventId = _binding[1]
				local data = _binding[2]
				if type(eventId) == "string" and data ~= nil then
					if player == player and eventId == id then
						connection:Disconnect()
						resolve(data)
					end
				end
			end)
			local _listeners = self.listeners
			local _arg1 = {
				connection = connection,
				timeout = self.timeout,
			}
			_listeners[id] = _arg1
			repeat
				do
					RunService.Stepped:Wait()
				end
			until not (connection.Connected and tick() < startTime + self.timeout)
			self.listeners[id] = nil
			if tick() >= startTime and connection.Connected then
				connection:Disconnect()
				reject("Request to client timed out")
			end
		end)
	end)
	ServerAsyncFunction.DefaultEventHook = function(player, ...)
		local args = { ... }
	end
end
local default = ServerAsyncFunction
return {
	default = default,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="274">
                  <Properties>
                    <string name="Name">ServerEvent</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local findOrCreateRemote = _internal.findOrCreateRemote
local IS_CLIENT = _internal.IS_CLIENT
local IS_RUNNING = _internal.IS_RUNNING
local MiddlewareEvent = TS.import(script, script.Parent, "MiddlewareEvent").default
local NetServerScriptSignal = TS.import(script, script.Parent, "NetServerScriptSignal").NetServerScriptSignal
--[[
	*
	* Interface for server listening events
]]
--[[
	*
	* Interface for server sender events
]]
local ServerEvent
do
	local super = MiddlewareEvent
	ServerEvent = setmetatable({}, {
		__tostring = function()
			return "ServerEvent"
		end,
		__index = super,
	})
	ServerEvent.__index = ServerEvent
	function ServerEvent.new(...)
		local self = setmetatable({}, ServerEvent)
		return self:constructor(...) or self
	end
	function ServerEvent:constructor(name, middlewares, configuration)
		if middlewares == nil then
			middlewares = {}
		end
		local _array = {}
		local _length = #_array
		local _middlewaresLength = #middlewares
		table.move(middlewares, 1, _middlewaresLength, _length + 1, _array)
		_length += _middlewaresLength
		local _array_1 = (configuration.ServerGlobalMiddleware or {})
		table.move(_array_1, 1, #_array_1, _length + 1, _array)
		super.constructor(self, _array)
		self.configuration = configuration
		local _arg0 = not IS_CLIENT
		assert(_arg0, "Cannot create a NetServerEvent on the client!")
		self.instance = findOrCreateRemote("RemoteEvent", name)
		self.connection = NetServerScriptSignal.new(self.instance.OnServerEvent, self.instance)
	end
	function ServerEvent:GetInstance()
		return self.instance
	end
	function ServerEvent:Connect(callback)
		local remoteId = self.instance.Name
		local microprofile = self.configuration.MicroprofileCallbacks
		return self.connection:Connect(function(player, ...)
			local args = { ... }
			if microprofile then
				debug.profilebegin("Net: " .. remoteId)
			end
			local _result = self:_processMiddleware(callback)
			if _result ~= nil then
				_result(player, unpack(args))
			end
		end)
	end
	function ServerEvent:SendToAllPlayers(...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		self.instance:FireAllClients(unpack(args))
	end
	function ServerEvent:SendToAllPlayersExcept(blacklist, ...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		local Players = game:GetService("Players")
		if typeof(blacklist) == "Instance" then
			local _exp = Players:GetPlayers()
			local _arg0 = function(p)
				return p ~= blacklist
			end
			-- ▼ ReadonlyArray.filter ▼
			local _newValue = {}
			local _length = 0
			for _k, _v in ipairs(_exp) do
				if _arg0(_v, _k - 1, _exp) == true then
					_length += 1
					_newValue[_length] = _v
				end
			end
			-- ▲ ReadonlyArray.filter ▲
			local otherPlayers = _newValue
			for _, player in ipairs(otherPlayers) do
				self.instance:FireClient(player, unpack(args))
			end
		elseif type(blacklist) == "table" then
			for _, player in ipairs(Players:GetPlayers()) do
				if (table.find(blacklist, player) or 0) - 1 == -1 then
					self.instance:FireClient(player, unpack(args))
				end
			end
		end
	end
	function ServerEvent:SendToPlayer(player, ...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		self.instance:FireClient(player, unpack(args))
	end
	function ServerEvent:SendToPlayers(players, ...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		for _, player in ipairs(players) do
			self:SendToPlayer(player, unpack(args))
		end
	end
end
return {
	default = ServerEvent,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="275">
                  <Properties>
                    <string name="Name">ServerFunction</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local findOrCreateRemote = _internal.findOrCreateRemote
local IS_SERVER = _internal.IS_SERVER
local MiddlewareFunction = TS.import(script, script.Parent, "MiddlewareFunction").default
local CollectionService = game:GetService("CollectionService")
local ServerFunction
do
	local super = MiddlewareFunction
	ServerFunction = setmetatable({}, {
		__tostring = function()
			return "ServerFunction"
		end,
		__index = super,
	})
	ServerFunction.__index = ServerFunction
	function ServerFunction.new(...)
		local self = setmetatable({}, ServerFunction)
		return self:constructor(...) or self
	end
	function ServerFunction:constructor(name, middlewares, configuration)
		if middlewares == nil then
			middlewares = {}
		end
		super.constructor(self, middlewares)
		self.configuration = configuration
		self.instance = findOrCreateRemote("RemoteFunction", name, function(instance)
			-- Default listener
			instance.OnServerInvoke = ServerFunction.DefaultFunctionHook
			CollectionService:AddTag(instance, "NetDefaultListener")
		end)
		assert(IS_SERVER, "Cannot create a Net.ServerFunction on the Client!")
	end
	function ServerFunction:GetInstance()
		return self.instance
	end
	function ServerFunction:SetCallback(callback)
		if CollectionService:HasTag(self.instance, "NetDefaultListener") then
			CollectionService:RemoveTag(self.instance, "NetDefaultListener")
		end
		self.instance.OnServerInvoke = function(player, ...)
			local args = { ... }
			local _result = self:_processMiddleware(callback)
			if _result ~= nil then
				_result = _result(player, unpack(args))
			end
			local result = _result
			if TS.Promise.is(result) then
				warn("[rbx-net] WARNING: Promises should be used with an AsyncFunction!")
				local success, value = result:await()
				if success then
					return value
				else
					error(value)
				end
			end
			return result
		end
	end
	ServerFunction.DefaultFunctionHook = function()
		-- TODO: 2.2 make usable for analytics?
		-- Although, unlike `Event`, this will need to be part of `SetCallback`'s stuff.
		return nil
	end
end
return {
	default = ServerFunction,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="276">
                  <Properties>
                    <string name="Name">ServerMessagingEvent</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _ExperienceBroadcastEvent = TS.import(script, script.Parent.Parent, "messaging", "ExperienceBroadcastEvent")
local ExperienceBroadcastEvent = _ExperienceBroadcastEvent.default
local isSubscriptionMessage = _ExperienceBroadcastEvent.isSubscriptionMessage
local _internal = TS.import(script, script.Parent.Parent, "internal")
local getGlobalRemote = _internal.getGlobalRemote
local IS_CLIENT = _internal.IS_CLIENT
local isLuaTable = _internal.isLuaTable
local ServerEvent = TS.import(script, script.Parent, "ServerEvent").default
local Players = game:GetService("Players")
local function isTargetedSubscriptionMessage(value)
	if isSubscriptionMessage(value) then
		if isLuaTable(value.Data) then
			return value.Data.InnerData ~= nil
		end
	end
	return false
end
--[[
	*
	* Similar to a ServerEvent, but works across all servers.
]]
local ServerMessagingEvent
do
	ServerMessagingEvent = setmetatable({}, {
		__tostring = function()
			return "ServerMessagingEvent"
		end,
	})
	ServerMessagingEvent.__index = ServerMessagingEvent
	function ServerMessagingEvent.new(...)
		local self = setmetatable({}, ServerMessagingEvent)
		return self:constructor(...) or self
	end
	function ServerMessagingEvent:constructor(name, config)
		self.instance = ServerEvent.new(getGlobalRemote(name), nil, config)
		self.event = ExperienceBroadcastEvent.new(name)
		local _arg0 = not IS_CLIENT
		assert(_arg0, "Cannot create a Net.GlobalServerEvent on the Client!")
		self.eventHandler = self.event:Connect(function(message)
			if isTargetedSubscriptionMessage(message) then
				self:recievedMessage(message.Data)
			else
				warn("[rbx-net] Recieved malformed message for ServerGameEvent: " .. name)
			end
		end)
	end
	function ServerMessagingEvent:getPlayersMatchingId(matching)
		if type(matching) == "number" then
			return Players:GetPlayerByUserId(matching)
		else
			local players = {}
			for _, id in ipairs(matching) do
				local player = Players:GetPlayerByUserId(id)
				if player then
					table.insert(players, player)
				end
			end
			return players
		end
	end
	function ServerMessagingEvent:recievedMessage(message)
		if message.TargetIds then
			local players = self:getPlayersMatchingId(message.TargetIds)
			if players then
				self.instance:SendToPlayers(players, unpack(message.InnerData))
			end
		elseif message.TargetId ~= nil then
			local player = self:getPlayersMatchingId(message.TargetId)
			if player then
				self.instance:SendToPlayer(player, unpack(message.InnerData))
			end
		else
			self.instance:SendToAllPlayers(unpack(message.InnerData))
		end
	end
	function ServerMessagingEvent:Connect(serverListener)
		return self.event:Connect(function(data, sent)
			serverListener(data, sent)
		end)
	end
	function ServerMessagingEvent:SendToAllServers(...)
		local args = { ... }
		self.event:SendToAllServers({
			InnerData = args,
		})
	end
	function ServerMessagingEvent:SendToServer(jobId, ...)
		local args = { ... }
		self.event:SendToServer(jobId, {
			InnerData = args,
		})
	end
	function ServerMessagingEvent:SendToUserId(userId, ...)
		local args = { ... }
		local player = Players:GetPlayerByUserId(userId)
		-- If the player exists in this instance, just send it straight to them.
		if player then
			self.instance:SendToPlayer(player, unpack(args))
		else
			self.event:SendToAllServers({
				InnerData = args,
				TargetId = userId,
			})
		end
	end
	function ServerMessagingEvent:SendToUserIds(userIds, ...)
		local args = { ... }
		-- Check to see if any of these users are in this server first, and handle accordingly.
		for _, targetId in ipairs(userIds) do
			local player = Players:GetPlayerByUserId(targetId)
			if player then
				self.instance:SendToPlayer(player, unpack(args))
				table.remove(userIds, targetId + 1)
			end
		end
		if #userIds > 0 then
			self.event:SendToAllServers({
				InnerData = args,
				TargetIds = userIds,
			})
		end
	end
end
return {
	default = ServerMessagingEvent,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="277">
            <Properties>
              <string name="Name">profileservice</string>
            </Properties>
            <Item class="ModuleScript" referent="278">
              <Properties>
                <string name="Name">src</string>
                <string name="Source">-- local Madwork = _G.Madwork
--[[
{Madwork}

-[ProfileService]---------------------------------------
	(STANDALONE VERSION)
	DataStore profiles - universal session-locked savable table API
	
	Official documentation:
		https://madstudioroblox.github.io/ProfileService/

	DevForum discussion:
		https://devforum.roblox.com/t/ProfileService/667805
	
	WARNINGS FOR "Profile.Data" VALUES:
	 	! Do not create numeric tables with gaps - attempting to replicate such tables will result in an error;
		! Do not create mixed tables (some values indexed by number and others by string key), as only
		     the data indexed by number will be replicated.
		! Do not index tables by anything other than numbers and strings.
		! Do not reference Roblox Instances
		! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing
		! Do not reference functions
		
	WARNING: Calling ProfileStore:LoadProfileAsync() with a "profile_key" which wasn't released in the SAME SESSION will result
		in an error! If you want to "ProfileStore:LoadProfileAsync()" instead of using the already loaded profile, :Release()
		the old Profile object.
		
	Members:
	
		ProfileService.ServiceLocked         [bool]
		
		ProfileService.IssueSignal           [ScriptSignal] (error_message, profile_store_name, profile_key)
		ProfileService.CorruptionSignal      [ScriptSignal] (profile_store_name, profile_key)
		ProfileService.CriticalStateSignal   [ScriptSignal] (is_critical_state)
	
	Functions:
	
		ProfileService.GetProfileStore(profile_store_index, profile_template) --> [ProfileStore]
			profile_store_index   [string] -- DataStore name
			OR
			profile_store_index   [table]: -- Allows the developer to define more GlobalDataStore variables
				{
					Name = "StoreName", -- [string] -- DataStore name
					-- Optional arguments:
					Scope = "StoreScope", -- [string] -- DataStore scope
				}
			profile_template      [table] -- Profiles will default to given table (hard-copy) when no data was saved previously

		ProfileService.IsLive() --> [bool] -- (CAN YIELD!!!)
			-- Returns true if ProfileService is connected to live Roblox DataStores
				
	Members [ProfileStore]:
	
		ProfileStore.Mock   [ProfileStore] -- Reflection of ProfileStore methods, but the methods will use a mock DataStore
		
	Methods [ProfileStore]:
	
		ProfileStore:LoadProfileAsync(profile_key, not_released_handler) --> [Profile] or nil -- not_released_handler(place_id, game_job_id)
			profile_key            [string] -- DataStore key
			not_released_handler   nil or []: -- Defaults to "ForceLoad"
				[string] "ForceLoad" -- Force loads profile on first call
				OR
				[string] "Steal" -- Steals the profile ignoring it's session lock
				OR
				[function] (place_id, game_job_id) --> [string] "Repeat", "Cancel", "ForceLoad" or "Steal"
					place_id      [number] or nil
					game_job_id   [string] or nil

				-- not_released_handler [function] will be triggered in cases where the profile is not released by a session. This
				--	function may yield for as long as desirable and must return one of three string values:

						["Repeat"] - ProfileService will repeat the profile loading proccess and may trigger the release handler again
						["Cancel"] - ProfileStore:LoadProfileAsync() will immediately return nil
						["ForceLoad"] - ProfileService will repeat the profile loading call, but will return Profile object afterwards
							and release the profile for another session that has loaded the profile
						["Steal"] - The profile will usually be loaded immediately, ignoring an existing remote session lock and applying
							a session lock for this session.

		ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler) --> [GlobalUpdates] or nil
			-- Returns GlobalUpdates object if update was successful, otherwise returns nil
			profile_key      [string] -- DataStore key
			update_handler   [function] (global_updates [GlobalUpdates])
			
		ProfileStore:ViewProfileAsync(profile_key, version) --> [Profile] or nil
			-- Reads profile without requesting a session lock; Data will not be saved and profile doesn't need to be released
			profile_key   [string] -- DataStore key
			version       nil or [string] -- DataStore key version

		ProfileStore:ProfileVersionQuery(profile_key, sort_direction, min_date, max_date) --> [ProfileVersionQuery]
			profile_key      [string]
			sort_direction   nil or [Enum.SortDirection]
			min_date         nil or [DateTime]
			max_date         nil or [DateTime]
			
		ProfileStore:WipeProfileAsync(profile_key) --> is_wipe_successful [bool]
			-- Completely wipes out profile data from the DataStore / mock DataStore with no way to recover it.
						
		* Parameter description for "ProfileStore:GlobalUpdateProfileAsync()":
		
			profile_key      [string] -- DataStore key
			update_handler   [function] (GlobalUpdates) -- This function gains access to GlobalUpdates object methods
				(update_handler can't yield)

	Methods [ProfileVersionQuery]:

		ProfileVersionQuery:NextAsync() --> [Profile] or nil -- (Yields)
			-- Returned profile has the same rules as profile returned by :ViewProfileAsync()
		
	Members [Profile]:
	
		Profile.Data              [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.MetaData          [table] (Read-only) -- Information about this profile
		
			Profile.MetaData.ProfileCreateTime   [number] (Read-only) -- os.time() timestamp of profile creation
			Profile.MetaData.SessionLoadCount    [number] (Read-only) -- Amount of times the profile was loaded
			Profile.MetaData.ActiveSession       [table] (Read-only) {place_id, game_job_id} / nil -- Set to a session link if a
				game session is currently having this profile loaded; nil if released
			Profile.MetaData.MetaTags            [table] {["tag_name"] = tag_value, ...} -- Saved and auto-saved just like Profile.Data
			Profile.MetaData.MetaTagsLatest      [table] (Read-only) -- Latest version of MetaData.MetaTags that was definetly saved to DataStore
				(You can use Profile.MetaData.MetaTagsLatest for product purchase save confirmation, but create a system to clear old tags after
				they pile up)

		Profile.MetaTagsUpdated   [ScriptSignal] (meta_tags_latest) -- Fires after every auto-save, after
			--	Profile.MetaData.MetaTagsLatest has been updated with the version that's guaranteed to be saved;
			--  .MetaTagsUpdated will fire regardless of whether .MetaTagsLatest changed after update;
			--	.MetaTagsUpdated may fire after the Profile is released - changes to Profile.Data are not saved
			--	after release.

		Profile.RobloxMetaData    [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.UserIds           [table] -- (Read-only) -- {user_id [number], ...} -- User ids associated with this profile

		Profile.KeyInfo           [DataStoreKeyInfo]
		Profile.KeyInfoUpdated    [ScriptSignal] (key_info [DataStoreKeyInfo])
		
		Profile.GlobalUpdates     [GlobalUpdates]
		
	Methods [Profile]:
	
		-- SAFE METHODS - Will not error after profile expires:
		Profile:IsActive() --> [bool] -- Returns true while the profile is active and can be written to
			
		Profile:GetMetaTag(tag_name) --> value [any]
			tag_name   [string]
		
		Profile:Reconcile() -- Fills in missing (nil) [string_key] = [value] pairs to the Profile.Data structure
		
		Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil)
			-- WARNING: Profiles can be released externally if another session force-loads
			--	this profile - use :ListenToRelease() to handle player leaving cleanup.
			
		Profile:Release() -- Call after the session has finished working with this profile
			e.g., after the player leaves (Profile object will become expired) (Does not yield)

		Profile:ListenToHopReady(listener) --> [ScriptConnection] () -- Passed listener will be executed after the releasing UpdateAsync call finishes;
			--	Wrap universe teleport requests with this method AFTER releasing the profile to improve session lock sharing between universe places;
			--  :ListenToHopReady() will usually call the listener in around a second, but may ocassionally take up to 7 seconds when a release happens
			--	next to an auto-update in regular usage scenarios.

		Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)
			user_id   [number]

		Profile:RemoveUserId(user_id) -- Unassociates user_id with profile (safe function)
			user_id   [number]

		Profile:Identify() --> [string] -- Returns a string containing DataStore name, scope and key; Used for debug;
			-- Example return: "[Store:"GameData";Scope:"Live";Key:"Player_2312310"]"
		
		Profile:SetMetaTag(tag_name, value) -- Equivalent of Profile.MetaData.MetaTags[tag_name] = value
			tag_name   [string]
			value      [any]
		
		Profile:Save() -- Call to quickly progress global update state or to speed up save validation processes (Does not yield)

		-- VIEW-MODE ONLY:

		Profile:ClearGlobalUpdates() -- Clears all global updates data from a profile payload

		Profile:OverwriteAsync() -- (Yields) Saves the profile payload to the DataStore and removes the session lock
		
	Methods [GlobalUpdates]:
	
	-- ALWAYS PUBLIC:
		GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data [table]}, ...}
		GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data [table]}, ...}
		
	-- ONLY WHEN FROM "Profile.GlobalUpdates":
		GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] (update_id, update_data)
			update_data   [table]
		GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] (update_id, update_data)
			update_data   [table]
		GlobalUpdates:LockActiveUpdate(update_id)  -- WARNING: will error after profile expires
		GlobalUpdates:ClearLockedUpdate(update_id) -- WARNING: will error after profile expires
		
	-- EXPOSED TO "update_handler" DURING ProfileStore:GlobalUpdateProfileAsync() CALL
		GlobalUpdates:AddActiveUpdate(update_data)
			update_data   [table]
		GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
			update_data   [table]
		GlobalUpdates:ClearActiveUpdate(update_id)
		
--]]

local SETTINGS = {

	AutoSaveProfiles = 30, -- Seconds (This value may vary - ProfileService will split the auto save load evenly in the given time)
	RobloxWriteCooldown = 7, -- Seconds between successive DataStore calls for the same key
	ForceLoadMaxSteps = 8, -- Steps taken before ForceLoad request steals the active session for a profile
	AssumeDeadSessionLock = 30 * 60, -- (seconds) If a profile hasn't been updated for 30 minutes, assume the session lock is dead
		-- As of writing, os.time() is not completely reliable, so we can only assume session locks are dead after a significant amount of time.
	
	IssueCountForCriticalState = 5, -- Issues to collect to announce critical state
	IssueLast = 120, -- Seconds
	CriticalStateLast = 120, -- Seconds
	
	MetaTagsUpdatedValues = { -- Technical stuff - do not alter
		ProfileCreateTime = true,
		SessionLoadCount = true,
		ActiveSession = true,
		ForceLoadSession = true,
		LastUpdate = true,
	},
	
}

local Madwork -- Standalone Madwork reference for portable version of ProfileService
do

	local MadworkScriptSignal = {}

	local FreeRunnerThread = nil
	
	local function AcquireRunnerThreadAndCallEventHandler(fn, ...)
		local acquired_runner_thread = FreeRunnerThread
		FreeRunnerThread = nil
		fn(...)
		FreeRunnerThread = acquired_runner_thread
	end
	
	local function RunEventHandlerInFreeThread(...)
		AcquireRunnerThreadAndCallEventHandler(...)
		while true do
			AcquireRunnerThreadAndCallEventHandler(coroutine.yield())
		end
	end
	
	-- ScriptConnection object:

	local ScriptConnection = {
		--[[
			_listener = listener,
			_script_signal = script_signal,
			_disconnect_listener = disconnect_listener,
			_disconnect_param = disconnect_param,
			
			_next = next_script_connection,
			_is_connected = is_connected,
		--]]
	}
	ScriptConnection.__index = ScriptConnection

	function ScriptConnection:Disconnect()

		if self._is_connected == false then
			return
		end

		self._is_connected = false
		self._script_signal._listener_count -= 1

		if self._script_signal._head == self then
			self._script_signal._head = self._next
		else
			local prev = self._script_signal._head
			while prev ~= nil and prev._next ~= self do
				prev = prev._next
			end
			if prev ~= nil then
				prev._next = self._next
			end
		end

		if self._disconnect_listener ~= nil then
			if not FreeRunnerThread then
				FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
			end
			task.spawn(FreeRunnerThread, self._disconnect_listener, self._disconnect_param)
			self._disconnect_listener = nil
		end

	end
	
	-- ScriptSignal object:

	local ScriptSignal = {
		--[[
			_head = nil,
			_listener_count = 0,
		--]]
	}
	ScriptSignal.__index = ScriptSignal

	function ScriptSignal:Connect(listener, disconnect_listener, disconnect_param) --> [ScriptConnection]

		local script_connection = {
			_listener = listener,
			_script_signal = self,
			_disconnect_listener = disconnect_listener,
			_disconnect_param = disconnect_param,

			_next = self._head,
			_is_connected = true,
		}
		setmetatable(script_connection, ScriptConnection)

		self._head = script_connection
		self._listener_count += 1

		return script_connection

	end

	function ScriptSignal:GetListenerCount() --> [number]
		return self._listener_count
	end

	function ScriptSignal:Fire(...)
		local item = self._head
		while item ~= nil do
			if item._is_connected == true then
				if not FreeRunnerThread then
					FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
				end
				task.spawn(FreeRunnerThread, item._listener, ...)
			end
			item = item._next
		end
	end

	function ScriptSignal:FireUntil(continue_callback, ...)
		local item = self._head
		while item ~= nil do
			if item._is_connected == true then
				item._listener(...)
				if continue_callback() ~= true then
					return
				end
			end
			item = item._next
		end
	end

	function MadworkScriptSignal.NewScriptSignal() --> [ScriptSignal]
		return {
			_head = nil,
			_listener_count = 0,
			Connect = ScriptSignal.Connect,
			GetListenerCount = ScriptSignal.GetListenerCount,
			Fire = ScriptSignal.Fire,
			FireUntil = ScriptSignal.FireUntil,
		}
	end

	-- Madwork framework namespace:
	
	Madwork = {
		NewScriptSignal = MadworkScriptSignal.NewScriptSignal,
		ConnectToOnClose = function(task, run_in_studio_mode)
			if game:GetService("RunService"):IsStudio() == false or run_in_studio_mode == true then
				game:BindToClose(task)
			end
		end,
	}

end

----- Service Table -----

local ProfileService = {

	ServiceLocked = false, -- Set to true once the server is shutting down

	IssueSignal = Madwork.NewScriptSignal(), -- (error_message, profile_store_name, profile_key) -- Fired when a DataStore API call throws an error
	CorruptionSignal = Madwork.NewScriptSignal(), -- (profile_store_name, profile_key) -- Fired when DataStore key returns a value that has
	-- all or some of it's profile components set to invalid data types. E.g., accidentally setting Profile.Data to a noon table value

	CriticalState = false, -- Set to true while DataStore service is throwing too many errors
	CriticalStateSignal = Madwork.NewScriptSignal(), -- (is_critical_state) -- Fired when CriticalState is set to true
	-- (You may alert players with this, or set up analytics)

	ServiceIssueCount = 0,

	_active_profile_stores = {}, -- {profile_store, ...}

	_auto_save_list = {}, -- {profile, ...} -- loaded profile table which will be circularly auto-saved

	_issue_queue = {}, -- [table] {issue_time, ...}
	_critical_state_start = 0, -- [number] 0 = no critical state / os.clock() = critical state start

	-- Debug:
	_mock_data_store = {},
	_user_mock_data_store = {},

	_use_mock_data_store = false,

}

--[[
	Saved profile structure:
	
	DataStoreProfile = {
		Data = {},
		MetaData = {
			ProfileCreateTime = 0,
			SessionLoadCount = 0,
			ActiveSession = {place_id, game_job_id} / nil,
			ForceLoadSession = {place_id, game_job_id} / nil,
			MetaTags = {},
			LastUpdate = 0, -- os.time()
		},
		RobloxMetaData = {},
		UserIds = {},
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}
	
	OR
	
	DataStoreProfile = {
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}
--]]

----- Private Variables -----

local ActiveProfileStores = ProfileService._active_profile_stores
local AutoSaveList = ProfileService._auto_save_list
local IssueQueue = ProfileService._issue_queue

local DataStoreService = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")

local PlaceId = game.PlaceId
local JobId = game.JobId

local AutoSaveIndex = 1 -- Next profile to auto save
local LastAutoSave = os.clock()

local LoadIndex = 0

local ActiveProfileLoadJobs = 0 -- Number of active threads that are loading in profiles
local ActiveProfileSaveJobs = 0 -- Number of active threads that are saving profiles

local CriticalStateStart = 0 -- os.clock()

local IsStudio = RunService:IsStudio()
local IsLiveCheckActive = false

local UseMockDataStore = false
local MockDataStore = ProfileService._mock_data_store -- Mock data store used when API access is disabled

local UserMockDataStore = ProfileService._user_mock_data_store -- Separate mock data store accessed via ProfileStore.Mock
local UseMockTag = {}

local CustomWriteQueue = {
	--[[
		[store] = {
			[key] = {
				LastWrite = os.clock(),
				Queue = {callback, ...},
				CleanupJob = nil,
			},
			...
		},
		...
	--]]
}

----- Utils -----

local function DeepCopyTable(t)
	local copy = {}
	for key, value in pairs(t) do
		if type(value) == "table" then
			copy[key] = DeepCopyTable(value)
		else
			copy[key] = value
		end
	end
	return copy
end

local function ReconcileTable(target, template)
	for k, v in pairs(template) do
		if type(k) == "string" then -- Only string keys will be reconciled
			if target[k] == nil then
				if type(v) == "table" then
					target[k] = DeepCopyTable(v)
				else
					target[k] = v
				end
			elseif type(target[k]) == "table" and type(v) == "table" then
				ReconcileTable(target[k], v)
			end
		end
	end
end

----- Private functions -----

local function IdentifyProfile(store_name, store_scope, key)
	return string.format(
		"[Store:\"%s\";%sKey:\"%s\"]",
		store_name,
		store_scope ~= nil and string.format("Scope:\"%s\";", store_scope) or "",
		key
	)
end

local function CustomWriteQueueCleanup(store, key)
	if CustomWriteQueue[store] ~= nil then
		CustomWriteQueue[store][key] = nil
		if next(CustomWriteQueue[store]) == nil then
			CustomWriteQueue[store] = nil
		end
	end
end

local function CustomWriteQueueMarkForCleanup(store, key)
	if CustomWriteQueue[store] ~= nil then
		if CustomWriteQueue[store][key] ~= nil then

			local queue_data = CustomWriteQueue[store][key]
			local queue = queue_data.Queue

			if queue_data.CleanupJob == nil then

				queue_data.CleanupJob = RunService.Heartbeat:Connect(function()
					if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and #queue == 0 then
						queue_data.CleanupJob:Disconnect()
						CustomWriteQueueCleanup(store, key)
					end
				end)

			end

		elseif next(CustomWriteQueue[store]) == nil then
			CustomWriteQueue[store] = nil
		end
	end
end

local function CustomWriteQueueAsync(callback, store, key) --> ... -- Passed return from callback

	if CustomWriteQueue[store] == nil then
		CustomWriteQueue[store] = {}
	end
	if CustomWriteQueue[store][key] == nil then
		CustomWriteQueue[store][key] = {LastWrite = 0, Queue = {}, CleanupJob = nil}
	end

	local queue_data = CustomWriteQueue[store][key]
	local queue = queue_data.Queue

	-- Cleanup job:

	if queue_data.CleanupJob ~= nil then
		queue_data.CleanupJob:Disconnect()
		queue_data.CleanupJob = nil
	end

	-- Queue logic:

	if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and #queue == 0 then
		queue_data.LastWrite = os.clock()
		return callback()
	else
		table.insert(queue, callback)
		while true do
			if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and queue[1] == callback then
				table.remove(queue, 1)
				queue_data.LastWrite = os.clock()
				return callback()
			end
			task.wait()
		end
	end

end

local function IsCustomWriteQueueEmptyFor(store, key) --> is_empty [bool]
	local lookup = CustomWriteQueue[store]
	if lookup ~= nil then
		lookup = lookup[key]
		return lookup == nil or #lookup.Queue == 0
	end
	return true
end

local function WaitForLiveAccessCheck() -- This function was created to prevent the ProfileService module yielding execution when required
	while IsLiveCheckActive == true do
		task.wait()
	end
end

local function WaitForPendingProfileStore(profile_store)
	while profile_store._is_pending == true do
		task.wait()
	end
end

local function RegisterIssue(error_message, store_name, store_scope, profile_key) -- Called when a DataStore API call errors
	warn("[ProfileService]: DataStore API error " .. IdentifyProfile(store_name, store_scope, profile_key) .. " - \"" .. tostring(error_message) .. "\"")
	table.insert(IssueQueue, os.clock()) -- Adding issue time to queue
	ProfileService.IssueSignal:Fire(tostring(error_message), store_name, profile_key)
end

local function RegisterCorruption(store_name, store_scope, profile_key) -- Called when a corrupted profile is loaded
	warn("[ProfileService]: Resolved profile corruption " .. IdentifyProfile(store_name, store_scope, profile_key))
	ProfileService.CorruptionSignal:Fire(store_name, profile_key)
end

local function NewMockDataStoreKeyInfo(params)

	local version_id_string = tostring(params.VersionId or 0)
	local meta_data = params.MetaData or {}
	local user_ids = params.UserIds or {}

	return {
		CreatedTime = params.CreatedTime,
		UpdatedTime = params.UpdatedTime,
		Version = string.rep("0", 16) .. "."
			.. string.rep("0", 10 - string.len(version_id_string)) .. version_id_string
			.. "." .. string.rep("0", 16) .. "." .. "01",

		GetMetadata = function()
			return DeepCopyTable(meta_data)
		end,

		GetUserIds = function()
			return DeepCopyTable(user_ids)
		end,
	}

end

local function MockUpdateAsync(mock_data_store, profile_store_name, key, transform_function, is_get_call) --> loaded_data, key_info

	local profile_store = mock_data_store[profile_store_name]

	if profile_store == nil then
		profile_store = {}
		mock_data_store[profile_store_name] = profile_store
	end

	local epoch_time = math.floor(os.time() * 1000)
	local mock_entry = profile_store[key]
	local mock_entry_was_nil = false

	if mock_entry == nil then
		mock_entry_was_nil = true
		if is_get_call ~= true then
			mock_entry = {
				Data = nil,
				CreatedTime = epoch_time,
				UpdatedTime = epoch_time,
				VersionId = 0,
				UserIds = {},
				MetaData = {},
			}
			profile_store[key] = mock_entry
		end
	end

	local mock_key_info = mock_entry_was_nil == false and NewMockDataStoreKeyInfo(mock_entry) or nil

	local transform, user_ids, roblox_meta_data = transform_function(mock_entry and mock_entry.Data, mock_key_info)

	if transform == nil then
		return nil
	else
		if mock_entry ~= nil and is_get_call ~= true then
			mock_entry.Data = transform
			mock_entry.UserIds = DeepCopyTable(user_ids or {})
			mock_entry.MetaData = DeepCopyTable(roblox_meta_data or {})
			mock_entry.VersionId += 1
			mock_entry.UpdatedTime = epoch_time
		end

		return DeepCopyTable(transform), mock_entry ~= nil and NewMockDataStoreKeyInfo(mock_entry) or nil
	end

end

local function IsThisSession(session_tag)
	return session_tag[1] == PlaceId and session_tag[2] == JobId
end

--[[
update_settings = {
	ExistingProfileHandle = function(latest_data),
	MissingProfileHandle = function(latest_data),
	EditProfile = function(lastest_data),
}
--]]
local function StandardProfileUpdateAsyncDataStore(profile_store, profile_key, update_settings, is_user_mock, is_get_call, version) --> loaded_data, key_info
	local loaded_data, key_info
	local success, error_message = pcall(function()
		local transform_function = function(latest_data)

			local missing_profile = false
			local data_corrupted = false
			local global_updates_data = {0, {}}

			if latest_data == nil then
				missing_profile = true
			elseif type(latest_data) ~= "table" then
				missing_profile = true
				data_corrupted = true
			end

			if type(latest_data) == "table" then
				-- Case #1: Profile was loaded
				if type(latest_data.Data) == "table"
					and type(latest_data.MetaData) == "table"
					and type(latest_data.GlobalUpdates) == "table" then

					latest_data.WasCorrupted = false -- Must be set to false if set previously
					global_updates_data = latest_data.GlobalUpdates
					if update_settings.ExistingProfileHandle ~= nil then
						update_settings.ExistingProfileHandle(latest_data)
					end
					-- Case #2: Profile was not loaded but GlobalUpdate data exists
				elseif latest_data.Data == nil
					and latest_data.MetaData == nil
					and type(latest_data.GlobalUpdates) == "table" then

					latest_data.WasCorrupted = false -- Must be set to false if set previously
					global_updates_data = latest_data.GlobalUpdates or global_updates_data
					missing_profile = true
				else
					missing_profile = true
					data_corrupted = true
				end
			end

			-- Case #3: Profile was not created or corrupted and no GlobalUpdate data exists
			if missing_profile == true then
				latest_data = {
					-- Data = nil,
					-- MetaData = nil,
					GlobalUpdates = global_updates_data,
				}
				if update_settings.MissingProfileHandle ~= nil then
					update_settings.MissingProfileHandle(latest_data)
				end
			end

			-- Editing profile:
			if update_settings.EditProfile ~= nil then
				update_settings.EditProfile(latest_data)
			end

			-- Data corruption handling (Silently override with empty profile) (Also run Case #1)
			if data_corrupted == true then
				latest_data.WasCorrupted = true -- Temporary tag that will be removed on first save
			end

			return latest_data, latest_data.UserIds, latest_data.RobloxMetaData
		end
		if is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock
			loaded_data, key_info = MockUpdateAsync(UserMockDataStore, profile_store._profile_store_lookup, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield
		elseif UseMockDataStore == true then -- Used when API access is disabled
			loaded_data, key_info = MockUpdateAsync(MockDataStore, profile_store._profile_store_lookup, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield
		else
			loaded_data, key_info = CustomWriteQueueAsync(
				function() -- Callback
					if is_get_call == true then
						local get_data, get_key_info
						if version ~= nil then
							local success, error_message = pcall(function()
								get_data, get_key_info = profile_store._global_data_store:GetVersionAsync(profile_key, version)
							end)
							if success == false and type(error_message) == "string" and string.find(error_message, "not valid") ~= nil then
								warn("[ProfileService]: Passed version argument is not valid; Traceback:\n" .. debug.traceback())
							end
						else
							get_data, get_key_info = profile_store._global_data_store:GetAsync(profile_key)
						end
						get_data = transform_function(get_data)
						return get_data, get_key_info
					else
						return profile_store._global_data_store:UpdateAsync(profile_key, transform_function)
					end
				end,
				profile_store._profile_store_lookup, -- Store
				profile_key -- Key
			)
		end
	end)
	if success == true and type(loaded_data) == "table" then
		-- Corruption handling:
		if loaded_data.WasCorrupted == true and is_get_call ~= true then
			RegisterCorruption(
				profile_store._profile_store_name,
				profile_store._profile_store_scope,
				profile_key
			)
		end
		-- Return loaded_data:
		return loaded_data, key_info
	else
		RegisterIssue(
			(error_message ~= nil) and error_message or "Undefined error",
			profile_store._profile_store_name,
			profile_store._profile_store_scope,
			profile_key
		)
		-- Return nothing:
		return nil
	end
end

local function RemoveProfileFromAutoSave(profile)
	local auto_save_index = table.find(AutoSaveList, profile)
	if auto_save_index ~= nil then
		table.remove(AutoSaveList, auto_save_index)
		if auto_save_index &lt; AutoSaveIndex then
			AutoSaveIndex = AutoSaveIndex - 1 -- Table contents were moved left before AutoSaveIndex so move AutoSaveIndex left as well
		end
		if AutoSaveList[AutoSaveIndex] == nil then -- AutoSaveIndex was at the end of the AutoSaveList - reset to 1
			AutoSaveIndex = 1
		end
	end
end

local function AddProfileToAutoSave(profile) -- Notice: Makes sure this profile isn't auto-saved too soon
	-- Add at AutoSaveIndex and move AutoSaveIndex right:
	table.insert(AutoSaveList, AutoSaveIndex, profile)
	if #AutoSaveList > 1 then
		AutoSaveIndex = AutoSaveIndex + 1
	elseif #AutoSaveList == 1 then
		-- First profile created - make sure it doesn't get immediately auto saved:
		LastAutoSave = os.clock()
	end
end

local function ReleaseProfileInternally(profile)
	-- 1) Remove profile object from ProfileService references: --
	-- Clear reference in ProfileStore:
	local profile_store = profile._profile_store
	local loaded_profiles = profile._is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles
	loaded_profiles[profile._profile_key] = nil
	if next(profile_store._loaded_profiles) == nil and next(profile_store._mock_loaded_profiles) == nil then -- ProfileStore has turned inactive
		local index = table.find(ActiveProfileStores, profile_store)
		if index ~= nil then
			table.remove(ActiveProfileStores, index)
		end
	end
	-- Clear auto update reference:
	RemoveProfileFromAutoSave(profile)
	-- 2) Trigger release listeners: --
	local place_id
	local game_job_id
	local active_session = profile.MetaData.ActiveSession
	if active_session ~= nil then
		place_id = active_session[1]
		game_job_id = active_session[2]
	end
	profile._release_listeners:Fire(place_id, game_job_id)
end

local function CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
	local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
	local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
	local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
	-- "old_" or "new_" global_updates_data = {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	for _, new_global_update in ipairs(new_global_updates_data[2]) do
		-- Find old global update with the same update_id:
		local old_global_update
		for _, global_update in ipairs(old_global_updates_data[2]) do
			if global_update[1] == new_global_update[1] then
				old_global_update = global_update
				break
			end
		end
		-- A global update is new when it didn't exist before or its version_id or update_locked state changed:
		local is_new = false
		if old_global_update == nil or new_global_update[2] > old_global_update[2] or new_global_update[3] ~= old_global_update[3] then
			is_new = true
		end
		if is_new == true then
			-- Active global updates:
			if new_global_update[3] == false then
				-- Check if update is not pending to be locked: (Preventing firing new active update listeners more than necessary)
				local is_pending_lock = false
				for _, update_id in ipairs(pending_update_lock) do
					if new_global_update[1] == update_id then
						is_pending_lock = true
						break
					end
				end
				if is_pending_lock == false then
					-- Trigger new active update listeners:
					global_updates_object._new_active_update_listeners:Fire(new_global_update[1], new_global_update[4])
				end
			end
			-- Locked global updates:
			if new_global_update[3] == true then
				-- Check if update is not pending to be cleared: (Preventing firing new locked update listeners after marking a locked update for clearing)
				local is_pending_clear = false
				for _, update_id in ipairs(pending_update_clear) do
					if new_global_update[1] == update_id then
						is_pending_clear = true
						break
					end
				end
				if is_pending_clear == false then
					-- Trigger new locked update listeners:

					global_updates_object._new_locked_update_listeners:FireUntil(
						function()
							-- Check if listener marked the update to be cleared:
							-- Normally there should be only one listener per profile for new locked global updates, but
							-- in case several listeners are connected we will not trigger more listeners after one listener
							-- marks the locked global update to be cleared.
							return table.find(pending_update_clear, new_global_update[1]) == nil
						end,
						new_global_update[1], new_global_update[4]
					)

				end
			end
		end
	end
end

local function SaveProfileAsync(profile, release_from_session, is_overwriting)
	if type(profile.Data) ~= "table" then
		RegisterCorruption(
			profile._profile_store._profile_store_name,
			profile._profile_store._profile_store_scope,
			profile._profile_key
		)
		error("[ProfileService]: PROFILE DATA CORRUPTED DURING RUNTIME! Profile: " .. profile:Identify())
	end
	if release_from_session == true and is_overwriting ~= true then
		ReleaseProfileInternally(profile)
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs + 1
	local last_session_load_count = profile.MetaData.SessionLoadCount
	-- Compare "SessionLoadCount" when writing to profile to prevent a rare case of repeat last save when the profile is loaded on the same server again
	local repeat_save_flag = true -- Released Profile save calls have to repeat until they succeed
	while repeat_save_flag == true do
		if release_from_session ~= true then
			repeat_save_flag = false
		end
		local loaded_data, key_info = StandardProfileUpdateAsyncDataStore(
			profile._profile_store,
			profile._profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					local session_owns_profile = false
					local force_load_pending = false

					if is_overwriting ~= true then
						-- 1) Check if this session still owns the profile: --
						local active_session = latest_data.MetaData.ActiveSession
						local force_load_session = latest_data.MetaData.ForceLoadSession
						local session_load_count = latest_data.MetaData.SessionLoadCount

						if type(active_session) == "table" then
							session_owns_profile = IsThisSession(active_session) and session_load_count == last_session_load_count
						end
						if type(force_load_session) == "table" then
							force_load_pending = not IsThisSession(force_load_session)
						end
					else
						session_owns_profile = true
					end

					if session_owns_profile == true then -- We may only edit the profile if this session has ownership of the profile

						if is_overwriting ~= true then
							-- 2) Manage global updates: --
							local latest_global_updates_data = latest_data.GlobalUpdates -- {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
							local latest_global_updates_list = latest_global_updates_data[2]

							local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
							local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
							local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
							-- Active update locking:
							for i = 1, #latest_global_updates_list do
								for _, lock_id in ipairs(pending_update_lock) do
									if latest_global_updates_list[i][1] == lock_id then
										latest_global_updates_list[i][3] = true
										break
									end
								end
							end
							-- Locked update clearing:
							for _, clear_id in ipairs(pending_update_clear) do
								for i = 1, #latest_global_updates_list do
									if latest_global_updates_list[i][1] == clear_id and latest_global_updates_list[i][3] == true then
										table.remove(latest_global_updates_list, i)
										break
									end
								end
							end
						end

						-- 3) Save profile data: --
						latest_data.Data = profile.Data
						latest_data.RobloxMetaData = profile.RobloxMetaData
						latest_data.UserIds = profile.UserIds

						if is_overwriting ~= true then
							latest_data.MetaData.MetaTags = profile.MetaData.MetaTags -- MetaData.MetaTags is the only actively savable component of MetaData
							latest_data.MetaData.LastUpdate = os.time()
							if release_from_session == true or force_load_pending == true then
								latest_data.MetaData.ActiveSession = nil
							end
						else
							latest_data.MetaData = profile.MetaData
							latest_data.MetaData.ActiveSession = nil
							latest_data.MetaData.ForceLoadSession = nil
							latest_data.GlobalUpdates = profile.GlobalUpdates._updates_latest
						end

					end
				end,
			},
			profile._is_user_mock
		)
		if loaded_data ~= nil and key_info ~= nil then
			if is_overwriting == true then
				break
			end
			repeat_save_flag = false
			-- 4) Set latest data in profile: --
			-- Updating DataStoreKeyInfo:
			profile.KeyInfo = key_info
			-- Setting global updates:
			local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
			local old_global_updates_data = global_updates_object._updates_latest
			local new_global_updates_data = loaded_data.GlobalUpdates
			global_updates_object._updates_latest = new_global_updates_data
			-- Setting MetaData:
			local session_meta_data = profile.MetaData
			local latest_meta_data = loaded_data.MetaData
			for key in pairs(SETTINGS.MetaTagsUpdatedValues) do
				session_meta_data[key] = latest_meta_data[key]
			end
			session_meta_data.MetaTagsLatest = latest_meta_data.MetaTags
			-- 5) Check if session still owns the profile: --
			local active_session = loaded_data.MetaData.ActiveSession
			local session_load_count = loaded_data.MetaData.SessionLoadCount
			local session_owns_profile = false
			if type(active_session) == "table" then
				session_owns_profile = IsThisSession(active_session) and session_load_count == last_session_load_count
			end
			local is_active = profile:IsActive()
			if session_owns_profile == true then
				-- 6) Check for new global updates: --
				if is_active == true then -- Profile could've been released before the saving thread finished
					CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
				end
			else
				-- Session no longer owns the profile:
				-- 7) Release profile if it hasn't been released yet: --
				if is_active == true then
					ReleaseProfileInternally(profile)
				end
				-- Cleanup reference in custom write queue:
				CustomWriteQueueMarkForCleanup(profile._profile_store._profile_store_lookup, profile._profile_key)
				-- Hop ready listeners:
				if profile._hop_ready == false then
					profile._hop_ready = true
					profile._hop_ready_listeners:Fire()
				end
			end
			-- Signaling MetaTagsUpdated listeners after a possible external profile release was handled:
			profile.MetaTagsUpdated:Fire(profile.MetaData.MetaTagsLatest)
			-- Signaling KeyInfoUpdated listeners:
			profile.KeyInfoUpdated:Fire(key_info)
		elseif repeat_save_flag == true then
			task.wait() -- Prevent infinite loop in case DataStore API does not yield
		end
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs - 1
end

----- Public functions -----

-- GlobalUpdates object:

local GlobalUpdates = {
	--[[
		_updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
		_pending_update_lock = {update_id, ...} / nil, -- [table / nil]
		_pending_update_clear = {update_id, ...} / nil, -- [table / nil]
		
		_new_active_update_listeners = [ScriptSignal] / nil, -- [table / nil]
		_new_locked_update_listeners = [ScriptSignal] / nil, -- [table / nil]
		
		_profile = Profile / nil, -- [Profile / nil]
		
		_update_handler_mode = true / nil, -- [bool / nil]
	--]]
}
GlobalUpdates.__index = GlobalUpdates

-- ALWAYS PUBLIC:
function GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == false then
			local is_pending_lock = false
			if self._pending_update_lock ~= nil then
				for _, update_id in ipairs(self._pending_update_lock) do
					if global_update[1] == update_id then
						is_pending_lock = true -- Exclude global updates pending to be locked
						break
					end
				end
			end
			if is_pending_lock == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

function GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == true then
			local is_pending_clear = false
			if self._pending_update_clear ~= nil then
				for _, update_id in ipairs(self._pending_update_clear) do
					if global_update[1] == update_id then
						is_pending_clear = true -- Exclude global updates pending to be cleared
						break
					end
				end
			end
			if is_pending_clear == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

-- ONLY WHEN FROM "Profile.GlobalUpdates":
function GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewActiveUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_active_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	return self._new_active_update_listeners:Connect(listener)
end

function GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewLockedUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_locked_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	return self._new_locked_update_listeners:Connect(listener)
end

function GlobalUpdates:LockActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't lock active global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_lock == nil then
		error("[ProfileService]: Can't lock active global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't lock active global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_lock = false
		for _, lock_update_id in ipairs(self._pending_update_lock) do
			if update_id == lock_update_id then
				is_pending_lock = true -- Exclude global updates pending to be locked
				break
			end
		end
		if is_pending_lock == false and global_update_exists[3] == false then -- Avoid id duplicates in _pending_update_lock
			table.insert(self._pending_update_lock, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearLockedUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't clear locked global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_clear == nil then
		error("[ProfileService]: Can't clear locked global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't clear locked global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_clear = false
		for _, clear_update_id in ipairs(self._pending_update_clear) do
			if update_id == clear_update_id then
				is_pending_clear = true -- Exclude global updates pending to be cleared
				break
			end
		end
		if is_pending_clear == false and global_update_exists[3] == true then -- Avoid id duplicates in _pending_update_clear
			table.insert(self._pending_update_clear, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- EXPOSED TO "update_handler" DURING ProfileStore:GlobalUpdateProfileAsync() CALL
function GlobalUpdates:AddActiveUpdate(update_data)
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't add active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't add active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local update_index = updates_latest[1] + 1 -- Incrementing global update index
	updates_latest[1] = update_index
	-- Add new active global update:
	table.insert(updates_latest[2], {update_index, 1, false, update_data})
end

function GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't change active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't change active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update = nil
	for _, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't change locked global update")
		end
		get_global_update[2] = get_global_update[2] + 1 -- Increment version id
		get_global_update[4] = update_data -- Set new global update data
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id argument")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't clear active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't clear active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update_index = nil
	local get_global_update = nil
	for index, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update_index = index
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't clear locked global update")
		end
		table.remove(updates_latest[2], get_global_update_index) -- Remove active global update
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- Profile object:

local Profile = {
	--[[
		Data = {}, -- [table] -- Loaded once after ProfileStore:LoadProfileAsync() finishes
		MetaData = {}, -- [table] -- Updated with every auto-save
		GlobalUpdates = GlobalUpdates, -- [GlobalUpdates]
		
		_profile_store = ProfileStore, -- [ProfileStore]
		_profile_key = "", -- [string]
		
		_release_listeners = [ScriptSignal] / nil, -- [table / nil]
		_hop_ready_listeners = [ScriptSignal] / nil, -- [table / nil]
		_hop_ready = false,
		
		_view_mode = true / nil, -- [bool] or nil
		
		_load_timestamp = os.clock(),
		
		_is_user_mock = false, -- ProfileStore.Mock
		_mock_key_info = {},
	--]]
}
Profile.__index = Profile

function Profile:IsActive() --> [bool]
	local loaded_profiles = self._is_user_mock == true and self._profile_store._mock_loaded_profiles or self._profile_store._loaded_profiles
	return loaded_profiles[self._profile_key] == self
end

function Profile:GetMetaTag(tag_name) --> value
	local meta_data = self.MetaData
	if meta_data == nil then
		return nil
		-- error("[ProfileService]: This Profile hasn't been loaded before - MetaData not available")
	end
	return self.MetaData.MetaTags[tag_name]
end

function Profile:SetMetaTag(tag_name, value)
	if type(tag_name) ~= "string" then
		error("[ProfileService]: tag_name must be a string")
	elseif string.len(tag_name) == 0 then
		error("[ProfileService]: Invalid tag_name")
	end
	self.MetaData.MetaTags[tag_name] = value
end

function Profile:Reconcile()
	ReconcileTable(self.Data, self._profile_store._profile_template)
end

function Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in Profile:ListenToRelease()")
	end
	if self._view_mode == true then
		return {Disconnect = function() end}
	end
	if self:IsActive() == false then
		-- Call release listener immediately if profile is expired
		local place_id
		local game_job_id
		local active_session = self.MetaData.ActiveSession
		if active_session ~= nil then
			place_id = active_session[1]
			game_job_id = active_session[2]
		end
		listener(place_id, game_job_id)
		return {Disconnect = function() end}
	else
		return self._release_listeners:Connect(listener)
	end
end

function Profile:Save()
	if self._view_mode == true then
		error("[ProfileService]: Can't save Profile in view mode - Should you be calling :OverwriteAsync() instead?")
	end
	if self:IsActive() == false then
		warn("[ProfileService]: Attempted saving an inactive profile "
			.. self:Identify() .. "; Traceback:\n" .. debug.traceback())
		return
	end
	-- Reject save request if a save is already pending in the queue - this will prevent the user from
	--	unecessary API request spam which we could not meaningfully execute anyways!
	if IsCustomWriteQueueEmptyFor(self._profile_store._profile_store_lookup, self._profile_key) == true then
		-- We don't want auto save to trigger too soon after manual saving - this will reset the auto save timer:
		RemoveProfileFromAutoSave(self)
		AddProfileToAutoSave(self)
		-- Call save function in a new thread:
		task.spawn(SaveProfileAsync, self)
	end
end

function Profile:Release()
	if self._view_mode == true then
		return
	end
	if self:IsActive() == true then
		task.spawn(SaveProfileAsync, self, true) -- Call save function in a new thread with release_from_session = true
	end
end

function Profile:ListenToHopReady(listener) --> [ScriptConnection] ()
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in Profile:ListenToHopReady()")
	end
	if self._view_mode == true then
		return {Disconnect = function() end}
	end
	if self._hop_ready == true then
		task.spawn(listener)
		return {Disconnect = function() end}
	else
		return self._hop_ready_listeners:Connect(listener)
	end
end

function Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn("[ProfileService]: Invalid UserId argument for :AddUserId() ("
			.. tostring(user_id) .. "); Traceback:\n" .. debug.traceback())
		return
	end

	if user_id &lt; 0 and self._is_user_mock ~= true and UseMockDataStore ~= true then
		return -- Avoid giving real Roblox APIs negative UserId's
	end

	if table.find(self.UserIds, user_id) == nil then
		table.insert(self.UserIds, user_id)
	end
	
end

function Profile:RemoveUserId(user_id) -- Unassociates user_id with profile (safe function)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn("[ProfileService]: Invalid UserId argument for :RemoveUserId() ("
			.. tostring(user_id) .. "); Traceback:\n" .. debug.traceback())
		return
	end
	
	local index = table.find(self.UserIds, user_id)

	if index ~= nil then
		table.remove(self.UserIds, index)
	end

end

function Profile:Identify() --> [string]
	return IdentifyProfile(
		self._profile_store._profile_store_name,
		self._profile_store._profile_store_scope,
		self._profile_key
	)
end

function Profile:ClearGlobalUpdates() -- Clears all global updates data from a profile payload

	if self._view_mode ~= true then
		error("[ProfileService]: :ClearGlobalUpdates() can only be used in view mode")
	end

	local global_updates_object = {
		_updates_latest = {0, {}},
		_profile = self,
	}
	setmetatable(global_updates_object, GlobalUpdates)

	self.GlobalUpdates = global_updates_object

end

function Profile:OverwriteAsync() -- Saves the profile to the DataStore and removes the session lock

	if self._view_mode ~= true then
		error("[ProfileService]: :OverwriteAsync() can only be used in view mode")
	end

	SaveProfileAsync(self, nil, true)

end

-- ProfileVersionQuery object:

local ProfileVersionQuery = {
	--[[
		_profile_store = profile_store,
		_profile_key = profile_key,
		_sort_direction = sort_direction,
		_min_date = min_date,
		_max_date = max_date,

		_query_pages = pages, -- [DataStoreVersionPages]
		_query_index = index, -- [number]
		_query_failure = false,

		_is_query_yielded = false,
		_query_queue = {},
	--]]
}
ProfileVersionQuery.__index = ProfileVersionQuery

function ProfileVersionQuery:_MoveQueue()
	while #self._query_queue > 0 do
		local queue_entry = table.remove(self._query_queue, 1)
		task.spawn(queue_entry)
		if self._is_query_yielded == true then
			break
		end
	end
end

function ProfileVersionQuery:NextAsync(_is_stacking) --> [Profile] or nil

	if self._profile_store == nil then
		return nil
	end

	local profile
	local is_finished = false

	local function query_job()

		if self._query_failure == true then
			is_finished = true
			return
		end

		-- First "next" call loads version pages:

		if self._query_pages == nil then

			self._is_query_yielded = true
			task.spawn(function()
				profile = self:NextAsync(true)
				is_finished = true
			end)
			
			local list_success, error_message = pcall(function()
				self._query_pages = self._profile_store._global_data_store:ListVersionsAsync(
					self._profile_key,
					self._sort_direction,
					self._min_date,
					self._max_date
				)
				self._query_index = 0
			end)

			if list_success == false or self._query_pages == nil then
				warn("[ProfileService]: Version query fail - " .. tostring(error_message))
				self._query_failure = true
			end

			self._is_query_yielded = false
			self:_MoveQueue()

			return

		end

		local current_page = self._query_pages:GetCurrentPage()
		local next_item = current_page[self._query_index + 1]

		-- No more entries:
		
		if self._query_pages.IsFinished == true and next_item == nil then
			is_finished = true
			return
		end

		-- Load next page when this page is over:

		if next_item == nil then

			self._is_query_yielded = true
			task.spawn(function()
				profile = self:NextAsync(true)
				is_finished = true
			end)

			local success = pcall(function()
				self._query_pages:AdvanceToNextPageAsync()
				self._query_index = 0
			end)

			if success == false or #self._query_pages:GetCurrentPage() == 0 then
				self._query_failure = true
			end

			self._is_query_yielded = false
			self:_MoveQueue()

			return

		end

		-- Next page item:

		self._query_index += 1
		profile = self._profile_store:ViewProfileAsync(self._profile_key, next_item.Version)
		is_finished = true

	end

	if self._is_query_yielded == false then
		query_job()
	else
		if _is_stacking == true then
			table.insert(self._query_queue, 1, query_job)
		else
			table.insert(self._query_queue, query_job)
		end
	end

	while is_finished == false do
		task.wait()
	end

	return profile

end

-- ProfileStore object:

local ProfileStore = {
	--[[
		Mock = {},
	
		_profile_store_name = "", -- [string] -- DataStore name
		_profile_store_scope = nil, -- [string] or [nil] -- DataStore scope
		_profile_store_lookup = "", -- [string] -- _profile_store_name .. "\0" .. (_profile_store_scope or "")
		
		_profile_template = {}, -- [table]
		_global_data_store = global_data_store, -- [GlobalDataStore] -- Object returned by DataStoreService:GetDataStore(_profile_store_name)
		
		_loaded_profiles = {[profile_key] = Profile, ...},
		_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},
		
		_mock_loaded_profiles = {[profile_key] = Profile, ...},
		_mock_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},
	--]]
}
ProfileStore.__index = ProfileStore

function ProfileStore:LoadProfileAsync(profile_key, not_released_handler, _use_mock) --> [Profile / nil] not_released_handler(place_id, game_job_id)

	not_released_handler = not_released_handler or "ForceLoad"

	if self._profile_template == nil then
		error("[ProfileService]: Profile template not set - ProfileStore:LoadProfileAsync() locked for this ProfileStore")
	end
	if type(profile_key) ~= "string" then
		error("[ProfileService]: profile_key must be a string")
	elseif string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(not_released_handler) ~= "function" and not_released_handler ~= "ForceLoad" and not_released_handler ~= "Steal" then
		error("[ProfileService]: Invalid not_released_handler")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	local is_user_mock = _use_mock == UseMockTag

	-- Check if profile with profile_key isn't already loaded in this session:
	for _, profile_store in ipairs(ActiveProfileStores) do
		if profile_store._profile_store_lookup == self._profile_store_lookup then
			local loaded_profiles = is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles
			if loaded_profiles[profile_key] ~= nil then
				error("[ProfileService]: Profile " .. IdentifyProfile(self._profile_store_name, self._profile_store_scope, profile_key) .. " is already loaded in this session")
				-- Are you using Profile:Release() properly?
			end
		end
	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs + 1
	local force_load = not_released_handler == "ForceLoad"
	local force_load_steps = 0
	local request_force_load = force_load -- First step of ForceLoad
	local steal_session = false -- Second step of ForceLoad
	local aggressive_steal = not_released_handler == "Steal" -- Developer invoked steal
	while ProfileService.ServiceLocked == false do
		-- Load profile:
		-- SPECIAL CASE - If LoadProfileAsync is called for the same key before another LoadProfileAsync finishes,
		-- yoink the DataStore return for the new call. The older call will return nil. This would prevent very rare
		-- game breaking errors where a player rejoins the server super fast.
		local profile_load_jobs = is_user_mock == true and self._mock_profile_load_jobs or self._profile_load_jobs
		local loaded_data, key_info
		local load_id = LoadIndex + 1
		LoadIndex = load_id
		local profile_load_job = profile_load_jobs[profile_key] -- {load_id, {loaded_data, key_info} or nil}
		if profile_load_job ~= nil then
			profile_load_job[1] = load_id -- Yoink load job
			while profile_load_job[2] == nil do -- Wait for job to finish
				task.wait()
			end
			if profile_load_job[1] == load_id then -- Load job hasn't been double-yoinked
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end
		else
			profile_load_job = {load_id, nil}
			profile_load_jobs[profile_key] = profile_load_job
			profile_load_job[2] = table.pack(StandardProfileUpdateAsyncDataStore(
				self,
				profile_key,
				{
					ExistingProfileHandle = function(latest_data)
						if ProfileService.ServiceLocked == false then
							local active_session = latest_data.MetaData.ActiveSession
							local force_load_session = latest_data.MetaData.ForceLoadSession
							-- IsThisSession(active_session)
							if active_session == nil then
								latest_data.MetaData.ActiveSession = {PlaceId, JobId}
								latest_data.MetaData.ForceLoadSession = nil
							elseif type(active_session) == "table" then
								if IsThisSession(active_session) == false then
									local last_update = latest_data.MetaData.LastUpdate
									if last_update ~= nil then
										if os.time() - last_update > SETTINGS.AssumeDeadSessionLock then
											latest_data.MetaData.ActiveSession = {PlaceId, JobId}
											latest_data.MetaData.ForceLoadSession = nil
											return
										end
									end
									if steal_session == true or aggressive_steal == true then
										local force_load_uninterrupted = false
										if force_load_session ~= nil then
											force_load_uninterrupted = IsThisSession(force_load_session)
										end
										if force_load_uninterrupted == true or aggressive_steal == true then
											latest_data.MetaData.ActiveSession = {PlaceId, JobId}
											latest_data.MetaData.ForceLoadSession = nil
										end
									elseif request_force_load == true then
										latest_data.MetaData.ForceLoadSession = {PlaceId, JobId}
									end
								else
									latest_data.MetaData.ForceLoadSession = nil
								end
							end
						end
					end,
					MissingProfileHandle = function(latest_data)
						latest_data.Data = DeepCopyTable(self._profile_template)
						latest_data.MetaData = {
							ProfileCreateTime = os.time(),
							SessionLoadCount = 0,
							ActiveSession = {PlaceId, JobId},
							ForceLoadSession = nil,
							MetaTags = {},
						}
					end,
					EditProfile = function(latest_data)
						if ProfileService.ServiceLocked == false then
							local active_session = latest_data.MetaData.ActiveSession
							if active_session ~= nil and IsThisSession(active_session) == true then
								latest_data.MetaData.SessionLoadCount = latest_data.MetaData.SessionLoadCount + 1
								latest_data.MetaData.LastUpdate = os.time()
							end
						end
					end,
				},
				is_user_mock
			))
			if profile_load_job[1] == load_id then -- Load job hasn't been yoinked
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- Load job yoinked
			end
		end
		-- Handle load_data:
		if loaded_data ~= nil and key_info ~= nil then
			local active_session = loaded_data.MetaData.ActiveSession
			if type(active_session) == "table" then
				if IsThisSession(active_session) == true then
					-- Special component in MetaTags:
					loaded_data.MetaData.MetaTagsLatest = DeepCopyTable(loaded_data.MetaData.MetaTags)
					-- Case #1: Profile is now taken by this session:
					-- Create Profile object:
					local global_updates_object = {
						_updates_latest = loaded_data.GlobalUpdates,
						_pending_update_lock = {},
						_pending_update_clear = {},

						_new_active_update_listeners = Madwork.NewScriptSignal(),
						_new_locked_update_listeners = Madwork.NewScriptSignal(),

						_profile = nil,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					local profile = {
						Data = loaded_data.Data,
						MetaData = loaded_data.MetaData,
						MetaTagsUpdated = Madwork.NewScriptSignal(),

						RobloxMetaData = loaded_data.RobloxMetaData or {},
						UserIds = loaded_data.UserIds or {},
						KeyInfo = key_info,
						KeyInfoUpdated = Madwork.NewScriptSignal(),

						GlobalUpdates = global_updates_object,

						_profile_store = self,
						_profile_key = profile_key,

						_release_listeners = Madwork.NewScriptSignal(),
						_hop_ready_listeners = Madwork.NewScriptSignal(),
						_hop_ready = false,

						_load_timestamp = os.clock(),

						_is_user_mock = is_user_mock,
					}
					setmetatable(profile, Profile)
					global_updates_object._profile = profile
					-- Referencing Profile object in ProfileStore:
					if next(self._loaded_profiles) == nil and next(self._mock_loaded_profiles) == nil then -- ProfileStore object was inactive
						table.insert(ActiveProfileStores, self)
					end
					if is_user_mock == true then
						self._mock_loaded_profiles[profile_key] = profile
					else
						self._loaded_profiles[profile_key] = profile
					end
					-- Adding profile to AutoSaveList;
					AddProfileToAutoSave(profile)
					-- Special case - finished loading profile, but session is shutting down:
					if ProfileService.ServiceLocked == true then
						SaveProfileAsync(profile, true) -- Release profile and yield until the DataStore call is finished
						profile = nil -- nil will be returned by this call
					end
					-- Return Profile object:
					ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
					return profile
				else
					-- Case #2: Profile is taken by some other session:
					if force_load == true then
						local force_load_session = loaded_data.MetaData.ForceLoadSession
						local force_load_uninterrupted = false
						if force_load_session ~= nil then
							force_load_uninterrupted = IsThisSession(force_load_session)
						end
						if force_load_uninterrupted == true then
							if request_force_load == false then
								force_load_steps = force_load_steps + 1
								if force_load_steps == SETTINGS.ForceLoadMaxSteps then
									steal_session = true
								end
							end
							task.wait() -- Overload prevention
						else
							-- Another session tried to force load this profile:
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						end
						request_force_load = false -- Only request a force load once
					elseif aggressive_steal == true then
						task.wait() -- Overload prevention
					else
						local handler_result = not_released_handler(active_session[1], active_session[2])
						if handler_result == "Repeat" then
							task.wait() -- Overload prevention
						elseif handler_result == "Cancel" then
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						elseif handler_result == "ForceLoad" then
							force_load = true
							request_force_load = true
							task.wait() -- Overload prevention
						elseif handler_result == "Steal" then
							aggressive_steal = true
							task.wait() -- Overload prevention
						else
							error(
								"[ProfileService]: Invalid return from not_released_handler (\"" .. tostring(handler_result) .. "\")(" .. type(handler_result) .. ");" ..
									"\n" .. IdentifyProfile(self._profile_store_name, self._profile_store_scope, profile_key) ..
									" Traceback:\n" .. debug.traceback()
							)
						end
					end
				end
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- In this scenario it is likely the ProfileService.ServiceLocked flag was raised
			end
		else
			task.wait() -- Overload prevention
		end
	end
	ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
	return nil -- If loop breaks return nothing
end

function ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler, _use_mock) --> [GlobalUpdates / nil] (update_handler(GlobalUpdates))
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(update_handler) ~= "function" then
		error("[ProfileService]: Invalid update_handler")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	while ProfileService.ServiceLocked == false do
		-- Updating profile:
		local loaded_data = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)
					-- Running update_handler:
					local global_updates_object = {
						_updates_latest = latest_data.GlobalUpdates,
						_update_handler_mode = true,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					update_handler(global_updates_object)
				end,
			},
			_use_mock == UseMockTag
		)
		CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)
		-- Handling loaded_data:
		if loaded_data ~= nil then
			-- Return GlobalUpdates object (Update successful):
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			return global_updates_object
		else
			task.wait() -- Overload prevention
		end
	end
	return nil -- Return nothing (Update unsuccessful)
end

function ProfileStore:ViewProfileAsync(profile_key, version, _use_mock) --> [Profile / nil]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	if version ~= nil and (_use_mock == UseMockTag or UseMockDataStore == true) then
		return nil -- No version support in mock mode
	end

	while ProfileService.ServiceLocked == false do
		-- Load profile:
		local loaded_data, key_info = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = function(latest_data)
					latest_data.Data = DeepCopyTable(self._profile_template)
					latest_data.MetaData = {
						ProfileCreateTime = os.time(),
						SessionLoadCount = 0,
						ActiveSession = nil,
						ForceLoadSession = nil,
						MetaTags = {},
					}
				end,
				EditProfile = nil,
			},
			_use_mock == UseMockTag,
			true, -- Use :GetAsync()
			version -- DataStore key version
		)
		CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)
		-- Handle load_data:
		if loaded_data ~= nil then
			if key_info == nil then
				return nil -- Load was successful, but the key was empty - return no profile object
			end
			-- Create Profile object:
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates, -- {0, {}}
				_profile = nil,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			local profile = {
				Data = loaded_data.Data,
				MetaData = loaded_data.MetaData,
				MetaTagsUpdated = Madwork.NewScriptSignal(),

				RobloxMetaData = loaded_data.RobloxMetaData or {},
				UserIds = loaded_data.UserIds or {},
				KeyInfo = key_info,
				KeyInfoUpdated = Madwork.NewScriptSignal(),

				GlobalUpdates = global_updates_object,

				_profile_store = self,
				_profile_key = profile_key,

				_view_mode = true,

				_load_timestamp = os.clock(),
			}
			setmetatable(profile, Profile)
			global_updates_object._profile = profile
			-- Returning Profile object:
			return profile
		else
			task.wait() -- Overload prevention
		end
	end
	return nil -- If loop breaks return nothing
end

function ProfileStore:ProfileVersionQuery(profile_key, sort_direction, min_date, max_date, _use_mock) --> [ProfileVersionQuery]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return setmetatable({}, ProfileVersionQuery) -- Silently fail :Next() requests
	end

	WaitForPendingProfileStore(self)

	if _use_mock == UseMockTag or UseMockDataStore == true then
		error("[ProfileService]: :ProfileVersionQuery() is not supported in mock mode")
	end

	-- Type check:
	if sort_direction ~= nil and (typeof(sort_direction) ~= "EnumItem"
		or sort_direction.EnumType ~= Enum.SortDirection) then
		error("[ProfileService]: Invalid sort_direction (" .. tostring(sort_direction) .. ")")
	end

	if min_date ~= nil and typeof(min_date) ~= "DateTime" and typeof(min_date) ~= "number" then
		error("[ProfileService]: Invalid min_date (" .. tostring(min_date) .. ")")
	end

	if max_date ~= nil and typeof(max_date) ~= "DateTime" and typeof(max_date) ~= "number" then
		error("[ProfileService]: Invalid max_date (" .. tostring(max_date) .. ")")
	end

	min_date = typeof(min_date) == "DateTime" and min_date.UnixTimestampMillis or min_date
	max_date = typeof(max_date) == "DateTime" and max_date.UnixTimestampMillis or max_date

	local profile_version_query = {
		_profile_store = self,
		_profile_key = profile_key,
		_sort_direction = sort_direction,
		_min_date = min_date,
		_max_date = max_date,

		_query_pages = nil,
		_query_index = 0,
		_query_failure = false,

		_is_query_yielded = false,
		_query_queue = {},
	}
	setmetatable(profile_version_query, ProfileVersionQuery)

	return profile_version_query

end

function ProfileStore:WipeProfileAsync(profile_key, _use_mock) --> is_wipe_successful [bool]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return false
	end

	WaitForPendingProfileStore(self)

	local wipe_status = false

	if _use_mock == UseMockTag then -- Used when the profile is accessed through ProfileStore.Mock
		local mock_data_store = UserMockDataStore[self._profile_store_lookup]
		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
		end
		wipe_status = true
		task.wait() -- Simulate API call yield
	elseif UseMockDataStore == true then -- Used when API access is disabled
		local mock_data_store = MockDataStore[self._profile_store_lookup]
		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
		end
		wipe_status = true
		task.wait() -- Simulate API call yield
	else
		wipe_status = pcall(function()
			self._global_data_store:RemoveAsync(profile_key)
		end)
	end

	CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)

	return wipe_status
end

-- New ProfileStore:

function ProfileService.GetProfileStore(profile_store_index, profile_template) --> [ProfileStore]

	local profile_store_name
	local profile_store_scope = nil

	-- Parsing profile_store_index:
	if type(profile_store_index) == "string" then
		-- profile_store_index as string:
		profile_store_name = profile_store_index
	elseif type(profile_store_index) == "table" then
		-- profile_store_index as table:
		profile_store_name = profile_store_index.Name
		profile_store_scope = profile_store_index.Scope
	else
		error("[ProfileService]: Invalid or missing profile_store_index")
	end

	-- Type checking:
	if profile_store_name == nil or type(profile_store_name) ~= "string" then
		error("[ProfileService]: Missing or invalid \"Name\" parameter")
	elseif string.len(profile_store_name) == 0 then
		error("[ProfileService]: ProfileStore name cannot be an empty string")
	end

	if profile_store_scope ~= nil and (type(profile_store_scope) ~= "string" or string.len(profile_store_scope) == 0) then
		error("[ProfileService]: Invalid \"Scope\" parameter")
	end

	if type(profile_template) ~= "table" then
		error("[ProfileService]: Invalid profile_template")
	end

	local profile_store
	profile_store = {
		Mock = {
			LoadProfileAsync = function(_, profile_key, not_released_handler)
				return profile_store:LoadProfileAsync(profile_key, not_released_handler, UseMockTag)
			end,
			GlobalUpdateProfileAsync = function(_, profile_key, update_handler)
				return profile_store:GlobalUpdateProfileAsync(profile_key, update_handler, UseMockTag)
			end,
			ViewProfileAsync = function(_, profile_key, version)
				return profile_store:ViewProfileAsync(profile_key, version, UseMockTag)
			end,
			FindProfileVersionAsync = function(_, profile_key, sort_direction, min_date, max_date)
				return profile_store:FindProfileVersionAsync(profile_key, sort_direction, min_date, max_date, UseMockTag)
			end,
			WipeProfileAsync = function(_, profile_key)
				return profile_store:WipeProfileAsync(profile_key, UseMockTag)
			end
		},

		_profile_store_name = profile_store_name,
		_profile_store_scope = profile_store_scope,
		_profile_store_lookup = profile_store_name .. "\0" .. (profile_store_scope or ""),

		_profile_template = profile_template,
		_global_data_store = nil,
		_loaded_profiles = {},
		_profile_load_jobs = {},
		_mock_loaded_profiles = {},
		_mock_profile_load_jobs = {},
		_is_pending = false,
	}
	setmetatable(profile_store, ProfileStore)

	local options = Instance.new("DataStoreOptions")
	options:SetExperimentalFeatures({v2 = true})

	if IsLiveCheckActive == true then
		profile_store._is_pending = true
		task.spawn(function()
			WaitForLiveAccessCheck()
			if UseMockDataStore == false then
				profile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name, profile_store_scope, options)
			end
			profile_store._is_pending = false
		end)
	else
		if UseMockDataStore == false then
			profile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name, profile_store_scope, options)
		end
	end

	return profile_store
end

function ProfileService.IsLive() --> [bool] -- (CAN YIELD!!!)

	WaitForLiveAccessCheck()

	return UseMockDataStore == false

end

----- Initialize -----

if IsStudio == true then
	IsLiveCheckActive = true
	task.spawn(function()
		local status, message = pcall(function()
			-- This will error if current instance has no Studio API access:
			DataStoreService:GetDataStore("____PS"):SetAsync("____PS", os.time())
		end)
		local no_internet_access = status == false and string.find(message, "ConnectFail", 1, true) ~= nil
		if no_internet_access == true then
			warn("[ProfileService]: No internet access - check your network connection")
		end
		if status == false and
			(string.find(message, "403", 1, true) ~= nil or -- Cannot write to DataStore from studio if API access is not enabled
				string.find(message, "must publish", 1, true) ~= nil or -- Game must be published to access live keys
				no_internet_access == true) then -- No internet access

			UseMockDataStore = true
			ProfileService._use_mock_data_store = true
			print("[ProfileService]: Roblox API services unavailable - data will not be saved")
		else
			print("[ProfileService]: Roblox API services available - data will be saved")
		end
		IsLiveCheckActive = false
	end)
end

----- Connections -----

-- Auto saving and issue queue managing:
RunService.Heartbeat:Connect(function()
	-- 1) Auto saving: --
	local auto_save_list_length = #AutoSaveList
	if auto_save_list_length > 0 then
		local auto_save_index_speed = SETTINGS.AutoSaveProfiles / auto_save_list_length
		local os_clock = os.clock()
		while os_clock - LastAutoSave > auto_save_index_speed do
			LastAutoSave = LastAutoSave + auto_save_index_speed
			local profile = AutoSaveList[AutoSaveIndex]
			if os_clock - profile._load_timestamp &lt; SETTINGS.AutoSaveProfiles then
				-- This profile is freshly loaded - auto-saving immediately after loading will cause a warning in the log:
				profile = nil
				for _ = 1, auto_save_list_length - 1 do
					-- Move auto save index to the right:
					AutoSaveIndex = AutoSaveIndex + 1
					if AutoSaveIndex > auto_save_list_length then
						AutoSaveIndex = 1
					end
					profile = AutoSaveList[AutoSaveIndex]
					if os_clock - profile._load_timestamp >= SETTINGS.AutoSaveProfiles then
						break
					else
						profile = nil
					end
				end
			end
			-- Move auto save index to the right:
			AutoSaveIndex = AutoSaveIndex + 1
			if AutoSaveIndex > auto_save_list_length then
				AutoSaveIndex = 1
			end
			-- Perform save call:
			if profile ~= nil then
				task.spawn(SaveProfileAsync, profile) -- Auto save profile in new thread
			end
		end
	end
	-- 2) Issue queue: --
	-- Critical state handling:
	if ProfileService.CriticalState == false then
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			ProfileService.CriticalState = true
			ProfileService.CriticalStateSignal:Fire(true)
			CriticalStateStart = os.clock()
			warn("[ProfileService]: Entered critical state")
		end
	else
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			CriticalStateStart = os.clock()
		elseif os.clock() - CriticalStateStart > SETTINGS.CriticalStateLast then
			ProfileService.CriticalState = false
			ProfileService.CriticalStateSignal:Fire(false)
			warn("[ProfileService]: Critical state ended")
		end
	end
	-- Issue queue:
	while true do
		local issue_time = IssueQueue[1]
		if issue_time == nil then
			break
		elseif os.clock() - issue_time > SETTINGS.IssueLast then
			table.remove(IssueQueue, 1)
		else
			break
		end
	end
end)

-- Release all loaded profiles when the server is shutting down:
task.spawn(function()
	WaitForLiveAccessCheck()
	Madwork.ConnectToOnClose(
		function()
			ProfileService.ServiceLocked = true
			-- 1) Release all active profiles: --
			-- Clone AutoSaveList to a new table because AutoSaveList changes when profiles are released:
			local on_close_save_job_count = 0
			local active_profiles = {}
			for index, profile in ipairs(AutoSaveList) do
				active_profiles[index] = profile
			end
			-- Release the profiles; Releasing profiles can trigger listeners that release other profiles, so check active state:
			for _, profile in ipairs(active_profiles) do
				if profile:IsActive() == true then
					on_close_save_job_count = on_close_save_job_count + 1
					task.spawn(function() -- Save profile on new thread
						SaveProfileAsync(profile, true)
						on_close_save_job_count = on_close_save_job_count - 1
					end)
				end
			end
			-- 2) Yield until all active profile jobs are finished: --
			while on_close_save_job_count > 0 or ActiveProfileLoadJobs > 0 or ActiveProfileSaveJobs > 0 do
				task.wait()
			end
			return -- We're done!
		end,
		UseMockDataStore == false -- Always run this OnClose task if using Roblox API services
	)
end)

return ProfileService</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="279">
            <Properties>
              <string name="Name">services</string>
              <string name="Source"><![CDATA[return setmetatable({}, {
	__index = function(self, serviceName)
		local service = game:GetService(serviceName)
		self[serviceName] = service
		return service
	end,
})
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="280">
            <Properties>
              <string name="Name">signal</string>
              <string name="Source"><![CDATA[local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({ Bindable = Instance.new("BindableEvent") }, Signal)
end

function Signal:Connect(Callback)
	return self.Bindable.Event:Connect(function(GetArguments)
		Callback(GetArguments())
	end)
end

function Signal:Once(Callback)
	return self.Bindable.Event:Once(function(GetArguments)
		Callback(GetArguments())
	end)
end

function Signal:ConnectParallel(Callback)
	return self.Bindable.Event:ConnectParallel(function(GetArguments)
		Callback(GetArguments())
	end)
end

function Signal:Fire(...)
	local Arguments = { ... }
	local n = select("#", ...)

	self.Bindable:Fire(function()
		return table.unpack(Arguments, 1, n)
	end)
end

function Signal:Wait()
	return self.Bindable.Event:Wait()()
end

function Signal:Destroy()
	self.Bindable:Destroy()
end

return Signal
]]></string>
            </Properties>
          </Item>
          <Item class="Folder" referent="281">
            <Properties>
              <string name="Name">signals</string>
            </Properties>
            <Item class="ModuleScript" referent="282">
              <Properties>
                <string name="Name">out</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "store") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "primitives") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "signals") or {} do
	exports[_k] = _v
end
return exports
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="283">
                <Properties>
                  <string name="Name">argCount</string>
                  <string name="Source">local Module = {}

function Module.withArgCount(func)
  return function(...)
    return func(select("#", ...), ...)
  end
end

return Module</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="284">
                <Properties>
                  <string name="Name">primitives</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "animate") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "tween") or {} do
	exports[_k] = _v
end
return exports
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="285">
                  <Properties>
                    <string name="Name">animate</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local curves
local function keyframes(...)
	local keys = { ... }
	return function(t)
		if t <= 0 then
			return keys[1].value
		end
		if t >= 1 then
			return keys[#keys].value
		end
		local prevKey = keys[1]
		for i = 1, #keys - 1 do
			local key = keys[i + 1]
			if t <= key.at then
				local progress = (t - prevKey.at) / (key.at - prevKey.at)
				local easing = key.easing or curves.linear
				return prevKey.value + easing(progress) * (key.value - prevKey.value)
			end
			prevKey = key
		end
		return keys[#keys].value
	end
end
curves = {
	cubicBezier = function(p0, p1, p2, p3)
		return function(t)
			local u = 1 - t
			local tt = t * t
			local uu = u * u
			local uuu = uu * u
			local ttt = tt * t
			return uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y
		end
	end,
	linear = function(t)
		return t
	end,
	easeIn = function(t)
		return t * t
	end,
	easeOut = function(t)
		return t * (2 - t)
	end,
	easeInOut = function(t)
		return if t < 0.5 then 2 * t * t else -1 + (4 - 2 * t) * t
	end,
	bounce = function(t)
		if t < 0.36363636 then
			return 7.5625 * t * t
		elseif t < 0.72727273 then
			t -= 0.54545455
			return 7.5625 * t * t + 0.75
		elseif t < 0.90909091 then
			t -= 0.81818182
			return 7.5625 * t * t + 0.9375
		else
			t -= 0.95454545
			return 7.5625 * t * t + 0.984375
		end
	end,
	bounceIn = function(t)
		return 1 - curves.bounce(1 - t)
	end,
	bounceOut = function(t)
		return curves.bounce(t)
	end,
	bounceInOut = function(t)
		return if t < 0.5 then (1 - curves.bounce(1 - 2 * t)) / 2 else (1 + curves.bounce(2 * t - 1)) / 2
	end,
	elastic = function(t)
		local c4 = (2 * math.pi) / 3
		return if t == 0 then 0 elseif t == 1 then 1 elseif t < 0.5 then (math.pow(2, 20 * t - 10) * math.sin((t * 20 - 11.125) * c4)) / 2 else (math.pow(2, -20 * t + 10) * math.sin((t * 20 - 11.125) * c4)) / -2 + 1
	end,
	elasticIn = function(t)
		return 1 - curves.elastic(1 - t)
	end,
	elasticOut = function(t)
		return curves.elastic(t)
	end,
	elasticInOut = function(t)
		return if t < 0.5 then (1 - curves.elastic(1 - 2 * t)) / 2 else (1 + curves.elastic(2 * t - 1)) / 2
	end,
	back = function(t)
		local s = 1.70158
		return t * t * ((s + 1) * t - s)
	end,
	backIn = function(t)
		return curves.back(t)
	end,
	backOut = function(t)
		local s = 1.70158
		t -= 1
		return t * t * ((s + 1) * t + s) + 1
	end,
	backInOut = function(t)
		local s = 1.70158
		local _result
		if t < 0.5 then
			_result = (t * t * ((s + 1) * t - s)) / 2
		else
			t -= 1
			_result = (t * t * ((s + 1) * t + s)) / 2 + 1
		end
		return _result
	end,
	steps = function(steps, direction)
		if direction == nil then
			direction = "end"
		end
		local stepSize = 1 / steps
		return function(t)
			local step = math.floor(t / stepSize)
			if direction == "start" then
				return step * stepSize
			elseif direction == "end" then
				return (step + 1) * stepSize
			else
				return (step + 0.5) * stepSize
			end
		end
	end,
}
return {
	keyframes = keyframes,
	curves = curves,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="286">
                  <Properties>
                    <string name="Name">tween</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local _signals = TS.import(script, script.Parent.Parent, "signals")
local createEffect = _signals.createEffect
local createMemo = _signals.createMemo
local createSignal = _signals.createSignal
local on = _signals.on
local onCleanup = _signals.onCleanup
local untrack = _signals.untrack
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
--[[
	*
	 * # Tween
	 * Creates a tween signal that animates a value from its current value to the target value over a specified duration.
	 * @param target A function that returns the target value to tween to.
	 * @param param1 An object containing the tween properties.
	 * @returns A signal that represents the current value of the tween.
	 
]]
local function createTween(target, _param)
	if _param == nil then
		_param = {}
	end
	local ease = _param.ease
	if ease == nil then
		ease = function(t)
			return t
		end
	end
	local duration = _param.duration
	if duration == nil then
		duration = 100
	end
	local elapsed = createSignal(0)
	local from = untrack(target)
	local delta = 0
	local current = createMemo(function()
		return from + delta * ease(elapsed() / duration)
	end)
	local connection = nil
	local function tick(dt)
		elapsed.set(function(prev)
			local nextVal = math.clamp(prev + (dt * 1000), 0, duration)
			if nextVal == duration then
				local _result = connection
				if _result ~= nil then
					_result:Disconnect()
				end
			end
			return nextVal
		end)
	end
	createEffect(on(target, function(target)
		from = current()
		delta = target - from
		elapsed(0)
		connection = RunService.Heartbeat:Connect(tick)
		onCleanup(function()
			local _result = connection
			if _result ~= nil then
				_result = _result:Disconnect()
			end
			return _result
		end)
	end, {
		defer = true,
	}))
	return current
end
--[[
	*
	 * # createTweened
	 * Creates a tweened signal that animates a value from its next value to the target value over a specified duration.
	 * @param value The initial value of the tweened signal.
	 * @param props An object containing the tween properties.
	 * @returns A tuple containing the tweened signal and a setter function to update the value.
	 
]]
local function createTweened(value, props)
	local signal = createSignal(value)
	local tween = createTween(signal, props)
	return { tween, function(value)
		return signal(value)
	end }
end
return {
	createTween = createTween,
	createTweened = createTweened,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="287">
                <Properties>
                  <string name="Name">signals</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * Custom implementation of S.js for roblox, with interfaces inspired from many other libraries like solidjs, preact, etc.
	 * 
	 * This code is mainly not mine, the library could be created thanks to a massive inspiration from:
	 *  - https://github.com/adamhaile/S
	 *  - https://github.com/solidjs/solid
	 *  - https://www.npmjs.com/package/@preact/signals-react
	 *  - https://github.com/rodydavis/signals.dart
	 * 
	 * The code has been rewritten to be compilable using roblox-ts, and to be more useable in roblox.
	 * I included some functionalities that i foud useful in other libraries, like the on, getOwner 
	 * and runWithOwner from solidjs, the single-function signals style from preact, augmented with 
	 * other methods inspired by signals.dart.
	 * 
	 * I removed some securities, so if any buc can be fous let me know it in a pull request or in issues.
	 * 
	 * The library may be slower that the original S.js, but it is more flexible and easier to use, and i 
	 * did not found any performance issue in my tests, unless when i created a ridiculously sized tree of signals.
	 
]]
local withArgCount = TS.import(script, script.Parent, "argCount").withArgCount
-- Because luau has no console, we use print, to keep js-like syntax
local console = {
	warn = function(msg)
		return print("[WARNING]", msg)
	end,
	error = function(msg)
		return print("[ERROR]", msg)
	end,
}
-- Constants
local NOTPENDING = {}
local CURRENT = 0
local STALE = 1
local RUNNING = 2
local CurrBench = nil
--[[
	*
	 * # Benchmarking function
	 * Benchmarks a function by running it and measuring the time taken to execute it, as well as the number of computations,
	 * reads, writes and disposes that occurred during the execution.
	 * 
	 * @param fn Function to benchmark, all computations must be synchronous, and context must not be frozen
	 * @param logs Whether to log the results or not, defaults to true
	 * @returns A tuple of the result of the function and a BenchmarkResult object containing the number of computations, reads, writes, disposes and execution time in milliseconds
	 
]]
local function benchmark(fn, logs)
	if logs == nil then
		logs = true
	end
	local startTime = os.clock()
	local oldBench = CurrBench
	local bench = {
		computations = 0,
		reads = 0,
		writes = 0,
		disposes = 0,
		execTime = 0,
	}
	local result
	CurrBench = bench
	TS.try(function()
		result = fn()
	end, nil, function()
		bench.execTime = (os.clock() - startTime) * 1000
		if oldBench ~= nil then
			oldBench.computations += bench.computations
			oldBench.reads += bench.reads
			oldBench.writes += bench.writes
			oldBench.disposes += bench.disposes
		end
		CurrBench = oldBench
	end)
	if logs then
		print(`[SIGNAL-BENCH] Time taken: {bench.execTime}ms, Computations: {bench.computations}, Reads: {bench.reads}, Writes: {bench.writes}, Disposes: {bench.disposes}`)
	end
	return { result, bench }
end
local Listener = nil
local LastNode = nil
local Owner = nil
--[[
	*
	 * # Get owner
	 * @returns The current running computation node owning the current context, or undefined if there is none
	 
]]
local function getOwner()
	local owner = Owner
	-- prevent recycling the node bc can be used in async gaps.
	if owner ~= nil and owner.kept == false then
		owner.kept = true
		local clean = function()
			owner.kept = false
			return owner.kept
		end
		if owner.cleanups ~= nil then
			owner.cleanups[#owner.cleanups + 1] = clean
		else
			owner.cleanups = { clean }
		end
	end
	return owner
end
--[[
	*
	 * # Run with owner
	 * Runs a function with a given owner, and restores the previous owner after the function is executed.
	 * This is useful in asynchronous contexts where the owner will be undefined, allows to create new 
	 * computations owned by the given owner, to allow them to be disposed when the owner is disposed.
	 * 
	 * @param owner The new computation node owner to define during the function execution 
	 * @param fn The function to execute with the new owner
	 * @returns The result of the function execution
	 
]]
local function runWithOwner(owner, fn)
	local prevOwner = Owner
	Owner = owner
	local _exitType, _returns = TS.try(function()
		return TS.TRY_RETURN, { fn() }
	end, nil, function()
		Owner = prevOwner
	end)
	if _exitType then
		return unpack(_returns)
	end
end
--[[
	*
	 * # ComputationNode class
	 * Represents a computation node in the reactive system. It holds the function to be executed, its value, and its state.
	 * It also manages its dependencies and cleanups.
	 
]]
local RootClock, updateNode, logComputationRead, RootClockProxy
local ComputationNode
do
	ComputationNode = setmetatable({}, {
		__tostring = function()
			return "ComputationNode"
		end,
	})
	ComputationNode.__index = ComputationNode
	function ComputationNode.new(...)
		local self = setmetatable({}, ComputationNode)
		return self:constructor(...) or self
	end
	function ComputationNode:constructor()
		self.fn = nil
		self.value = nil
		self.age = -1
		self.state = CURRENT
		self.source1 = nil
		self.source1slot = 0
		self.sources = nil
		self.sourceslots = nil
		self.log = nil
		self.owned = nil
		self.cleanups = nil
		self.context = {}
		self.kept = false
		self.current = function(untrack, _)
			if Listener ~= nil then
				if self.age == RootClock.time then
					if self.state == RUNNING then
						error("circular dependency")
					else
						updateNode(self)
					end
				end
				if not untrack then
					logComputationRead(self)
				end
			end
			return self.value
		end
	end
	function ComputationNode:clock()
		return RootClockProxy
	end
	function ComputationNode:apply(fn)
		return runWithOwner(self, fn)
	end
end
local UNOWNED = ComputationNode.new()
--[[
	*
	 * # Get candidate node
	 * Gets the last recycled node, or creates a new one if there is none.
	 * This is used to create new computations nodes to provide as root for new computations.
	 * @returns The current running computation node, or undefined if there is none
	 
]]
local function getCandidateNode()
	local node = LastNode
	if node == nil then
		node = ComputationNode.new()
	end
	LastNode = nil
	local _condition = Owner
	if _condition then
		-- ▼ ReadonlyMap.size ▼
		local _size = 0
		for _ in Owner.context do
			_size += 1
		end
		-- ▲ ReadonlyMap.size ▲
		_condition = _size > 0
	end
	if _condition then
		for k, v in Owner.context do
			node.context[k] = v
		end
	end
	return node
end
--[[
	*
	 * # Create root
	 * Will create a new computation node with the given function, and will run it immediately.
	 * The node will be the base of a new computation tree, and will be disposed when the given
	 * dispose function will be executed.
	 * @param fn Function where the new owner will be defined, and will be executed immediately, with the given dispose function at first parameter
	 * @returns The result of the function execution
	 
]]
local RunningClock, dispose, recycleOrClaimNode
local function createRoot(fn)
	local root = getCandidateNode()
	local result
	local owner = Owner
	local disposer = function()
		return if root == nil then nil elseif RunningClock ~= nil then RootClock.disposes:add(root) else dispose(root)
	end
	Owner = root
	TS.try(function()
		result = fn(disposer)
	end, nil, function()
		Owner = owner
	end)
	if recycleOrClaimNode(root, nil, nil, true) then
		root = nil
	end
	return result
end
local createComputationResult = {
	node = nil,
	value = nil,
}
--[[
	*
	 * # Make computation node
	 * Creates a new computation node with the given function and initial value. The node will be owned 
	 * by the current owner, and will be disposed when the owner is disposed, unless orphaned.
	 * The computation will be executed immediately with the initial value, and will track its dependencies, unless untracked.
	 * 
	 * @warn Prefer using createEffect or createMemo instead of this function, as it is not meant to be used directly, exposed for more advanced use cases.
	 * @warn Creating a computations without any owner will never be disposed, and will leak memory.
	 * @param fn Function to execute on initialization and when any of its dependencies change, will be passed the last execution value as first parameter.
	 * @param value Initial value of the computation, will be passed to the function on first execution
	 * @param orphan Whether the computation is orphaned or not, if true, the computation will not be disposed when the owner is disposed
	 * @param sample Whether the computation is sampled or not, if true, the computation will not track its dependencies
	 * @returns 
	 
]]
local execToplevelComputation, finishToplevelComputation
local function createComputation(fn, value, orphan, untrack)
	if Owner == nil then
		console.warn("computations created without a root or parent will never be disposed")
	end
	local node = getCandidateNode()
	local owner = Owner
	local listener = Listener
	local toplevel = RunningClock == nil
	Owner = node
	Listener = if untrack then nil else node
	value = if toplevel then execToplevelComputation(fn, value) else fn(value)
	Owner = owner
	Listener = listener
	local recycled = recycleOrClaimNode(node, fn, value, orphan)
	if toplevel then
		finishToplevelComputation(owner, listener)
	end
	createComputationResult.node = if recycled then nil else node
	createComputationResult.value = value
	return createComputationResult
end
--[[
	*
	 * # DataNode class
	 * Represents a data node in the reactive system. It holds the value of the node, its state, and its dependencies.
	 * It also manages its cleanups and updates.
	 
]]
local logDataRead, event
local DataNode
do
	DataNode = setmetatable({}, {
		__tostring = function()
			return "DataNode"
		end,
	})
	DataNode.__index = DataNode
	function DataNode.new(...)
		local self = setmetatable({}, DataNode)
		return self:constructor(...) or self
	end
	function DataNode:constructor(value, signalPredicate)
		if signalPredicate == nil then
			signalPredicate = true
		end
		self.value = value
		self.signalPredicate = signalPredicate
		self.pending = NOTPENDING
		self.log = nil
		self.current = function(untrack, instantaneous)
			if not untrack and Listener ~= nil then
				logDataRead(self)
			end
			if CurrBench ~= nil then
				CurrBench.reads += 1
			end
			return if instantaneous then self:getInstantaneousValue() else self.value
		end
	end
	function DataNode:getInstantaneousValue()
		if self.pending == NOTPENDING then
			return self.value
		else
			return self.pending
		end
	end
	function DataNode:shouldUpdate(a, b)
		-- Most common case first (direct equality check)
		if self.signalPredicate == true then
			return a ~= b
		end
		-- Less common cases
		if self.signalPredicate == false then
			return true
		end
		return not self.signalPredicate(a, b)
	end
	function DataNode:next(value)
		if not self:shouldUpdate(if self.pending == NOTPENDING then self.value else self.pending, value) then
			return value
		end
		-- Batched case
		if RunningClock ~= nil then
			local notPending = self.pending == NOTPENDING
			self.pending = value
			if notPending then
				RootClock.changes:add(self)
			end
		else
			if self.log ~= nil then
				self.pending = value
				RootClock.changes:add(self)
				event()
			else
				if CurrBench ~= nil then
					CurrBench.writes += 1
				end
				self.value = value
			end
		end
		return value
	end
	function DataNode:clock()
		return RootClockProxy
	end
end
--[[
	*
	 * # Make data node
	 * Creates a new data node with the given value and options. The node will be owned by the current owner, and will be disposed when the owner is disposed.
	 * 
	 * @param value The value of the data node
	 * @param options The options to be passed to the data node, including the eq function
	 * @returns The new data node
	 
]]
local function makeDataNode(value, options)
	local _exp = value
	local _result = options
	if _result ~= nil then
		_result = _result.eq
	end
	local _condition = _result
	if _condition == nil then
		_condition = true
	end
	return DataNode.new(_exp, _condition)
end
--[[
	*
	 * # Make lazy data node
	 * Creates a new lazy data node with the given value and options. The node will be created when it is first got using the accessor function.
	 * the owner used for disposal is the one that was defined at the moment of makeLazyDataNode was called, and if it was no owner at this moment,
	 * the owner used will be the one that is defined at first call of the accessor function.
	 * A lazy option is provided, when false, the node will be created directly.
	 * 
	 * @param value The accessor function to be called when the node is first accessed
	 * @param options The options to be passed to the data node, including the eq function and lazy option
	 * @returns An accessor function that will return the data node when called
	 
]]
local function makeLazyDataNode(value, options)
	local node = if options == nil or options.lazy ~= false then nil else makeDataNode(value, options)
	local owner = Owner
	return function()
		if node ~= nil then
			return node
		end
		local _owner = Owner
		Owner = owner or _owner
		local _exitType, _returns = TS.try(function()
			node = makeDataNode(value, options)
			return TS.TRY_RETURN, { node }
		end, nil, function()
			Owner = _owner
		end)
		if _exitType then
			return unpack(_returns)
		end
	end
end
--[[
	*
	 * # Create signal
	 * Makes a signal using a DataNode, with an user-friendly interface.
	 * If lazy is set to true (default), the signal will be created when it is first accessed, cf: {@link makeLazyDataNode}
	 * 
	 * @param value The first value of the signal
	 * @param options The options to be passed to the signal, including the eq function and lazy option
	 * @returns A signal object
	 
]]
local function createSignal(value, options)
	local node = makeLazyDataNode(value, options)
	return setmetatable({
		SIGNAL = true,
	}, {
		__call = withArgCount(function(argCount, _, value)
			if argCount == 1 then
				return node().current()
			else
				return node():next(value)
			end
		end),
		__index = function(target, key)
			if key == "val" then
				return node().current()
			elseif key == "set" then
				return function(fn)
					return node():next(fn(node():getInstantaneousValue()))
				end
			elseif key == "peek" then
				return node().current(true)
			elseif key == "accessor" then
				return node().current
			end
			return target[key]
		end,
		__newindex = function(_, key, value)
			if key == "val" then
				node():next(value)
			end
		end,
		__metatable = nil,
	})
end
local function isSignal(signal)
	local _signal = signal
	local _condition = type(_signal) == "table"
	if _condition then
		_condition = signal.SIGNAL == true
	end
	return _condition
end
--[[
	*
	 * # Make memo node
	 * Like {@link makeDataNode}, will create a new data node with the given value and options, but will also create
	 * a new computation node with the given function, that will update the data node anytime its dependencies change.
	 * 
	 * @warn memo is batched, see {@link batch} for more information
	 * @warn Like any computations, creating a computations without any owner will never be disposed, and will leak memory.
	 * @param fn The function to be executed when any of its dependencies change, will update its signal value.
	 * @param value The initial value of the memo, will be passed to the function on first execution.
	 * @param options The options to be passed to the data node, including the eq function
	 * @returns 
	 
]]
local function makeMemoNode(fn, value, options)
	local dataNode
	local computationNode = createComputation(function(V)
		local newVal = fn(V)
		if dataNode then
			dataNode:next(newVal)
		end
		return newVal
	end, value, false, false)
	dataNode = makeDataNode(computationNode.value, options)
	return dataNode
end
--[[
	*
	 * # Make lazy memo node
	 * Like {@link makeMemoNode}, but with {@link makeLazyDataNode} behavior.
	 * 
	 * @warn memo is batched, see {@link batch} for more information
	 * @warn Like any computations, creating a computations without any owner will never be disposed, and will leak memory.
	 * @param fn The function to be executed when any of its dependencies change, will update its signal value.
	 * @param value The initial value of the memo, will be passed to the function on first execution.
	 * @param options The options to be passed to the data node, including the eq function
	 * @returns 
	 
]]
local function makeLazyMemoNode(fn, value, options)
	local node = if options == nil or options.lazy ~= false then nil else makeMemoNode(fn, value, options)
	local owner = Owner
	return function()
		if node ~= nil then
			return node
		end
		local _owner = Owner
		Owner = owner or _owner
		local _exitType, _returns = TS.try(function()
			node = makeMemoNode(fn, value, options)
			return TS.TRY_RETURN, { node }
		end, nil, function()
			Owner = _owner
		end)
		if _exitType then
			return unpack(_returns)
		end
	end
end
--[[
	*
	 * # Create Memo
	 * Creates a memoized function that will be executed when any of its dependencies change.
	 * The memoized will act as a computation that updates a signal value, and will be disposed when the owner is disposed.
	 * 
	 * @warn memo is batched, see {@link batch} for more information
	 * @warn Like any computations, creating a computations without any owner will never be disposed, and will leak memory.
	 * @param fn The function to be executed when any of its dependencies change, will update its data node value, will get the current value of the signal as first parameter
	 * @param value The initial value of the memo, will be passed to the function on first execution
	 * @param options 
	 
]]
local function createMemo(fn, value, options)
	local node = makeLazyMemoNode(fn, value, options)
	return setmetatable({
		SIGNAL = false,
	}, {
		__call = function()
			return node().current()
		end,
		__index = function(target, key)
			if key == "val" then
				return node().current()
			elseif key == "peek" then
				return node().current(true)
			elseif key == "accessor" then
				return node().current
			end
			return target[key]
		end,
		__newindex = function(_, key, value)
			if key == "val" then
				node():next(value)
			end
		end,
		__metatable = nil,
	})
end
local function isReadonlySignal(signal)
	local _signal = signal
	if not (type(_signal) == "table") then
		return false
	end
	local is = signal.SIGNAL
	return is == false or is == true
end
--[[
	*
	 * # Untrack
	 * Disable listener during the function execution, so it won't track any dependencies. This is useful to avoid unnecessary updates
	 * 
	 * @param fn The function to be executed without tracking
	 * @returns The result of the function execution
	 
]]
local function untrack(fn)
	-- Fast path: if no listener is active, avoid temporary variable overhead
	if Listener == nil then
		return fn()
	end
	local result
	local listener = Listener
	Listener = nil
	TS.try(function()
		result = fn()
	end, nil, function()
		Listener = listener
	end)
	return result
end
--[[
	*
	 * # Create effect
	 * Creates a new effect that will be executed when any of its dependencies change. returns a function that will get the effect result.
	 * 
	 * @warn createEffect is batched, see {@link batch} for more information
	 * @warn Like any computations, creating a computations without any owner will never be disposed, and will leak memory.
	 * @param fn The function to be executed when any of its dependencies change, will be passed the last execution value as first parameter
	 * @param value The initial value of the effect, will be passed to the function on first execution
	 * @returns A function that will get the effect result
	 
]]
local function createEffect(fn, value)
	local _binding = createComputation(fn, value, false, false)
	local node = _binding.node
	local _value = _binding.value
	return if node == nil then function()
		return _value
	end else node.current
end
--[[
	*
	 * # On
	 * This function help to keep control of tracking, by using the first function to track dependencies, and the second one to transform
	 * the first function's result, and old computation result as second parameter, in an untracked scope, returns a function to give to 
	 * any computation.
	 * Defer option is used to wait for the first change in the first function to execute the second one, so initialisation will not 
	 * execute the second function if defer is true.
	 * 
	 * @param on Tracking function, will be called to track dependencies
	 * @param fn Transform function, will be called to transform the first function's result and old computation result
	 * @param options Options to be passed to the function, including the defer option
	 * @returns 
	 
]]
local function on(on, fn, options)
	local onchanges = if options ~= nil then options.defer == true else false
	return function(old)
		local listener = Listener
		local input = on()
		if onchanges then
			onchanges = false
			return nil
		else
			Listener = nil
			local value = fn(input, old)
			Listener = listener
			return value
		end
	end
end
--[[
	*
	 * # batch
	 * Executes a function in a batch, so all changes will be applied at once, and will not trigger any updates until the batch is finished.
	 * Nesting batches is allowed, but will have no more effect than a single batch.
	 * 
	 * @note createEffect and createMemo are already batched, so this function is not needed in most cases.
	 * @param fn The function to be executed in a batch
	 * @returns The result of the function execution
	 
]]
local function batch(fn)
	-- Fast path - if already in a batch, just run the function directly
	if RunningClock ~= nil then
		return fn()
	end
	-- New batch - set up clock and run
	RunningClock = RootClock
	RunningClock.changes:reset()
	local result
	TS.try(function()
		result = fn()
		event()
	end, nil, function()
		RunningClock = nil
	end)
	return result
end
--[[
	*
	 * # On cleanup
	 * Adds a cleanup function to the current owner, that will be executed when the owner is disposed.
	 * 
	 * @param fn The function to execute when the owner is disposed 
	 
]]
local function onCleanup(fn)
	if Owner == nil then
		console.warn("cleanups created without a root or parent will never be run")
	elseif Owner.cleanups == nil then
		Owner.cleanups = { fn }
	else
		Owner.cleanups[#Owner.cleanups + 1] = fn
	end
end
--[[
	*
	 * # Dispose
	 * a function to manually dispose a node, and all its dependencies.
	 * 
	 * @param node The node to dispose
	 
]]
local function disposeNode(node)
	if node == nil then
		return nil
	end
	if RunningClock ~= nil then
		RootClock.disposes:add(node)
	else
		dispose(node)
	end
end
--[[
	*
	 * # Is batching
	 * Checks if the current context is in a batch or not, and returns true if it is.
	 
]]
local function isBatching()
	return RunningClock ~= nil
end
--[[
	*
	 * # Is listening
	 * Checks if the current context is listening or not, and returns true if it is.
	 
]]
local function isListening()
	return Listener ~= nil
end
--[[
	*
	 * #Context class
	 * Represents a context in the reactive system. It holds a value and allows to run a function with the context value.
	 
]]
local Context
do
	Context = setmetatable({}, {
		__tostring = function()
			return "Context"
		end,
	})
	Context.__index = Context
	function Context.new(...)
		local self = setmetatable({}, Context)
		return self:constructor(...) or self
	end
	function Context:constructor(value)
		self.value = value
		self.symbol = {}
	end
	function Context:getValue()
		local _result = Owner
		if _result ~= nil then
			local _context = _result.context
			local _symbol = self.symbol
			_result = _context[_symbol]
		end
		local _condition = _result
		if _condition == nil then
			_condition = self.value
		end
		return _condition
	end
	function Context:populate(value)
		if Owner ~= nil then
			local _context = Owner.context
			local _symbol = self.symbol
			local _value = value
			_context[_symbol] = _value
		end
	end
	function Context:apply(value, callback, tracks)
		if tracks == nil then
			tracks = false
		end
		local _binding = createComputation(function()
			self:populate(value)
			return callback()
		end, nil, false, not tracks)
		local _value = _binding.value
		return _value
	end
	function Context:Provider(props)
		return self:apply(props.Value, function()
			return props.Children
		end)
	end
end
--[[
	*
	 * # Create context
	 * Creates a new context with the given value. The context can be used to run a function with the context value.
	 * 
	 * @param value The value of the context
	 * @returns The new context
	 
]]
local function createContext(value)
	return Context.new(value)
end
--[[
	*
	 * # Get context
	 * Gets the current context value. If the context is not defined, it will return the default value of the context.
	 * 
	 * @param context The context to get the value from
	 * @returns The current context value
	 
]]
local function useContext(context)
	return context:getValue()
end
--[[
	*
	 * # Create cache
	 * Cache a value to avoid executing the function multiple times.
	 * Useful to execute a function in another context, but avoiding to execute it multiple times.
	 * Cache is resettable using the second function returned.
	 * @param fn Function to be executed to get the value of the cache
	 * @returns A function that will return the cached value, and a function to clear the cache
	 
]]
local function createCache(fn)
	local value = nil
	local cache = function()
		if value == nil then
			value = fn()
		end
		return value
	end
	onCleanup(function()
		value = nil
		return value
	end)
	return { cache, function()
		value = nil
	end }
end
--/ Graph classes and operations
local Log
do
	Log = setmetatable({}, {
		__tostring = function()
			return "Log"
		end,
	})
	Log.__index = Log
	function Log.new(...)
		local self = setmetatable({}, Log)
		return self:constructor(...) or self
	end
	function Log:constructor()
		self.node1 = nil
		self.node1slot = 0
		self.nodes = nil
		self.nodeslots = nil
	end
end
local Queue
do
	Queue = setmetatable({}, {
		__tostring = function()
			return "Queue"
		end,
	})
	Queue.__index = Queue
	function Queue.new(...)
		local self = setmetatable({}, Queue)
		return self:constructor(...) or self
	end
	function Queue:constructor()
		self.items = {}
		self.count = 0
	end
	function Queue:reset()
		self.count = 0
	end
	function Queue:add(item)
		self.items[self.count + 1] = item
		self.count += 1
	end
	function Queue:run(fn)
		local items = self.items
		for _, item in items do
			fn(item)
		end
		table.clear(items)
		self.count = 0
	end
end
local Clock
do
	Clock = setmetatable({}, {
		__tostring = function()
			return "Clock"
		end,
	})
	Clock.__index = Clock
	function Clock.new(...)
		local self = setmetatable({}, Clock)
		return self:constructor(...) or self
	end
	function Clock:constructor()
		self.time = 0
		self.changes = Queue.new()
		self.updates = Queue.new()
		self.disposes = Queue.new()
	end
end
RootClock = Clock.new()
RunningClock = nil
RootClockProxy = {
	time = function(self)
		return RootClock.time
	end,
}
function execToplevelComputation(fn, _value)
	RunningClock = RootClock
	RootClock.changes:reset()
	RootClock.updates:reset()
	local value = nil
	TS.try(function()
		value = fn(_value)
	end, nil, function()
		RunningClock = nil
		Listener = RunningClock
		Owner = Listener
	end)
	return value
end
local run
function finishToplevelComputation(owner, listener)
	if RootClock.changes.count > 0 or RootClock.updates.count > 0 then
		RootClock.time += 1
		TS.try(function()
			run(RootClock)
		end, nil, function()
			RunningClock = nil
			Owner = owner
			Listener = listener
		end)
	end
end
function recycleOrClaimNode(node, fn, value, orphan)
	-- Get owner if there is one or if not orphaned
	local _owner = if orphan or Owner == UNOWNED then nil else Owner
	-- Node can be recycled if:
	-- 1. It's not being kept
	-- 2. It has no dependencies like data nodes called when it was the Listener
	-- 3. Owns nothing and has no cleanups (no need to dispose) or has an owner to transfer them to
	local recycle = node.kept == false and node.source1 == nil and (node.owned == nil and node.cleanups == nil or _owner ~= nil)
	if recycle then
		-- Mark for reuse
		LastNode = node
		-- If there's any element to transfer, transfer them to the owner, and clear contexts
		-- (owner is logically defined if any transferable data is present, unless it would be not recyclable, cf above)
		if node.owned ~= nil then
			if _owner.owned == nil then
				_owner.owned = node.owned
			else
				for _, ownedNode in node.owned do
					_owner.owned[#_owner.owned + 1] = ownedNode
				end
			end
		end
		if node.cleanups ~= nil then
			if _owner.cleanups == nil then
				_owner.cleanups = node.cleanups
			else
				for _, cleanup in node.cleanups do
					_owner.cleanups[#_owner.cleanups + 1] = cleanup
				end
			end
		end
		node.cleanups = nil
		node.owned = node.cleanups
		table.clear(node.context)
	else
		-- Set the node its own function, value and age (claim it)
		node.fn = fn
		node.value = value
		node.age = RootClock.time
		-- Add node to owner's owned list
		if _owner ~= nil then
			if _owner.owned == nil then
				_owner.owned = { node }
			else
				_owner.owned[#_owner.owned + 1] = node
			end
		end
	end
	return recycle
end
local function logRead(from)
	local to = Listener
	local toslot = if to.source1 == nil then -1 elseif to.sources == nil then 0 else #to.sources
	local fromslot
	if from.node1 == nil then
		from.node1 = to
		from.node1slot = toslot
		fromslot = -1
	elseif from.nodes == nil then
		from.nodes = { to }
		from.nodeslots = { toslot }
		fromslot = 0
	else
		fromslot = #from.nodes
		from.nodes[fromslot + 1] = to
		from.nodeslots[#from.nodeslots + 1] = toslot
	end
	if to.source1 == nil then
		to.source1 = from
		to.source1slot = fromslot
	elseif to.sources == nil then
		to.sources = { from }
		to.sourceslots = { fromslot }
	else
		to.sources[#to.sources + 1] = from
		to.sourceslots[#to.sourceslots + 1] = fromslot
	end
end
function logDataRead(data)
	if data.log == nil then
		data.log = Log.new()
	end
	logRead(data.log)
end
function logComputationRead(node)
	if node.log == nil then
		node.log = Log.new()
	end
	logRead(node.log)
end
function event()
	-- Preserve current owner while running events
	local owner = Owner
	-- Reset updates queue and increment time
	RootClock.updates:reset()
	RootClock.time += 1
	-- Run the clock updates with try/finally to ensure state is restored
	TS.try(function()
		run(RootClock)
	end, nil, function()
		Listener = nil
		RunningClock = Listener
		Owner = owner
	end)
end
local applyDataChange
function run(clock)
	local running = RunningClock
	local count = 0
	RunningClock = clock
	clock.disposes:reset()
	-- for each batch ...
	while clock.changes.count ~= 0 or clock.updates.count ~= 0 or clock.disposes.count ~= 0 do
		if count > 0 then
			clock.time += 1
		end
		clock.changes:run(applyDataChange)
		clock.updates:run(updateNode)
		clock.disposes:run(dispose)
		-- if there are still changes after excessive batches, assume runaway
		count += 1
		if count > 1e5 then
			error("Runaway clock detected")
		end
	end
	RunningClock = running
end
local markComputationsStale
function applyDataChange(data)
	if CurrBench ~= nil then
		CurrBench.writes += 1
	end
	data.value = data.pending
	data.pending = NOTPENDING
	if data.log then
		markComputationsStale(data.log)
	end
end
local markNodeStale
function markComputationsStale(log)
	local node1 = log.node1
	local nodes = log.nodes
	-- mark all downstream nodes stale which haven't been already
	if node1 ~= nil then
		markNodeStale(node1)
	end
	if nodes ~= nil then
		for _, node in nodes do
			markNodeStale(node)
		end
	end
end
local markOwnedNodesForDisposal
function markNodeStale(node)
	local time = RootClock.time
	if node.age >= time then
		return nil
	end
	node.age = time
	node.state = STALE
	RootClock.updates:add(node)
	-- Handle owned nodes if any
	if node.owned ~= nil then
		markOwnedNodesForDisposal(node.owned)
	end
	-- Mark downstream nodes if any
	if node.log ~= nil then
		markComputationsStale(node.log)
	end
end
function markOwnedNodesForDisposal(owned)
	for _, node in owned do
		node.age = RootClock.time
		node.state = CURRENT
		if node.owned ~= nil then
			markOwnedNodesForDisposal(node.owned)
		end
	end
end
local cleanupNode
function updateNode(node)
	-- Fast return if node isn't stale - avoid further checks
	if node.state ~= STALE then
		return nil
	end
	local owner = Owner
	local listener = Listener
	Listener = node
	Owner = Listener
	node.state = RUNNING
	cleanupNode(node, false)
	if CurrBench ~= nil then
		CurrBench.computations += 1
	end
	node.value = node.fn(node.value)
	node.state = CURRENT
	Owner = owner
	Listener = listener
end
local cleanupSource
function cleanupNode(node, final)
	if node.cleanups ~= nil then
		for _, cleanup in node.cleanups do
			cleanup(final)
		end
		node.cleanups = nil
	end
	if node.owned ~= nil then
		for _, ownedNode in node.owned do
			dispose(ownedNode)
		end
		node.owned = nil
	end
	if node.source1 ~= nil then
		cleanupSource(node.source1, node.source1slot)
		node.source1 = nil
	end
	if node.sources ~= nil and node.sourceslots ~= nil then
		for i = 0, #node.sources - 1 do
			local _exp = node.sources
			-- ▼ Array.pop ▼
			local _length = #_exp
			local _result = _exp[_length]
			_exp[_length] = nil
			-- ▲ Array.pop ▲
			local _exp_1 = node.sourceslots
			-- ▼ Array.pop ▼
			local _length_1 = #_exp_1
			local _result_1 = _exp_1[_length_1]
			_exp_1[_length_1] = nil
			-- ▲ Array.pop ▲
			cleanupSource(_result, _result_1)
		end
	end
end
function cleanupSource(source, slot)
	if slot == -1 then
		source.node1 = nil
	else
		local last = source.nodes[#source.nodes]
		local lastslot = source.nodeslots[#source.nodeslots]
		source.nodes[#source.nodes] = nil
		source.nodeslots[#source.nodeslots] = nil
		if slot ~= #source.nodes then
			source.nodes[slot + 1] = last
			source.nodeslots[slot + 1] = lastslot
			if lastslot == -1 then
				last.source1slot = slot
			else
				last.sourceslots[lastslot + 1] = slot
			end
		end
	end
end
function dispose(node)
	node.fn = nil
	node.log = nil
	cleanupNode(node, true)
	if CurrBench ~= nil then
		CurrBench.disposes += 1
	end
end
return {
	benchmark = benchmark,
	getOwner = getOwner,
	runWithOwner = runWithOwner,
	getCandidateNode = getCandidateNode,
	createRoot = createRoot,
	createComputation = createComputation,
	makeDataNode = makeDataNode,
	makeLazyDataNode = makeLazyDataNode,
	createSignal = createSignal,
	isSignal = isSignal,
	makeMemoNode = makeMemoNode,
	makeLazyMemoNode = makeLazyMemoNode,
	createMemo = createMemo,
	isReadonlySignal = isReadonlySignal,
	untrack = untrack,
	createEffect = createEffect,
	on = on,
	batch = batch,
	onCleanup = onCleanup,
	disposeNode = disposeNode,
	isBatching = isBatching,
	isListening = isListening,
	createContext = createContext,
	useContext = useContext,
	createCache = createCache,
	ComputationNode = ComputationNode,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="288">
                <Properties>
                  <string name="Name">store</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "mutable") or {} do
	exports[_k] = _v
end
return exports
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="289">
                  <Properties>
                    <string name="Name">mutable</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local _jsnatives = TS.import(script, TS.getModule(script, "@rbxts", "jsnatives").out)
local ArrayUtils = _jsnatives.ArrayUtils
local Object = _jsnatives.Object
local Proxy = _jsnatives.Proxy
local _signals = TS.import(script, script.Parent.Parent, "signals")
local makeDataNode = _signals.makeDataNode
local isListening = _signals.isListening
local untrack = _signals.untrack
local batch = _signals.batch
local objectNodes = setmetatable({}, {
	__mode = "k",
})
local objectProxies = setmetatable({}, {
	__mode = "k",
})
local function getNodes(obj)
	local _obj = obj
	local nodes = objectNodes[_obj]
	if not nodes then
		local _exp = obj
		nodes = {}
		local _nodes = nodes
		objectNodes[_exp] = _nodes
	end
	return nodes
end
local function getNode(nodes, key, value)
	local node = nodes[key]
	if not node then
		node = makeDataNode(value, {
			eq = false,
		})
		nodes[key] = node
	end
	return node
end
local SELF
local trackSelf = function(obj)
	return isListening() and getNode(getNodes(obj), SELF).current()
end
local updateSelf = function(obj)
	local _result = getNodes(obj)[SELF]
	if _result ~= nil then
		_result = _result:next(nil)
	end
	return _result
end
local isWrappable = function(obj)
	local _obj = obj
	if not (type(_obj) == "table") then
		return false
	end
	local meta = getmetatable(obj)
	if meta == nil then
		return true
	end
	return false
end
local PROXY
local isWrapped = function(obj)
	local _obj = obj
	if not (type(_obj) == "table") then
		return false
	end
	local meta = getmetatable(obj)
	if meta == nil or meta[PROXY] ~= true then
		return false
	end
	return true
end
local RAW = {}
local TRACK = {}
SELF = {}
PROXY = {}
local RAW_TRACKED = {}
local function unwrap(obj, untracks)
	if untracks == nil then
		untracks = true
	end
	if untracks then
		return untrack(function()
			return unwrap(obj, false)
		end)
	end
	if not isWrapped(obj) then
		return obj
	end
	if ArrayUtils.isArray(obj) then
		local newObj = {}
		for _, val in obj do
			newObj[#newObj + 1] = unwrap(val)
		end
		return newObj
	else
		local newObj = {}
		for _, _binding in Object.entries(obj) do
			local key = _binding[1]
			local value = _binding[2]
			newObj[key] = unwrap(value)
		end
		return newObj
	end
end
local function trackAll(obj)
	if not isWrapped(obj) then
		return nil
	end
	for _, value in Object.values(obj) do
		trackAll(value)
	end
end
local function withWrap(obj)
	if isWrapped(obj) then
		return obj
	end
	local _obj = obj
	local proxy = objectProxies[_obj]
	if proxy then
		return proxy
	end
	return obj
end
local function withoutWrap(obj, untracked)
	if untracked == nil then
		untracked = true
	end
	if isWrapped(obj) then
		if untracked then
			return obj[RAW]
		end
		return obj[RAW_TRACKED]
	end
	return obj
end
local function wrap(target)
	if not isWrappable(target) then
		return target
	end
	local _target = target
	local proxy = objectProxies[_target]
	if proxy then
		return proxy
	end
	proxy = Proxy.new(target, {
		get = function(target, key, proxy)
			if key == RAW then
				return target
			end
			if key == TRACK then
				return trackSelf(target)
			end
			if key == RAW_TRACKED then
				trackAll(proxy)
				return target
			end
			local nodes = getNodes(target)
			local tracked = nodes[key]
			local value = if tracked == nil then target[key] else tracked.current(false, true)
			if tracked == nil and isListening() then
				value = getNode(nodes, key, value).current(false, true)
			end
			return wrap(value)
		end,
		set = function(target, key, value, proxy)
			if key == RAW then
				return true
			end
			if key == TRACK then
				return true
			end
			if key == RAW_TRACKED then
				return true
			end
			local _value = value
			value = if type(_value) == "table" then withoutWrap(value) else value
			local current = target[key]
			if current == value then
				return true
			end
			untrack(function()
				batch(function()
					local _value_1 = value
					local _condition = type(_value_1) == "table"
					if _condition then
						_condition = type(current) == "table" and ArrayUtils.isArray(value) == ArrayUtils.isArray(current)
					end
					if _condition then
						local proxyCurrent = proxy[key]
						local anyStructuralChangeMade = false
						if ArrayUtils.isArray(value) and ArrayUtils.isArray(current) then
							local currSize = #current
							local newSize = #value
							do
								local i = 0
								local _shouldIncrement = false
								while true do
									if _shouldIncrement then
										i += 1
									else
										_shouldIncrement = true
									end
									if not (i < newSize or i < currSize) then
										break
									end
									local newVal = value[i + 1]
									local currVal = current[i + 1]
									if newVal ~= currVal then
										proxyCurrent[i] = newVal
									end
								end
							end
							anyStructuralChangeMade = newSize ~= currSize
						else
							local _set = {}
							for _, _v in Object.keys(current) do
								_set[_v] = true
							end
							local currentKeys = _set
							for _, _binding in Object.entries(value) do
								local key = _binding[1]
								local val = _binding[2]
								local currVal = current[key]
								if currVal ~= val then
									proxyCurrent[key] = val
								end
								if not (currentKeys[key] ~= nil) and val ~= nil then
									anyStructuralChangeMade = true
								else
									currentKeys[key] = nil
									if currVal == nil then
										anyStructuralChangeMade = true
									end
								end
							end
							-- ▼ ReadonlySet.size ▼
							local _size = 0
							for _ in currentKeys do
								_size += 1
							end
							-- ▲ ReadonlySet.size ▲
							if _size > 0 then
								anyStructuralChangeMade = true
								for key in currentKeys do
									proxyCurrent[key] = nil
								end
							end
						end
						if anyStructuralChangeMade then
							getNode(getNodes(target), key, value):next(current)
							updateSelf(current)
						end
					else
						target[key] = value
						local nodes = getNodes(target)
						local node = getNode(nodes, key, value)
						if node ~= nil then
							node:next(value)
						end
						updateSelf(target)
					end
				end)
			end)
			return true
		end,
	}, {}, {
		[PROXY] = true,
	})
	local _target_1 = target
	local _proxy = proxy
	objectProxies[_target_1] = _proxy
	return proxy
end
local createMutable = function(obj)
	return wrap(obj)
end
return {
	unwrap = unwrap,
	trackAll = trackAll,
	withWrap = withWrap,
	withoutWrap = withoutWrap,
	RAW = RAW,
	TRACK = TRACK,
	SELF = SELF,
	PROXY = PROXY,
	RAW_TRACKED = RAW_TRACKED,
	createMutable = createMutable,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="290">
            <Properties>
              <string name="Name">t</string>
            </Properties>
            <Item class="Folder" referent="291">
              <Properties>
                <string name="Name">lib</string>
              </Properties>
              <Item class="ModuleScript" referent="292">
                <Properties>
                  <string name="Name">ts</string>
                  <string name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

local t = {}

function t.type(typeName)
	return function(value)
		local valueType = type(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

function t.typeof(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = t.typeof("boolean")

--[[**
	ensures Lua primitive buffer type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.buffer = t.typeof("buffer")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = t.typeof("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = t.typeof("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = t.typeof("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = t.typeof("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = t.typeof("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = t.type("userdata")

--[[**
	ensures Lua primitive vector type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.vector = t.type("vector")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false
		end
	else
		return false
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value ~= value then
			return true
		else
			return false
		end
	else
		return false
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = t.typeof("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = t.typeof("BrickColor")

--[[**
	ensures Roblox CatalogSearchParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CatalogSearchParams = t.typeof("CatalogSearchParams")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = t.typeof("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = t.typeof("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = t.typeof("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = t.typeof("ColorSequenceKeypoint")

--[[**
	ensures Roblox DateTime type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DateTime = t.typeof("DateTime")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = t.typeof("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = t.typeof("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = t.typeof("EnumItem")

--[[**
	ensures Roblox Enums type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enums = t.typeof("Enums")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = t.typeof("Faces")

--[[**
	ensures Roblox FloatCurveKey type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.FloatCurveKey = t.typeof("FloatCurveKey")

--[[**
	ensures Roblox Font type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Font = t.typeof("Font")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = t.typeof("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = t.typeof("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = t.typeof("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = t.typeof("NumberSequenceKeypoint")

--[[**
	ensures Roblox OverlapParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.OverlapParams = t.typeof("OverlapParams")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = t.typeof("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = t.typeof("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = t.typeof("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = t.typeof("Ray")

--[[**
	ensures Roblox RaycastParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastParams = t.typeof("RaycastParams")

--[[**
	ensures Roblox RaycastResult type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastResult = t.typeof("RaycastResult")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = t.typeof("RBXScriptConnection")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = t.typeof("RBXScriptSignal")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = t.typeof("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = t.typeof("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = t.typeof("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = t.typeof("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = t.typeof("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = t.typeof("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = t.typeof("Vector2")

--[[**
	ensures Roblox Vector2int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2int16 = t.typeof("Vector2int16")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = t.typeof("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = t.typeof("Vector3int16")

--[[**
	ensures value is any of the given literal values

	@param literals The literals to check against

	@returns A function that will return true if the condition is passed
**--]]
function t.literalList(literals)
	-- optimization for primitive types
	local set = {}
	for _, literal in ipairs(literals) do
		set[literal] = true
	end
	return function(value)
		if set[value] then
			return true
		end
		for _, literal in ipairs(literals) do
			if literal == value then
				return true
			end
		end

		return false
	end
end

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.unionList(literals)
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success = t.number(value)
	if not success then
		return false
	end

	if value % 1 == 0 then
		return true
	else
		return false
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value >= min then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value <= max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if min < value then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value < max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess = t.string(value)
		if not stringSuccess then
			return false
		end

		if string.match(value, pattern) == nil then
			return false
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success = check(value)
		if success then
			return true
		else
			return false
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success = check(args[i])
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for key in pairs(value) do
			local success = check(key)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for _, val in pairs(value) do
			local success = check(val)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess = keyChecker(value)
		if not keySuccess then
			return false
		end

		local valueSuccess = valueChecker(value)
		if not valueSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false
				end
			end

			local valueSuccess = valuesCheck(value)
			if not valueSuccess then
				return false
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess = typeFn(value[idx])
				if not typeSuccess then
					return false
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param checks The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.unionList(checks)
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false
		end
	end

--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		return t.unionList({ ... })
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param checks The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersectionList(checks)
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success = check(value)
				if not success then
					return false
				end
			end

			return true
		end
	end

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		return t.intersectionList({ ... })
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if value.ClassName ~= className then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if not value:IsA(className) then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess = t.EnumItem(value)
		if not enumItemSuccess then
			return false
		end

		if value.EnumType == enum then
			return true
		else
			return false
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The function to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess = t.Instance(value)
			if not instanceSuccess then
				return false
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success = check(childrenByName[name])
				if not success then
					return false
				end
			end

			return true
		end
	end
end

return { t = t }
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="293">
            <Properties>
              <string name="Name">testez</string>
            </Properties>
            <Item class="ModuleScript" referent="294">
              <Properties>
                <string name="Name">src</string>
                <string name="Source">local Expectation = require(script.Expectation)
local TestBootstrap = require(script.TestBootstrap)
local TestEnum = require(script.TestEnum)
local TestPlan = require(script.TestPlan)
local TestPlanner = require(script.TestPlanner)
local TestResults = require(script.TestResults)
local TestRunner = require(script.TestRunner)
local TestSession = require(script.TestSession)
local TextReporter = require(script.Reporters.TextReporter)
local TextReporterQuiet = require(script.Reporters.TextReporterQuiet)
local TeamCityReporter = require(script.Reporters.TeamCityReporter)

local function run(testRoot, callback)
	local modules = TestBootstrap:getModules(testRoot)
	local plan = TestPlanner.createPlan(modules)
	local results = TestRunner.runPlan(plan)

	callback(results)
end

local TestEZ = {
	run = run,

	Expectation = Expectation,
	TestBootstrap = TestBootstrap,
	TestEnum = TestEnum,
	TestPlan = TestPlan,
	TestPlanner = TestPlanner,
	TestResults = TestResults,
	TestRunner = TestRunner,
	TestSession = TestSession,

	Reporters = {
		TextReporter = TextReporter,
		TextReporterQuiet = TextReporterQuiet,
		TeamCityReporter = TeamCityReporter,
	},
}

return TestEZ</string>
              </Properties>
              <Item class="ModuleScript" referent="295">
                <Properties>
                  <string name="Name">Context</string>
                  <string name="Source"><![CDATA[--[[
	The Context object implements a write-once key-value store. It also allows
	for a new Context object to inherit the entries from an existing one.
]]
local Context = {}

function Context.new(parent)
	local meta = {}
	local index = {}
	meta.__index = index

	if parent then
		for key, value in pairs(getmetatable(parent).__index) do
			index[key] = value
		end
	end

	function meta.__newindex(_obj, key, value)
		assert(index[key] == nil, string.format("Cannot reassign %s in context", tostring(key)))
		index[key] = value
	end

	return setmetatable({}, meta)
end

return Context
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="296">
                <Properties>
                  <string name="Name">Expectation</string>
                  <string name="Source"><![CDATA[--[[
	Allows creation of expectation statements designed for behavior-driven
	testing (BDD). See Chai (JS) or RSpec (Ruby) for examples of other BDD
	frameworks.

	The Expectation class is exposed to tests as a function called `expect`:

		expect(5).to.equal(5)
		expect(foo()).to.be.ok()

	Expectations can be negated using .never:

		expect(true).never.to.equal(false)

	Expectations throw errors when their conditions are not met.
]]

local Expectation = {}

--[[
	These keys don't do anything except make expectations read more cleanly
]]
local SELF_KEYS = {
	to = true,
	be = true,
	been = true,
	have = true,
	was = true,
	at = true,
}

--[[
	These keys invert the condition expressed by the Expectation.
]]
local NEGATION_KEYS = {
	never = true,
}

--[[
	Extension of Lua's 'assert' that lets you specify an error level.
]]
local function assertLevel(condition, message, level)
	message = message or "Assertion failed!"
	level = level or 1

	if not condition then
		error(message, level + 1)
	end
end

--[[
	Returns a version of the given method that can be called with either . or :
]]
local function bindSelf(self, method)
	return function(firstArg, ...)
		if firstArg == self then
			return method(self, ...)
		else
			return method(self, firstArg, ...)
		end
	end
end

local function formatMessage(result, trueMessage, falseMessage)
	if result then
		return trueMessage
	else
		return falseMessage
	end
end

--[[
	Create a new expectation
]]
function Expectation.new(value)
	local self = {
		value = value,
		successCondition = true,
		condition = false,
		matchers = {},
		_boundMatchers = {},
	}

	setmetatable(self, Expectation)

	self.a = bindSelf(self, self.a)
	self.an = self.a
	self.ok = bindSelf(self, self.ok)
	self.equal = bindSelf(self, self.equal)
	self.throw = bindSelf(self, self.throw)
	self.near = bindSelf(self, self.near)

	return self
end

function Expectation.checkMatcherNameCollisions(name)
	if SELF_KEYS[name] or NEGATION_KEYS[name] or Expectation[name] then
		return false
	end

	return true
end

function Expectation:extend(matchers)
	self.matchers = matchers or {}

	for name, implementation in pairs(self.matchers) do
		self._boundMatchers[name] = bindSelf(self, function(_self, ...)
			local result = implementation(self.value, ...)
			local pass = result.pass == self.successCondition

			assertLevel(pass, result.message, 3)
			self:_resetModifiers()
			return self
		end)
	end

	return self
end

function Expectation.__index(self, key)
	-- Keys that don't do anything except improve readability
	if SELF_KEYS[key] then
		return self
	end

	-- Invert your assertion
	if NEGATION_KEYS[key] then
		local newExpectation = Expectation.new(self.value):extend(self.matchers)
		newExpectation.successCondition = not self.successCondition

		return newExpectation
	end

	if self._boundMatchers[key] then
		return self._boundMatchers[key]
	end

	-- Fall back to methods provided by Expectation
	return Expectation[key]
end

--[[
	Called by expectation terminators to reset modifiers in a statement.

	This makes chains like:

		expect(5)
			.never.to.equal(6)
			.to.equal(5)

	Work as expected.
]]
function Expectation:_resetModifiers()
	self.successCondition = true
end

--[[
	Assert that the expectation value is the given type.

	expect(5).to.be.a("number")
]]
function Expectation:a(typeName)
	local result = (typeof(self.value) == typeName) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		),
		("Expected value not of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

-- Make alias public on class
Expectation.an = Expectation.a

--[[
	Assert that our expectation value is not nil
]]
function Expectation:ok()
	local result = (self.value ~= nil) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q to be non-nil"):format(
			tostring(self.value)
		),
		("Expected value %q to be nil"):format(
			tostring(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value
]]
function Expectation:equal(otherValue)
	local result = (self.value == otherValue) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q (%s), got %q (%s) instead"):format(
			tostring(otherValue),
			type(otherValue),
			tostring(self.value),
			type(self.value)
		),
		("Expected anything but value %q (%s)"):format(
			tostring(otherValue),
			type(otherValue)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value within some
	inclusive limit.
]]
function Expectation:near(otherValue, limit)
	assert(type(self.value) == "number", "Expectation value must be a number to use 'near'")
	assert(type(otherValue) == "number", "otherValue must be a number")
	assert(type(limit) == "number" or limit == nil, "limit must be a number or nil")

	limit = limit or 1e-7

	local result = (math.abs(self.value - otherValue) <= limit) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value to be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		),
		("Expected value to not be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our functoid expectation value throws an error when called.
	An optional error message can be passed to assert that the error message
	contains the given value.
]]
function Expectation:throw(messageSubstring)
	local ok, err = pcall(self.value)
	local result = ok ~= self.successCondition

	if messageSubstring and not ok then
		if self.successCondition then
			result = err:find(messageSubstring, 1, true) ~= nil
		else
			result = err:find(messageSubstring, 1, true) == nil
		end
	end

	local message

	if messageSubstring then
		message = formatMessage(self.successCondition,
			("Expected function to throw an error containing %q, but it %s"):format(
				messageSubstring,
				err and ("threw: %s"):format(err) or "did not throw."
			),
			("Expected function to never throw an error containing %q, but it threw: %s"):format(
				messageSubstring,
				tostring(err)
			)
		)
	else
		message = formatMessage(self.successCondition,
			"Expected function to throw an error, but it did not throw.",
			("Expected function to succeed, but it threw an error: %s"):format(
				tostring(err)
			)
		)
	end

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

return Expectation
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="297">
                <Properties>
                  <string name="Name">ExpectationContext</string>
                  <string name="Source"><![CDATA[local Expectation = require(script.Parent.Expectation)
local checkMatcherNameCollisions = Expectation.checkMatcherNameCollisions

local function copy(t)
	local result = {}

	for key, value in pairs(t) do
		result[key] = value
	end

	return result
end

local ExpectationContext = {}
ExpectationContext.__index = ExpectationContext

function ExpectationContext.new(parent)
	local self = {
		_extensions = parent and copy(parent._extensions) or {},
	}

	return setmetatable(self, ExpectationContext)
end

function ExpectationContext:startExpectationChain(...)
	return Expectation.new(...):extend(self._extensions)
end

function ExpectationContext:extend(config)
	for key, value in pairs(config) do
		assert(self._extensions[key] == nil, string.format("Cannot reassign %q in expect.extend", key))
		assert(checkMatcherNameCollisions(key), string.format("Cannot overwrite matcher %q; it already exists", key))

		self._extensions[key] = value
	end
end

return ExpectationContext
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="298">
                <Properties>
                  <string name="Name">LifecycleHooks</string>
                  <string name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)

local LifecycleHooks = {}
LifecycleHooks.__index = LifecycleHooks

function LifecycleHooks.new()
	local self = {
		_stack = {},
	}
	return setmetatable(self, LifecycleHooks)
end

--[[
	Returns an array of `beforeEach` hooks in FIFO order
]]
function LifecycleHooks:getBeforeEachHooks()
	local key = TestEnum.NodeType.BeforeEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, hook)
		end
	end

	return hooks
end

--[[
	Returns an array of `afterEach` hooks in FILO order
]]
function LifecycleHooks:getAfterEachHooks()
	local key = TestEnum.NodeType.AfterEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, 1, hook)
		end
	end

	return hooks
end

--[[
	Pushes uncalled beforeAll and afterAll hooks back up the stack
]]
function LifecycleHooks:popHooks()
	table.remove(self._stack, #self._stack)
end

function LifecycleHooks:pushHooksFrom(planNode)
	assert(planNode ~= nil)

	table.insert(self._stack, {
		[TestEnum.NodeType.BeforeAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeAll),
		[TestEnum.NodeType.AfterAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterAll),
		[TestEnum.NodeType.BeforeEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeEach),
		[TestEnum.NodeType.AfterEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterEach),
	})
end

--[[
	Get the beforeAll hooks from the current level.
]]
function LifecycleHooks:getBeforeAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.BeforeAll]
end

--[[
	Get the afterAll hooks from the current level.
]]
function LifecycleHooks:getAfterAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.AfterAll]
end

function LifecycleHooks:_getHooksOfType(nodes, key)
	local hooks = {}

	for _, node in ipairs(nodes) do
		if node.type == key then
			table.insert(hooks, node.callback)
		end
	end

	return hooks
end

return LifecycleHooks
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="299">
                <Properties>
                  <string name="Name">Reporters</string>
                </Properties>
                <Item class="ModuleScript" referent="300">
                  <Properties>
                    <string name="Name">TeamCityReporter</string>
                    <string name="Source">local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local TeamCityReporter = {}

local function teamCityEscape(str)
	str = string.gsub(str, "([]|'[])","|%1")
	str = string.gsub(str, "\r", "|r")
	str = string.gsub(str, "\n", "|n")
	return str
end

local function teamCityEnterSuite(suiteName)
	return string.format("##teamcity[testSuiteStarted name='%s']", teamCityEscape(suiteName))
end

local function teamCityLeaveSuite(suiteName)
	return string.format("##teamcity[testSuiteFinished name='%s']", teamCityEscape(suiteName))
end

local function teamCityEnterCase(caseName)
	return string.format("##teamcity[testStarted name='%s']", teamCityEscape(caseName))
end

local function teamCityLeaveCase(caseName)
	return string.format("##teamcity[testFinished name='%s']", teamCityEscape(caseName))
end

local function teamCityFailCase(caseName, errorMessage)
	return string.format("##teamcity[testFailed name='%s' message='%s']",
		teamCityEscape(caseName), teamCityEscape(errorMessage))
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0
	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end
	if node.planNode.type == TestEnum.NodeType.Describe then
		table.insert(buffer, teamCityEnterSuite(node.planNode.phrase))
		for _, child in ipairs(node.children) do
			reportNode(child, buffer, level + 1)
		end
		table.insert(buffer, teamCityLeaveSuite(node.planNode.phrase))
	else
		table.insert(buffer, teamCityEnterCase(node.planNode.phrase))
		if node.status == TestEnum.TestStatus.Failure then
			table.insert(buffer, teamCityFailCase(node.planNode.phrase, table.concat(node.errors,"\n")))
		end
		table.insert(buffer, teamCityLeaveCase(node.planNode.phrase))
	end
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TeamCityReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TeamCityReporter</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="301">
                  <Properties>
                    <string name="Name">TextReporter</string>
                    <string name="Source">--[[
	The TextReporter uses the results from a completed test to output text to
	standard output and TestService.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporter = {}

local function compareNodes(a, b)
	return a.planNode.phrase:lower() &lt; b.planNode.phrase:lower()
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	else
		line = ("%s%s"):format(
			INDENT:rep(level),
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporter</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="302">
                  <Properties>
                    <string name="Name">TextReporterQuiet</string>
                    <string name="Source">--[[
	Copy of TextReporter that doesn't output successful tests.

	This should be temporary, it's just a workaround to make CI environments
	happy in the short-term.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporterQuiet = {}

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status ~= TestEnum.TestStatus.Success then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporterQuiet.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporterQuiet</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="303">
                <Properties>
                  <string name="Name">TestBootstrap</string>
                  <string name="Source">--[[
	Provides an interface to quickly run and report tests from a given object.
]]

local TestPlanner = require(script.Parent.TestPlanner)
local TestRunner = require(script.Parent.TestRunner)
local TextReporter = require(script.Parent.Reporters.TextReporter)

local TestBootstrap = {}

local function stripSpecSuffix(name)
	return (name:gsub("%.spec$", ""))
end
local function isSpecScript(aScript)
	return aScript:IsA("ModuleScript") and aScript.Name:match("%.spec$")
end

local function getPath(module, root)
	root = root or game

	local path = {}
	local last = module

	if last.Name == "init.spec" then
		-- Use the directory's node for init.spec files.
		last = last.Parent
	end

	while last ~= nil and last ~= root do
		table.insert(path, stripSpecSuffix(last.Name))
		last = last.Parent
	end
	table.insert(path, stripSpecSuffix(root.Name))

	return path
end

local function toStringPath(tablePath)
	local stringPath = ""
	local first = true
	for _, element in ipairs(tablePath) do
		if first then
			stringPath = element
			first = false
		else
			stringPath = element .. " " .. stringPath
		end
	end
	return stringPath
end

function TestBootstrap:getModulesImpl(root, modules, current)
	modules = modules or {}
	current = current or root

	if isSpecScript(current) then
		local method = require(current)
		local path = getPath(current, root)
		local pathString = toStringPath(path)

		table.insert(modules, {
			method = method,
			path = path,
			pathStringForSorting = pathString:lower()
		})
	end
end

--[[
	Find all the ModuleScripts in this tree that are tests.
]]
function TestBootstrap:getModules(root)
	local modules = {}

	self:getModulesImpl(root, modules)

	for _, child in ipairs(root:GetDescendants()) do
		self:getModulesImpl(root, modules, child)
	end

	return modules
end

--[[
	Runs all test and reports the results using the given test reporter.

	If no reporter is specified, a reasonable default is provided.

	This function demonstrates the expected workflow with this testing system:
	1. Locate test modules
	2. Generate test plan
	3. Run test plan
	4. Report test results

	This means we could hypothetically present a GUI to the developer that shows
	the test plan before we execute it, allowing them to toggle specific tests
	before they're run, but after they've been identified!
]]
function TestBootstrap:run(roots, reporter, otherOptions)
	reporter = reporter or TextReporter

	otherOptions = otherOptions or {}
	local showTimingInfo = otherOptions["showTimingInfo"] or false
	local testNamePattern = otherOptions["testNamePattern"]
	local extraEnvironment = otherOptions["extraEnvironment"] or {}

	if type(roots) ~= "table" then
		error(("Bad argument #1 to TestBootstrap:run. Expected table, got %s"):format(typeof(roots)), 2)
	end

	local startTime = tick()

	local modules = {}
	for _, subRoot in ipairs(roots) do
		local newModules = self:getModules(subRoot)

		for _, newModule in ipairs(newModules) do
			table.insert(modules, newModule)
		end
	end

	local afterModules = tick()

	local plan = TestPlanner.createPlan(modules, testNamePattern, extraEnvironment)
	local afterPlan = tick()

	local results = TestRunner.runPlan(plan)
	local afterRun = tick()

	reporter.report(results)
	local afterReport = tick()

	if showTimingInfo then
		local timing = {
			("Took %f seconds to locate test modules"):format(afterModules - startTime),
			("Took %f seconds to create test plan"):format(afterPlan - afterModules),
			("Took %f seconds to run tests"):format(afterRun - afterPlan),
			("Took %f seconds to report tests"):format(afterReport - afterRun),
		}

		print(table.concat(timing, "\n"))
	end

	return results
end

return TestBootstrap</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="304">
                <Properties>
                  <string name="Name">TestEnum</string>
                  <string name="Source">--[[
	Constants used throughout the testing framework.
]]

local TestEnum = {}

TestEnum.TestStatus = {
	Success = "Success",
	Failure = "Failure",
	Skipped = "Skipped"
}

TestEnum.NodeType = {
	Describe = "Describe",
	It = "It",
	BeforeAll = "BeforeAll",
	AfterAll = "AfterAll",
	BeforeEach = "BeforeEach",
	AfterEach = "AfterEach"
}

TestEnum.NodeModifier = {
	None = "None",
	Skip = "Skip",
	Focus = "Focus"
}

return TestEnum</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="305">
                <Properties>
                  <string name="Name">TestPlan</string>
                  <string name="Source"><![CDATA[--[[
	Represents a tree of tests that have been loaded but not necessarily
	executed yet.

	TestPlan objects are produced by TestPlanner.
]]

local TestEnum = require(script.Parent.TestEnum)
local Expectation = require(script.Parent.Expectation)

local function newEnvironment(currentNode, extraEnvironment)
	local env = {}

	if extraEnvironment then
		if type(extraEnvironment) ~= "table" then
			error(("Bad argument #2 to newEnvironment. Expected table, got %s"):format(
				typeof(extraEnvironment)), 2)
		end

		for key, value in pairs(extraEnvironment) do
			env[key] = value
		end
	end

	local function addChild(phrase, callback, nodeType, nodeModifier)
		local node = currentNode:addChild(phrase, nodeType, nodeModifier)
		node.callback = callback
		if nodeType == TestEnum.NodeType.Describe then
			node:expand()
		end
		return node
	end

	function env.describeFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Focus)
	end

	function env.describeSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Skip)
	end

	function env.describe(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.None)
	end

	function env.itFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Focus)
	end

	function env.itSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
	end

	function env.itFIXME(phrase, callback)
		local node = addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
		warn("FIXME: broken test", node:getFullName())
	end

	function env.it(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.None)
	end

	-- Incrementing counter used to ensure that beforeAll, afterAll, beforeEach, afterEach have unique phrases
	local lifecyclePhaseId = 0

	local lifecycleHooks = {
		[TestEnum.NodeType.BeforeAll] = "beforeAll",
		[TestEnum.NodeType.AfterAll] = "afterAll",
		[TestEnum.NodeType.BeforeEach] = "beforeEach",
		[TestEnum.NodeType.AfterEach] = "afterEach"
	}

	for nodeType, name in pairs(lifecycleHooks) do
		env[name] = function(callback)
			addChild(name .. "_" .. tostring(lifecyclePhaseId), callback, nodeType, TestEnum.NodeModifier.None)
			lifecyclePhaseId = lifecyclePhaseId + 1
		end
	end

	function env.FIXME(optionalMessage)
		warn("FIXME: broken test", currentNode:getFullName(), optionalMessage or "")

		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	function env.FOCUS()
		currentNode.modifier = TestEnum.NodeModifier.Focus
	end

	function env.SKIP()
		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	--[[
		This function is deprecated. Calling it is a no-op beyond generating a
		warning.
	]]
	function env.HACK_NO_XPCALL()
		warn("HACK_NO_XPCALL is deprecated. It is now safe to yield in an " ..
			"xpcall, so this is no longer necessary. It can be safely deleted.")
	end

	env.fit = env.itFOCUS
	env.xit = env.itSKIP
	env.fdescribe = env.describeFOCUS
	env.xdescribe = env.describeSKIP

	env.expect = setmetatable({
		extend = function(...)
			error("Cannot call \"expect.extend\" from within a \"describe\" node.")
		end,
	}, {
		__call = function(_self, ...)
			return Expectation.new(...)
		end,
	})

	return env
end

local TestNode = {}
TestNode.__index = TestNode

--[[
	Create a new test node. A pointer to the test plan, a phrase to describe it
	and the type of node it is are required. The modifier is optional and will
	be None if left blank.
]]
function TestNode.new(plan, phrase, nodeType, nodeModifier)
	nodeModifier = nodeModifier or TestEnum.NodeModifier.None

	local node = {
		plan = plan,
		phrase = phrase,
		type = nodeType,
		modifier = nodeModifier,
		children = {},
		callback = nil,
		parent = nil,
	}

	node.environment = newEnvironment(node, plan.extraEnvironment)
	return setmetatable(node, TestNode)
end

local function getModifier(name, pattern, modifier)
	if pattern and (modifier == nil or modifier == TestEnum.NodeModifier.None) then
		if name:match(pattern) then
			return TestEnum.NodeModifier.Focus
		else
			return TestEnum.NodeModifier.Skip
		end
	end
	return modifier
end

function TestNode:addChild(phrase, nodeType, nodeModifier)
	if nodeType == TestEnum.NodeType.It then
		for _, child in pairs(self.children) do
			if child.phrase == phrase then
				error("Duplicate it block found: " .. child:getFullName())
			end
		end
	end

	local childName = self:getFullName() .. " " .. phrase
	nodeModifier = getModifier(childName, self.plan.testNamePattern, nodeModifier)
	local child = TestNode.new(self.plan, phrase, nodeType, nodeModifier)
	child.parent = self
	table.insert(self.children, child)
	return child
end

--[[
	Join the names of all the nodes back to the parent.
]]
function TestNode:getFullName()
	if self.parent then
		local parentPhrase = self.parent:getFullName()
		if parentPhrase then
			return parentPhrase .. " " .. self.phrase
		end
	end
	return self.phrase
end

--[[
	Expand a node by setting its callback environment and then calling it. Any
	further it and describe calls within the callback will be added to the tree.
]]
function TestNode:expand()
	local originalEnv = getfenv(self.callback)
	local callbackEnv = setmetatable({}, { __index = originalEnv })
	for key, value in pairs(self.environment) do
		callbackEnv[key] = value
	end
	-- Copy 'script' directly to new env to make Studio debugger happy.
	-- Studio debugger does not look into __index, because of security reasons
	callbackEnv.script = originalEnv.script
	setfenv(self.callback, callbackEnv)

	local success, result = xpcall(self.callback, function(message)
		return debug.traceback(tostring(message), 2)
	end)

	if not success then
		self.loadError = result
	end
end

local TestPlan = {}
TestPlan.__index = TestPlan

--[[
	Create a new, empty TestPlan.
]]
function TestPlan.new(testNamePattern, extraEnvironment)
	local plan = {
		children = {},
		testNamePattern = testNamePattern,
		extraEnvironment = extraEnvironment,
	}

	return setmetatable(plan, TestPlan)
end

--[[
	Add a new child under the test plan's root node.
]]
function TestPlan:addChild(phrase, nodeType, nodeModifier)
	nodeModifier = getModifier(phrase, self.testNamePattern, nodeModifier)
	local child = TestNode.new(self, phrase, nodeType, nodeModifier)
	table.insert(self.children, child)
	return child
end

--[[
	Add a new describe node with the given method as a callback. Generates or
	reuses all the describe nodes along the path.
]]
function TestPlan:addRoot(path, method)
	local curNode = self
	for i = #path, 1, -1 do
		local nextNode = nil

		for _, child in ipairs(curNode.children) do
			if child.phrase == path[i] then
				nextNode = child
				break
			end
		end

		if nextNode == nil then
			nextNode = curNode:addChild(path[i], TestEnum.NodeType.Describe)
		end

		curNode = nextNode
	end

	curNode.callback = method
	curNode:expand()
end

--[[
	Calls the given callback on all nodes in the tree, traversed depth-first.
]]
function TestPlan:visitAllNodes(callback, root, level)
	root = root or self
	level = level or 0

	for _, child in ipairs(root.children) do
		callback(child, level)

		self:visitAllNodes(callback, child, level + 1)
	end
end

--[[
	Visualizes the test plan in a simple format, suitable for debugging the test
	plan's structure.
]]
function TestPlan:visualize()
	local buffer = {}
	self:visitAllNodes(function(node, level)
		table.insert(buffer, (" "):rep(3 * level) .. node.phrase)
	end)
	return table.concat(buffer, "\n")
end

--[[
	Gets a list of all nodes in the tree for which the given callback returns
	true.
]]
function TestPlan:findNodes(callback)
	local results = {}
	self:visitAllNodes(function(node)
		if callback(node) then
			table.insert(results, node)
		end
	end)
	return results
end

return TestPlan
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="306">
                <Properties>
                  <string name="Name">TestPlanner</string>
                  <string name="Source">--[[
	Turns a series of specification functions into a test plan.

	Uses a TestPlanBuilder to keep track of the state of the tree being built.
]]
local TestPlan = require(script.Parent.TestPlan)

local TestPlanner = {}

--[[
	Create a new TestPlan from a list of specification functions.

	These functions should call a combination of `describe` and `it` (and their
	variants), which will be turned into a test plan to be executed.

	Parameters:
		- modulesList - list of tables describing test modules {
			method, -- specification function described above
			path, -- array of parent entires, first element is the leaf that owns `method`
			pathStringForSorting -- a string representation of `path`, used for sorting of the test plan
		}
		- testNamePattern - Only tests matching this Lua pattern string will run. Pass empty or nil to run all tests
		- extraEnvironment - Lua table holding additional functions and variables to be injected into the specification
							function during execution
]]
function TestPlanner.createPlan(modulesList, testNamePattern, extraEnvironment)
	local plan = TestPlan.new(testNamePattern, extraEnvironment)

	table.sort(modulesList, function(a, b)
		return a.pathStringForSorting &lt; b.pathStringForSorting
	end)

	for _, module in ipairs(modulesList) do
		plan:addRoot(module.path, module.method)
	end

	return plan
end

return TestPlanner</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="307">
                <Properties>
                  <string name="Name">TestResults</string>
                  <string name="Source">--[[
	Represents a tree of test results.

	Each node in the tree corresponds directly to a node in a corresponding
	TestPlan, accessible via the 'planNode' field.

	TestResults objects are produced by TestRunner using TestSession as state.
]]

local TestEnum = require(script.Parent.TestEnum)

local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}

local TestResults = {}

TestResults.__index = TestResults

--[[
	Create a new TestResults tree that's linked to the given TestPlan.
]]
function TestResults.new(plan)
	local self = {
		successCount = 0,
		failureCount = 0,
		skippedCount = 0,
		planNode = plan,
		children = {},
		errors = {}
	}

	setmetatable(self, TestResults)

	return self
end

--[[
	Create a new result node that can be inserted into a TestResult tree.
]]
function TestResults.createNode(planNode)
	local node = {
		planNode = planNode,
		children = {},
		errors = {},
		status = nil
	}

	return node
end

--[[
	Visit all test result nodes, depth-first.
]]
function TestResults:visitAllNodes(callback, root)
	root = root or self

	for _, child in ipairs(root.children) do
		callback(child)

		self:visitAllNodes(callback, child)
	end
end

--[[
	Creates a debug visualization of the test results.
]]
function TestResults:visualize(root, level)
	root = root or self
	level = level or 0

	local buffer = {}

	for _, child in ipairs(root.children) do
		if child.planNode.type == TestEnum.NodeType.It then
			local symbol = STATUS_SYMBOLS[child.status] or "?"
			local str = ("%s[%s] %s"):format(
				(" "):rep(3 * level),
				symbol,
				child.planNode.phrase
			)

			if child.messages and #child.messages > 0 then
				str = str .. "\n " .. (" "):rep(3 * level) .. table.concat(child.messages, "\n " .. (" "):rep(3 * level))
			end

			table.insert(buffer, str)
		else
			local str = ("%s%s"):format(
				(" "):rep(3 * level),
				child.planNode.phrase or ""
			)

			if child.status then
				str = str .. (" (%s)"):format(child.status)
			end

			table.insert(buffer, str)

			if #child.children > 0 then
				local text = self:visualize(child, level + 1)
				table.insert(buffer, text)
			end
		end
	end

	return table.concat(buffer, "\n")
end

return TestResults</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="308">
                <Properties>
                  <string name="Name">TestRunner</string>
                  <string name="Source"><![CDATA[--[[
	Contains the logic to run a test plan and gather test results from it.

	TestRunner accepts a TestPlan object, executes the planned tests, and
	produces a TestResults object. While the tests are running, the system's
	state is contained inside a TestSession object.
]]

local TestEnum = require(script.Parent.TestEnum)
local TestSession = require(script.Parent.TestSession)
local LifecycleHooks = require(script.Parent.LifecycleHooks)

local RUNNING_GLOBAL = "__TESTEZ_RUNNING_TEST__"

local TestRunner = {
	environment = {}
}

local function wrapExpectContextWithPublicApi(expectationContext)
	return setmetatable({
		extend = function(...)
			expectationContext:extend(...)
		end,
	}, {
		__call = function(_self, ...)
			return expectationContext:startExpectationChain(...)
		end,
	})
end

--[[
	Runs the given TestPlan and returns a TestResults object representing the
	results of the run.
]]
function TestRunner.runPlan(plan)
	local session = TestSession.new(plan)
	local lifecycleHooks = LifecycleHooks.new()

	local exclusiveNodes = plan:findNodes(function(node)
		return node.modifier == TestEnum.NodeModifier.Focus
	end)

	session.hasFocusNodes = #exclusiveNodes > 0

	TestRunner.runPlanNode(session, plan, lifecycleHooks)

	return session:finalize()
end

--[[
	Run the given test plan node and its descendants, using the given test
	session to store all of the results.
]]
function TestRunner.runPlanNode(session, planNode, lifecycleHooks)
	local function runCallback(callback, messagePrefix)
		local success = true
		local errorMessage
		-- Any code can check RUNNING_GLOBAL to fork behavior based on
		-- whether a test is running. We use this to avoid accessing
		-- protected APIs; it's a workaround that will go away someday.
		_G[RUNNING_GLOBAL] = true

		messagePrefix = messagePrefix or ""

		local testEnvironment = getfenv(callback)

		for key, value in pairs(TestRunner.environment) do
			testEnvironment[key] = value
		end

		testEnvironment.fail = function(message)
			if message == nil then
				message = "fail() was called."
			end

			success = false
			errorMessage = messagePrefix .. debug.traceback(tostring(message), 2)
		end

		testEnvironment.expect = wrapExpectContextWithPublicApi(session:getExpectationContext())

		local context = session:getContext()

		local nodeSuccess, nodeResult = xpcall(
			function()
				callback(context)
			end,
			function(message)
				return messagePrefix .. debug.traceback(tostring(message), 2)
			end
		)

		-- If a node threw an error, we prefer to use that message over
		-- one created by fail() if it was set.
		if not nodeSuccess then
			success = false
			errorMessage = nodeResult
		end

		_G[RUNNING_GLOBAL] = nil

		return success, errorMessage
	end

	local function runNode(childPlanNode)
		-- Errors can be set either via `error` propagating upwards or
		-- by a test calling fail([message]).

		for _, hook in ipairs(lifecycleHooks:getBeforeEachHooks()) do
			local success, errorMessage = runCallback(hook, "beforeEach hook: ")
			if not success then
				return false, errorMessage
			end
		end

		local testSuccess, testErrorMessage = runCallback(childPlanNode.callback)

		for _, hook in ipairs(lifecycleHooks:getAfterEachHooks()) do
			local success, errorMessage = runCallback(hook, "afterEach hook: ")
			if not success then
				if not testSuccess then
					return false, testErrorMessage .. "\nWhile cleaning up the failed test another error was found:\n" .. errorMessage
				end
				return false, errorMessage
			end
		end

		if not testSuccess then
			return false, testErrorMessage
		end

		return true, nil
	end

	lifecycleHooks:pushHooksFrom(planNode)

	local halt = false
	for _, hook in ipairs(lifecycleHooks:getBeforeAllHooks()) do
		local success, errorMessage = runCallback(hook, "beforeAll hook: ")
		if not success then
			session:addDummyError("beforeAll", errorMessage)
			halt = true
		end
	end

	if not halt then
		for _, childPlanNode in ipairs(planNode.children) do
			if childPlanNode.type == TestEnum.NodeType.It then
				session:pushNode(childPlanNode)
				if session:shouldSkip() then
					session:setSkipped()
				else
					local success, errorMessage = runNode(childPlanNode)

					if success then
						session:setSuccess()
					else
						session:setError(errorMessage)
					end
				end
				session:popNode()
			elseif childPlanNode.type == TestEnum.NodeType.Describe then
				session:pushNode(childPlanNode)
				TestRunner.runPlanNode(session, childPlanNode, lifecycleHooks)

				-- Did we have an error trying build a test plan?
				if childPlanNode.loadError then
					local message = "Error during planning: " .. childPlanNode.loadError
					session:setError(message)
				else
					session:setStatusFromChildren()
				end
				session:popNode()
			end
		end
	end

	for _, hook in ipairs(lifecycleHooks:getAfterAllHooks()) do
		local success, errorMessage = runCallback(hook, "afterAll hook: ")
		if not success then
			session:addDummyError("afterAll", errorMessage)
		end
	end

	lifecycleHooks:popHooks()
end

return TestRunner
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="309">
                <Properties>
                  <string name="Name">TestSession</string>
                  <string name="Source"><![CDATA[--[[
	Represents the state relevant while executing a test plan.

	Used by TestRunner to produce a TestResults object.

	Uses the same tree building structure as TestPlanBuilder; TestSession keeps
	track of a stack of nodes that represent the current path through the tree.
]]

local TestEnum = require(script.Parent.TestEnum)
local TestResults = require(script.Parent.TestResults)
local Context = require(script.Parent.Context)
local ExpectationContext = require(script.Parent.ExpectationContext)

local TestSession = {}

TestSession.__index = TestSession

--[[
	Create a TestSession related to the given TestPlan.

	The resulting TestResults object will be linked to this TestPlan.
]]
function TestSession.new(plan)
	local self = {
		results = TestResults.new(plan),
		nodeStack = {},
		contextStack = {},
		expectationContextStack = {},
		hasFocusNodes = false
	}

	setmetatable(self, TestSession)

	return self
end

--[[
	Calculate success, failure, and skipped test counts in the tree at the
	current point in the execution.
]]
function TestSession:calculateTotals()
	local results = self.results

	results.successCount = 0
	results.failureCount = 0
	results.skippedCount = 0

	results:visitAllNodes(function(node)
		local status = node.status
		local nodeType = node.planNode.type

		if nodeType == TestEnum.NodeType.It then
			if status == TestEnum.TestStatus.Success then
				results.successCount = results.successCount + 1
			elseif status == TestEnum.TestStatus.Failure then
				results.failureCount = results.failureCount + 1
			elseif status == TestEnum.TestStatus.Skipped then
				results.skippedCount = results.skippedCount + 1
			end
		end
	end)
end

--[[
	Gathers all of the errors reported by tests and puts them at the top level
	of the TestResults object.
]]
function TestSession:gatherErrors()
	local results = self.results

	results.errors = {}

	results:visitAllNodes(function(node)
		if #node.errors > 0 then
			for _, message in ipairs(node.errors) do
				table.insert(results.errors, message)
			end
		end
	end)
end

--[[
	Calculates test totals, verifies the tree is valid, and returns results.
]]
function TestSession:finalize()
	if #self.nodeStack ~= 0 then
		error("Cannot finalize TestResults with nodes still on the stack!", 2)
	end

	self:calculateTotals()
	self:gatherErrors()

	return self.results
end

--[[
	Create a new test result node and push it onto the navigation stack.
]]
function TestSession:pushNode(planNode)
	local node = TestResults.createNode(planNode)
	local lastNode = self.nodeStack[#self.nodeStack] or self.results
	table.insert(lastNode.children, node)
	table.insert(self.nodeStack, node)

	local lastContext = self.contextStack[#self.contextStack]
	local context = Context.new(lastContext)
	table.insert(self.contextStack, context)

	local lastExpectationContext = self.expectationContextStack[#self.expectationContextStack]
	local expectationContext = ExpectationContext.new(lastExpectationContext)
	table.insert(self.expectationContextStack, expectationContext)
end

--[[
	Pops a node off of the navigation stack.
]]
function TestSession:popNode()
	assert(#self.nodeStack > 0, "Tried to pop from an empty node stack!")
	table.remove(self.nodeStack, #self.nodeStack)
	table.remove(self.contextStack, #self.contextStack)
	table.remove(self.expectationContextStack, #self.expectationContextStack)
end

--[[
	Gets the Context object for the current node.
]]
function TestSession:getContext()
	assert(#self.contextStack > 0, "Tried to get context from an empty stack!")
	return self.contextStack[#self.contextStack]
end


function TestSession:getExpectationContext()
	assert(#self.expectationContextStack > 0, "Tried to get expectationContext from an empty stack!")
	return self.expectationContextStack[#self.expectationContextStack]
end

--[[
	Tells whether the current test we're in should be skipped.
]]
function TestSession:shouldSkip()
	-- If our test tree had any exclusive tests, then normal tests are skipped!
	if self.hasFocusNodes then
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			-- Skipped tests are still skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end

			-- Focused tests are the only ones that aren't skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Focus then
				return false
			end
		end

		return true
	else
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end
		end
	end

	return false
end

--[[
	Set the current node's status to Success.
]]
function TestSession:setSuccess()
	assert(#self.nodeStack > 0, "Attempting to set success status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Success
end

--[[
	Set the current node's status to Skipped.
]]
function TestSession:setSkipped()
	assert(#self.nodeStack > 0, "Attempting to set skipped status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Skipped
end

--[[
	Set the current node's status to Failure and adds a message to its list of
	errors.
]]
function TestSession:setError(message)
	assert(#self.nodeStack > 0, "Attempting to set error status on empty stack")
	local last = self.nodeStack[#self.nodeStack]
	last.status = TestEnum.TestStatus.Failure
	table.insert(last.errors, message)
end

--[[
	Add a dummy child node to the current node to hold the given error. This
	allows an otherwise empty describe node to report an error in a more natural
	way.
]]
function TestSession:addDummyError(phrase, message)
	self:pushNode({type = TestEnum.NodeType.It, phrase = phrase})
	self:setError(message)
	self:popNode()
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Failure
end

--[[
	Set the current node's status based on that of its children. If all children
	are skipped, mark it as skipped. If any are fails, mark it as failed.
	Otherwise, mark it as success.
]]
function TestSession:setStatusFromChildren()
	assert(#self.nodeStack > 0, "Attempting to set status from children on empty stack")

	local last = self.nodeStack[#self.nodeStack]
	local status = TestEnum.TestStatus.Success
	local skipped = true

	-- If all children were skipped, then we were skipped
	-- If any child failed, then we failed!
	for _, child in ipairs(last.children) do
		if child.status ~= TestEnum.TestStatus.Skipped then
			skipped = false

			if child.status == TestEnum.TestStatus.Failure then
				status = TestEnum.TestStatus.Failure
			end
		end
	end

	if skipped then
		status = TestEnum.TestStatus.Skipped
	end

	last.status = status
end

return TestSession
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="310">
            <Properties>
              <string name="Name">types</string>
            </Properties>
            <Item class="Folder" referent="311">
              <Properties>
                <string name="Name">include</string>
              </Properties>
              <Item class="Folder" referent="312">
                <Properties>
                  <string name="Name">generated</string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="313">
            <Properties>
              <string name="Name">zone-plus</string>
            </Properties>
            <Item class="ModuleScript" referent="314">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[local Tracker = require(script.Zone.ZoneController.Tracker)
local Zone = require(script.Zone)
local ZoneController = require(script.Zone.ZoneController)

return {
	Tracker = Tracker,
	Zone = Zone,
	ZoneController = ZoneController
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="315">
                <Properties>
                  <string name="Name">Zone</string>
                  <string name="Source">-- LOCAL
local players = game:GetService("Players")
local runService = game:GetService("RunService")
local heartbeat = runService.Heartbeat
local localPlayer = runService:IsClient() and players.LocalPlayer
local replicatedStorage = game:GetService("ReplicatedStorage")
local httpService = game:GetService("HttpService")
local Enum_ = require(script.Enum)
local enum = Enum_.enums
local Janitor = require(script.Janitor)
local Signal = require(script.Signal)
local ZonePlusReference = require(script.ZonePlusReference)
local referenceObject = ZonePlusReference.getObject()
local zoneControllerModule = script.ZoneController
local trackerModule = zoneControllerModule.Tracker
local collectiveWorldModelModule = zoneControllerModule.CollectiveWorldModel
local ZoneController = require(zoneControllerModule)
local referenceLocation = (game:GetService("RunService"):IsClient() and "Client") or "Server"
local referencePresent = referenceObject and referenceObject:FindFirstChild(referenceLocation)
if referencePresent then
	return require(referenceObject.Value)
end

local Zone = {}
Zone.__index = Zone
if not referencePresent then
	ZonePlusReference.addToReplicatedStorage()
end
Zone.enum = enum



-- CONSTRUCTORS
function Zone.new(container)
	local self = {}
	setmetatable(self, Zone)
	
	-- Validate container
	local INVALID_TYPE_WARNING = "The zone container must be a model, folder, basepart or table!"
	local containerType = typeof(container)
	if not(containerType == "table" or containerType == "Instance") then
		error(INVALID_TYPE_WARNING)
	end

	-- Configurable
	self.accuracy = enum.Accuracy.High
	self.autoUpdate = true
	self.respectUpdateQueue = true
	--self.maxPartsAddition = 20
	--self.ignoreRecommendedMaxParts = false

	-- Variable
	local janitor = Janitor.new()
	self.janitor = janitor
	self._updateConnections = janitor:add(Janitor.new(), "destroy")
	self.container = container
	self.zoneParts = {}
	self.overlapParams = {}
	self.region = nil
	self.volume = nil
	self.boundMin = nil
	self.boundMax = nil
	self.recommendedMaxParts = nil
	self.zoneId = httpService:GenerateGUID()
	self.activeTriggers = {}
	self.occupants = {}
	self.trackingTouchedTriggers = {}
	self.enterDetection = enum.Detection.Centre
	self.exitDetection = enum.Detection.Centre
	self._currentEnterDetection = nil -- This will update automatically internally
	self._currentExitDetection = nil -- This will also update automatically internally
	self.totalPartVolume = 0
	self.allZonePartsAreBlocks = true
	self.trackedItems = {}
	self.settingsGroupName = nil
	self.worldModel = workspace
	self.onItemDetails = {}
	self.itemsToUntrack = {}

	-- This updates _currentEnterDetection and _currentExitDetection right away to prevent nil comparisons
	ZoneController.updateDetection(self)

	-- Signals
	self.updated = janitor:add(Signal.new(), "destroy")
	local triggerTypes = {
		"player",
		"part",
		"localPlayer",
		"item"
	}
	local triggerEvents = {
		"entered",
		"exited",
	}
	for _, triggerType in pairs(triggerTypes) do
		local activeConnections = 0
		local previousActiveConnections = 0
		for i, triggerEvent in pairs(triggerEvents) do
			-- this enables us to determine when a developer connects to an event
			-- so that we can act accoridngly (i.e. begin or end a checker loop)
			local signal = janitor:add(Signal.new(true), "destroy")
			local triggerEventUpper = triggerEvent:sub(1,1):upper()..triggerEvent:sub(2)
			local signalName = triggerType..triggerEventUpper
			self[signalName] = signal
			signal.connectionsChanged:Connect(function(increment)
				if triggerType == "localPlayer" and not localPlayer and increment == 1 then
					error(("Can only connect to 'localPlayer%s' on the client!"):format(triggerEventUpper))
				end
				previousActiveConnections = activeConnections
				activeConnections += increment
				if previousActiveConnections == 0 and activeConnections > 0 then
					-- At least 1 connection active, begin loop
					ZoneController._registerConnection(self, triggerType, triggerEventUpper)
				elseif previousActiveConnections > 0 and activeConnections == 0 then
					-- All connections have disconnected, end loop
					ZoneController._deregisterConnection(self, triggerType)
				end
			end)
		end
	end

	-- Setup touched receiver functions where applicable
	Zone.touchedConnectionActions = {}
	for _, triggerType in pairs(triggerTypes) do
		local methodName = ("_%sTouchedZone"):format(triggerType)
		local correspondingMethod = self[methodName]
		if correspondingMethod then
			self.trackingTouchedTriggers[triggerType] = {}
			Zone.touchedConnectionActions[triggerType] = function(touchedItem)
				correspondingMethod(self, touchedItem)
			end
		end
	end

	-- This constructs the zones boundaries, region, etc
	self:_update()

	-- Register/deregister zone
	ZoneController._registerZone(self)
	janitor:add(function()
		ZoneController._deregisterZone(self)
	end, true)
	
	return self
end

function Zone.fromRegion(cframe, size)
	local MAX_PART_SIZE = 2024
	local container = Instance.new("Model")
	local function createCube(cubeCFrame, cubeSize)
		if cubeSize.X > MAX_PART_SIZE or cubeSize.Y > MAX_PART_SIZE or cubeSize.Z > MAX_PART_SIZE then
			local quarterSize = cubeSize * 0.25
			local halfSize = cubeSize * 0.5
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, -quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, -quarterSize.Y, quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, quarterSize.Y, quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, -quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, -quarterSize.Y, quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, quarterSize.Y, quarterSize.Z), halfSize)
		else
			local part = Instance.new("Part")
			part.CFrame = cubeCFrame
			part.Size = cubeSize
			part.Anchored = true
			part.Parent = container
		end
	end
	createCube(cframe, size)
	local zone = Zone.new(container)
	zone:relocate()
	return zone
end



-- PRIVATE METHODS
function Zone:_calculateRegion(tableOfParts, dontRound)
	local bounds = {["Min"] = {}, ["Max"] = {}}
	for boundType, details in pairs(bounds) do
		details.Values = {}
		function details.parseCheck(v, currentValue)
			if boundType == "Min" then
				return (v &lt;= currentValue)
			elseif boundType == "Max" then
				return (v >= currentValue)
			end
		end
		function details:parse(valuesToParse)
			for i,v in pairs(valuesToParse) do
				local currentValue = self.Values[i] or v
				if self.parseCheck(v, currentValue) then
					self.Values[i] = v
				end
			end
		end
	end
	for _, part in pairs(tableOfParts) do
		local sizeHalf = part.Size * 0.5
		local corners = {
			part.CFrame * CFrame.new(-sizeHalf.X, -sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(-sizeHalf.X, -sizeHalf.Y, sizeHalf.Z),
			part.CFrame * CFrame.new(-sizeHalf.X, sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(-sizeHalf.X, sizeHalf.Y, sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, -sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, -sizeHalf.Y, sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, sizeHalf.Y, sizeHalf.Z),
		}
		for _, cornerCFrame in pairs(corners) do
			local x, y, z = cornerCFrame:GetComponents()
			local values = {x, y, z}
			bounds.Min:parse(values)
			bounds.Max:parse(values)
		end
	end
	local minBound = {}
	local maxBound = {}
	-- Rounding a regions coordinates to multiples of 4 ensures the region optimises the region
	-- by ensuring it aligns on the voxel grid
	local function roundToFour(to_round)
		local ROUND_TO = 4
		local divided = (to_round+ROUND_TO/2) / ROUND_TO
		local rounded = ROUND_TO * math.floor(divided)
		return rounded
	end
	for boundName, boundDetail in pairs(bounds) do
		for _, v in pairs(boundDetail.Values) do
			local newTable = (boundName == "Min" and minBound) or maxBound
			local newV = v
			if not dontRound then
				local roundOffset = (boundName == "Min" and -2) or 2
				newV = roundToFour(v+roundOffset) -- +-2 to ensures the zones region is not rounded down/up
			end
			table.insert(newTable, newV)
		end
	end
	local boundMin = Vector3.new(unpack(minBound))
	local boundMax = Vector3.new(unpack(maxBound))
	local region = Region3.new(boundMin, boundMax)
	return region, boundMin, boundMax
end

function Zone:_displayBounds()
	if not self.displayBoundParts then
		self.displayBoundParts = true
		local boundParts = {BoundMin = self.boundMin, BoundMax = self.boundMax}
		for boundName, boundCFrame in pairs(boundParts) do
			local part = Instance.new("Part")
			part.Anchored = true
			part.CanCollide = false
			part.Transparency = 0.5
			part.Size = Vector3.new(1,1,1)
			part.Color = Color3.fromRGB(255,0,0)
			part.CFrame = CFrame.new(boundCFrame)
			part.Name = boundName
			part.Parent = workspace
			self.janitor:add(part, "Destroy")
		end
	end
end

function Zone:_update()
	local container = self.container
	local zoneParts = {}
	local updateQueue = 0
	self._updateConnections:clean()

	local containerType = typeof(container)
	local holders = {}
	local INVALID_TYPE_WARNING = "The zone container must be a model, folder, basepart or table!"
	if containerType == "table" then
		for _, part in pairs(container) do
			if part:IsA("BasePart") then
				table.insert(zoneParts, part)
			end
		end
	elseif containerType == "Instance" then
		if container:IsA("BasePart") then
			table.insert(zoneParts, container)
		else
			table.insert(holders, container)
			for _, part in pairs(container:GetDescendants()) do
				if part:IsA("BasePart") then
					table.insert(zoneParts, part)
				else
					table.insert(holders, part)
				end
			end
		end
	end
	self.zoneParts = zoneParts
	self.overlapParams = {}
	
	local allZonePartsAreBlocksNew = true
	for _, zonePart in pairs(zoneParts) do
		local success, shapeName = pcall(function() return zonePart.Shape.Name end)
		if shapeName ~= "Block" then
			allZonePartsAreBlocksNew = false
		end
	end
	self.allZonePartsAreBlocks = allZonePartsAreBlocksNew
	
	local zonePartsWhitelist = OverlapParams.new()
	zonePartsWhitelist.FilterType = Enum.RaycastFilterType.Whitelist
	zonePartsWhitelist.MaxParts = #zoneParts
	zonePartsWhitelist.FilterDescendantsInstances = zoneParts
	self.overlapParams.zonePartsWhitelist = zonePartsWhitelist

	local zonePartsIgnorelist = OverlapParams.new()
	zonePartsIgnorelist.FilterType = Enum.RaycastFilterType.Blacklist
	zonePartsIgnorelist.FilterDescendantsInstances = zoneParts
	self.overlapParams.zonePartsIgnorelist = zonePartsIgnorelist
	
	-- this will call update on the zone when the container parts size or position changes, and when a
	-- child is removed or added from a holder (anything which isn't a basepart)
	local function update()
		if self.autoUpdate then
			local executeTime = os.clock()
			if self.respectUpdateQueue then
				updateQueue += 1
				executeTime += 0.1
			end
			local updateConnection
			updateConnection = runService.Heartbeat:Connect(function()
				if os.clock() >= executeTime then
					updateConnection:Disconnect()
					if self.respectUpdateQueue then
						updateQueue -= 1
					end
					if updateQueue == 0 and self.zoneId then
						self:_update()
					end
				end
			end)
		end
	end
	local partProperties = {"Size", "Position"}
	local function verifyDefaultCollision(instance)
		if instance.CollisionGroupId ~= 0 then
			error("Zone parts must belong to the 'Default' (0) CollisionGroup! Consider using zone:relocate() if you wish to move zones outside of workspace to prevent them interacting with other parts.")
		end
	end
	for _, part in pairs(zoneParts) do
		for _, prop in pairs(partProperties) do
			self._updateConnections:add(part:GetPropertyChangedSignal(prop):Connect(update), "Disconnect")
		end
		verifyDefaultCollision(part)
		self._updateConnections:add(part:GetPropertyChangedSignal("CollisionGroupId"):Connect(function()
			verifyDefaultCollision(part)
		end), "Disconnect")
	end
	local containerEvents = {"ChildAdded", "ChildRemoved"}
	for _, holder in pairs(holders) do
		for _, event in pairs(containerEvents) do
			self._updateConnections:add(self.container[event]:Connect(function(child)
				if child:IsA("BasePart") then
					update()
				end
			end), "Disconnect")
		end
	end
	
	local region, boundMin, boundMax = self:_calculateRegion(zoneParts)
	local exactRegion, _, _ = self:_calculateRegion(zoneParts, true)
	self.region = region
	self.exactRegion = exactRegion
	self.boundMin = boundMin
	self.boundMax = boundMax
	local rSize = region.Size
	self.volume = rSize.X*rSize.Y*rSize.Z
	
	-- Update: I was going to use this for the old part detection until the CanTouch property was released
	-- everything below is now irrelevant however I'll keep just in case I use again for future
	-------------------------------------------------------------------------------------------------
	-- When a zones region is determined, we also check for parts already existing within the zone
	-- these parts are likely never to move or interact with the zone, so we set the number of these
	-- to the baseline MaxParts value. 'recommendMaxParts' is then determined through the sum of this
	-- and maxPartsAddition. This ultimately optimises region checks as they can be generated with
	-- minimal MaxParts (i.e. recommendedMaxParts can be used instead of math.huge every time)
	--[[
	local result = self.worldModel:FindPartsInRegion3(region, nil, math.huge)
	local maxPartsBaseline = #result
	self.recommendedMaxParts = maxPartsBaseline + self.maxPartsAddition
	--]]
	
	self:_updateTouchedConnections()
	
	self.updated:Fire()
end

function Zone:_updateOccupants(trackerName, newOccupants)
	local previousOccupants = self.occupants[trackerName]
	if not previousOccupants then
		previousOccupants = {}
		self.occupants[trackerName] = previousOccupants
	end
	local signalsToFire = {}
	for occupant, prevItem in pairs(previousOccupants) do
		local newItem = newOccupants[occupant]
		if newItem == nil or newItem ~= prevItem then
			previousOccupants[occupant] = nil
			if not signalsToFire.exited then
				signalsToFire.exited = {}
			end
			table.insert(signalsToFire.exited, occupant)
		end
	end
	for occupant, _ in pairs(newOccupants) do
		if previousOccupants[occupant] == nil then
			local isAPlayer = occupant:IsA("Player")
			previousOccupants[occupant] = (isAPlayer and occupant.Character) or true
			if not signalsToFire.entered then
				signalsToFire.entered = {}
			end
			table.insert(signalsToFire.entered, occupant)
		end
	end 
	return signalsToFire
end

function Zone:_formTouchedConnection(triggerType)
	local touchedJanitorName = "_touchedJanitor"..triggerType
	local touchedJanitor = self[touchedJanitorName]
	if touchedJanitor then
		touchedJanitor:clean()
	else
		touchedJanitor = self.janitor:add(Janitor.new(), "destroy")
		self[touchedJanitorName] = touchedJanitor
	end
	self:_updateTouchedConnection(triggerType)
end

function Zone:_updateTouchedConnection(triggerType)
	local touchedJanitorName = "_touchedJanitor"..triggerType
	local touchedJanitor = self[touchedJanitorName]
	if not touchedJanitor then return end
	for _, basePart in pairs(self.zoneParts) do
		touchedJanitor:add(basePart.Touched:Connect(self.touchedConnectionActions[triggerType], self), "Disconnect")
	end
end

function Zone:_updateTouchedConnections()
	for triggerType, _ in pairs(self.touchedConnectionActions) do
		local touchedJanitorName = "_touchedJanitor"..triggerType
		local touchedJanitor = self[touchedJanitorName]
		if touchedJanitor then
			touchedJanitor:cleanup()
			self:_updateTouchedConnection(triggerType)
		end
	end
end

function Zone:_disconnectTouchedConnection(triggerType)
	local touchedJanitorName = "_touchedJanitor"..triggerType
	local touchedJanitor = self[touchedJanitorName]
	if touchedJanitor then
		touchedJanitor:cleanup()
		self[touchedJanitorName] = nil
	end
end

local function round(number, decimalPlaces)
	return math.round(number * 10^decimalPlaces) * 10^-decimalPlaces
end
function Zone:_partTouchedZone(part)
	local trackingDict = self.trackingTouchedTriggers["part"]
	if trackingDict[part] then return end
	local nextCheck = 0
	local verifiedEntrance = false
	local enterPosition = part.Position
	local enterTime = os.clock()
	local partJanitor = self.janitor:add(Janitor.new(), "destroy")
	trackingDict[part] = partJanitor
	local instanceClassesToIgnore = {Seat = true, VehicleSeat = true}
	local instanceNamesToIgnore = {HumanoidRootPart = true}
	if not (instanceClassesToIgnore[part.ClassName] or not instanceNamesToIgnore[part.Name])  then
		part.CanTouch = false
	end
	--
	local partVolume = round((part.Size.X * part.Size.Y * part.Size.Z), 5)
	self.totalPartVolume += partVolume
	--
	partJanitor:add(heartbeat:Connect(function()
		local clockTime = os.clock()
		if clockTime >= nextCheck then
			----
			local cooldown = enum.Accuracy.getProperty(self.accuracy)
			nextCheck = clockTime + cooldown
			----

			-- We initially perform a singular point check as this is vastly more lightweight than a large part check
			-- If the former returns false, perform a whole part check in case the part is on the outer bounds.
			local withinZone = self:findPoint(part.CFrame)
			if not withinZone then
				withinZone = self:findPart(part)
			end
			if not verifiedEntrance then
				if withinZone then
					verifiedEntrance = true
					self.partEntered:Fire(part)
				elseif (part.Position - enterPosition).Magnitude > 1.5 and clockTime - enterTime >= cooldown then
					-- Even after the part has exited the zone, we track it for a brief period of time based upon the criteria
					-- in the line above to ensure the .touched behaviours are not abused
					partJanitor:cleanup()
				end
			elseif not withinZone then
				verifiedEntrance = false
				enterPosition = part.Position
				enterTime = os.clock()
				self.partExited:Fire(part)
			end
		end
	end), "Disconnect")
	partJanitor:add(function()
		trackingDict[part] = nil
		part.CanTouch = true
		self.totalPartVolume = round((self.totalPartVolume - partVolume), 5)
	end, true)
end

local partShapeActions = {
	["Ball"] = function(part)
		return "GetPartBoundsInRadius", {part.Position, part.Size.X}
	end,
	["Block"] = function(part)
		return "GetPartBoundsInBox", {part.CFrame, part.Size}
	end,
	["Other"] = function(part)
		return "GetPartsInPart", {part}
	end,
}
function Zone:_getRegionConstructor(part, overlapParams)
	local success, shapeName = pcall(function() return part.Shape.Name end)
	local methodName, args
	if success and self.allZonePartsAreBlocks then
		local action = partShapeActions[shapeName]
		if action then
			methodName, args = action(part)
		end
	end
	if not methodName then
		methodName, args = partShapeActions.Other(part)
	end
	if overlapParams then
		table.insert(args, overlapParams)
	end
	return methodName, args
end



-- PUBLIC METHODS
function Zone:findLocalPlayer()
	if not localPlayer then
		error("Can only call 'findLocalPlayer' on the client!")
	end
	return self:findPlayer(localPlayer)
end

function Zone:_find(trackerName, item)
	ZoneController.updateDetection(self)
	local tracker = ZoneController.trackers[trackerName]
	local touchingZones = ZoneController.getTouchingZones(item, false, self._currentEnterDetection, tracker)
	for _, zone in pairs(touchingZones) do
		if zone == self then
			return true
		end
	end
	return false
end

function Zone:findPlayer(player)
	local character = player.Character
	local humanoid = character and character:FindFirstChildOfClass("Humanoid")
	if not humanoid then
		return false
	end
	return self:_find("player", player.Character)
end

function Zone:findItem(item)
	return self:_find("item", item)
end

function Zone:findPart(part)
	local methodName, args = self:_getRegionConstructor(part, self.overlapParams.zonePartsWhitelist)
	local touchingZoneParts = self.worldModel[methodName](self.worldModel, unpack(args))
	--local touchingZoneParts = self.worldModel:GetPartsInPart(part, self.overlapParams.zonePartsWhitelist)
	if #touchingZoneParts > 0 then
		return true, touchingZoneParts
	end
	return false
end

function Zone:getCheckerPart()
	local checkerPart = self.checkerPart
	if not checkerPart then
		checkerPart = self.janitor:add(Instance.new("Part"), "Destroy")
		checkerPart.Size = Vector3.new(0.1, 0.1, 0.1)
		checkerPart.Name = "ZonePlusCheckerPart"
		checkerPart.Anchored = true
		checkerPart.Transparency = 1
		checkerPart.CanCollide = false
		self.checkerPart = checkerPart
	end
	local checkerParent = self.worldModel
	if checkerParent == workspace then
		checkerParent = ZoneController.getWorkspaceContainer()
	end
	if checkerPart.Parent ~= checkerParent then
		checkerPart.Parent = checkerParent
	end
	return checkerPart
end

function Zone:findPoint(positionOrCFrame)
	local cframe = positionOrCFrame
	if typeof(positionOrCFrame) == "Vector3" then
		cframe = CFrame.new(positionOrCFrame)
	end
	local checkerPart = self:getCheckerPart()
	checkerPart.CFrame = cframe
	--checkerPart.Parent = self.worldModel
	local methodName, args = self:_getRegionConstructor(checkerPart, self.overlapParams.zonePartsWhitelist)
	local touchingZoneParts = self.worldModel[methodName](self.worldModel, unpack(args))
	--local touchingZoneParts = self.worldModel:GetPartsInPart(self.checkerPart, self.overlapParams.zonePartsWhitelist)
	if #touchingZoneParts > 0 then
		return true, touchingZoneParts
	end
	return false
end

function Zone:_getAll(trackerName)
	ZoneController.updateDetection(self)
	local itemsArray = {}
	local zonesAndOccupants = ZoneController._getZonesAndItems(trackerName, {self = true}, self.volume, false, self._currentEnterDetection)
	local occupantsDict = zonesAndOccupants[self]
	if occupantsDict then
		for item, _ in pairs(occupantsDict) do
			table.insert(itemsArray, item)
		end
	end
	return itemsArray
end

function Zone:getPlayers()
	return self:_getAll("player")
end

function Zone:getItems()
	return self:_getAll("item")
end

function Zone:getParts()
	-- This is designed for infrequent 'one off' use
	-- If you plan on checking for parts within a zone frequently, it's recommended you
	-- use the .partEntered and .partExited events instead.
	local partsArray = {}
	if self.activeTriggers["part"] then
		local trackingDict = self.trackingTouchedTriggers["part"]
		for part, _ in pairs(trackingDict) do
			table.insert(partsArray, part)
		end
		return partsArray
	end
	local partsInRegion = self.worldModel:GetPartBoundsInBox(self.region.CFrame, self.region.Size, self.overlapParams.zonePartsIgnorelist)
	for _, part in pairs(partsInRegion) do
		if self:findPart(part) then
			table.insert(partsArray, part)
		end
	end
	return partsArray
end

function Zone:getRandomPoint()
	local region = self.exactRegion
	local size = region.Size
	local cframe = region.CFrame
	local random = Random.new()
	local randomCFrame
	local success, touchingZoneParts
	local pointIsWithinZone
	repeat
		randomCFrame = cframe * CFrame.new(random:NextNumber(-size.X/2,size.X/2), random:NextNumber(-size.Y/2,size.Y/2), random:NextNumber(-size.Z/2,size.Z/2))
		success, touchingZoneParts = self:findPoint(randomCFrame)
		if success then
			pointIsWithinZone = true
		end
	until pointIsWithinZone
	local randomVector = randomCFrame.Position
	return randomVector, touchingZoneParts
end

function Zone:setAccuracy(enumIdOrName)
	local enumId = tonumber(enumIdOrName)
	if not enumId then
		enumId = enum.Accuracy[enumIdOrName]
		if not enumId then
			error(("'%s' is an invalid enumName!"):format(enumIdOrName))
		end
	else
		local enumName = enum.Accuracy.getName(enumId)
		if not enumName then
			error(("%s is an invalid enumId!"):format(enumId))
		end
	end
	self.accuracy = enumId
end

function Zone:setDetection(enumIdOrName)
	local enumId = tonumber(enumIdOrName)
	if not enumId then
		enumId = enum.Detection[enumIdOrName]
		if not enumId then
			error(("'%s' is an invalid enumName!"):format(enumIdOrName))
		end
	else
		local enumName = enum.Detection.getName(enumId)
		if not enumName then
			error(("%s is an invalid enumId!"):format(enumId))
		end
	end
	self.enterDetection = enumId
	self.exitDetection = enumId
end

function Zone:trackItem(instance)
	local isBasePart = instance:IsA("BasePart")
	local isCharacter = false
	if not isBasePart then
		isCharacter = instance:FindFirstChildOfClass("Humanoid") and instance:FindFirstChild("HumanoidRootPart")
	end

	assert(isBasePart or isCharacter, "Only BaseParts or Characters/NPCs can be tracked!")

	if self.trackedItems[instance] then
		return
	end
	if self.itemsToUntrack[instance] then
		self.itemsToUntrack[instance] = nil
	end

	local itemJanitor = self.janitor:add(Janitor.new(), "destroy")
	local itemDetail = {
		janitor = itemJanitor,
		item = instance,
		isBasePart = isBasePart,
		isCharacter = isCharacter,
	}
	self.trackedItems[instance] = itemDetail

	itemJanitor:add(instance.AncestryChanged:Connect(function()
		if not instance:IsDescendantOf(game) then
			self:untrackItem(instance)
		end
	end), "Disconnect")

	local Tracker = require(trackerModule)
	Tracker.itemAdded:Fire(itemDetail)
end

function Zone:untrackItem(instance)
	local itemDetail = self.trackedItems[instance]
	if itemDetail then
		itemDetail.janitor:destroy()
	end
	self.trackedItems[instance] = nil

	local Tracker = require(trackerModule)
	Tracker.itemRemoved:Fire(itemDetail)
end

function Zone:bindToGroup(settingsGroupName)
	self:unbindFromGroup()
	local group = ZoneController.getGroup(settingsGroupName) or ZoneController.setGroup(settingsGroupName)
	group._memberZones[self.zoneId] = self
	self.settingsGroupName = settingsGroupName
end

function Zone:unbindFromGroup()
	if self.settingsGroupName then
		local group = ZoneController.getGroup(self.settingsGroupName)
		if group then
			group._memberZones[self.zoneId] = nil
		end
		self.settingsGroupName = nil
	end
end

function Zone:relocate()
	if self.hasRelocated then
		return
	end

	local CollectiveWorldModel = require(collectiveWorldModelModule)
	local worldModel = CollectiveWorldModel.setupWorldModel(self)
	self.worldModel = worldModel
	self.hasRelocated = true
	
	local relocationContainer = self.container
	if typeof(relocationContainer) == "table" then
		relocationContainer = Instance.new("Folder")
		for _, zonePart in pairs(self.zoneParts) do
			zonePart.Parent = relocationContainer
		end
	end
	self.relocationContainer = self.janitor:add(relocationContainer, "Destroy", "RelocationContainer")
	relocationContainer.Parent = worldModel
end

function Zone:_onItemCallback(eventName, desiredValue, instance, callbackFunction)
	local detail = self.onItemDetails[instance]
	if not detail then
		detail = {}
		self.onItemDetails[instance] = detail
	end
	if #detail == 0 then
		self.itemsToUntrack[instance] = true
	end
	table.insert(detail, instance)
	self:trackItem(instance)

	local function triggerCallback()
		callbackFunction()
		if self.itemsToUntrack[instance] then
			self.itemsToUntrack[instance] = nil
			self:untrackItem(instance)
		end
	end

	local inZoneAlready = self:findItem(instance)
	if inZoneAlready == desiredValue then
		triggerCallback()
	else
		local connection
		connection = self[eventName]:Connect(function(item)
			if connection and item == instance then
				connection:Disconnect()
				connection = nil
				triggerCallback()
			end
		end)
		--[[
		if typeof(expireAfterSeconds) == "number" then
			task.delay(expireAfterSeconds, function()
				if connection ~= nil then
					print("EXPIRE!")
					connection:Disconnect()
					connection = nil
					triggerCallback()
				end
			end)
		end
		--]]
	end
end

function Zone:onItemEnter(...)
	self:_onItemCallback("itemEntered", true, ...)
end

function Zone:onItemExit(...)
	self:_onItemCallback("itemExited", false, ...)
end

function Zone:destroy()
	self:unbindFromGroup()
	self.janitor:destroy()
end
Zone.Destroy = Zone.destroy



return Zone</string>
                </Properties>
                <Item class="ModuleScript" referent="316">
                  <Properties>
                    <string name="Name">Enum</string>
                    <string name="Source"><![CDATA[-- Custom enum implementation that provides an effective way to compare, send
-- and store values. Instead of returning a userdata value, enum items return
-- their corresponding itemValue (an integer) when indexed. Enum items can
-- also associate a 'property', specified as the third element, which can be
-- retrieved by doing ``enum.getProperty(ITEM_NAME_OR_VALUE)``
-- This ultimately means groups of data can be easily categorised, efficiently
-- transmitted over networks and saved without throwing errors.
-- Ben Horton (ForeverHD)



-- LOCAL
local Enum = {}
local enums = {}
Enum.enums = enums



-- METHODS
function Enum.createEnum(enumName, details)
	assert(typeof(enumName) == "string", "bad argument #1 - enums must be created using a string name!")
	assert(typeof(details) == "table", "bad argument #2 - enums must be created using a table!")
	assert(not enums[enumName], ("enum '%s' already exists!"):format(enumName))
	
	local enum = {}
	local usedNames = {}
	local usedValues = {}
	local usedProperties = {}
	local enumMetaFunctions = {
		getName = function(valueOrProperty)
			valueOrProperty = tostring(valueOrProperty)
			local index = usedValues[valueOrProperty]
			if not index then
				index = usedProperties[valueOrProperty]
			end
			if index then
				return details[index][1]
			end
		end,
		getValue = function(nameOrProperty)
			nameOrProperty = tostring(nameOrProperty)
			local index = usedNames[nameOrProperty]
			if not index then
				index = usedProperties[nameOrProperty]
			end
			if index then
				return details[index][2]
			end
		end,
		getProperty = function(nameOrValue)
			nameOrValue = tostring(nameOrValue)
			local index = usedNames[nameOrValue]
			if not index then
				index = usedValues[nameOrValue]
			end
			if index then
				return details[index][3]
			end
		end
	}
	for i, detail in pairs(details) do
		assert(typeof(detail) == "table", ("bad argument #2.%s - details must only be comprised of tables!"):format(i))
		local name = detail[1]
		assert(typeof(name) == "string", ("bad argument #2.%s.1 - detail name must be a string!"):format(i))
		assert(typeof(not usedNames[name]), ("bad argument #2.%s.1 - the detail name '%s' already exists!"):format(i, name))
		assert(typeof(not enumMetaFunctions[name]), ("bad argument #2.%s.1 - that name is reserved."):format(i, name))
		usedNames[tostring(name)] = i
		local value = detail[2]
		local valueString = tostring(value)
		--assert(typeof(value) == "number" and math.ceil(value)/value == 1, ("bad argument #2.%s.2 - detail value must be an integer!"):format(i))
		assert(typeof(not usedValues[valueString]), ("bad argument #2.%s.2 - the detail value '%s' already exists!"):format(i, valueString))
		usedValues[valueString] = i
		local property = detail[3]
		if property then
			assert(typeof(not usedProperties[property]), ("bad argument #2.%s.3 - the detail property '%s' already exists!"):format(i, tostring(property)))
			usedProperties[tostring(property)] = i
		end
		enum[name] = value
		setmetatable(enum, {
			__index = function(_, index)
				return(enumMetaFunctions[index])
			end
		})
	end
	
	enums[enumName] = enum
	return enum
end

function Enum.getEnums()
	return enums
end



-- SETUP ENUMS
local createEnum = Enum.createEnum
for _, childModule in pairs(script:GetChildren()) do
	if childModule:IsA("ModuleScript") then
		local enumDetail = require(childModule)
		createEnum(childModule.Name, enumDetail)
	end
end

--[[
-- Example enum
createEnum("Color", {
	{"White", 1, Color3.fromRGB(255, 255, 255)},
	{"Black", 2, Color3.fromRGB(0, 0, 0)},
})
--]]



return Enum
]]></string>
                  </Properties>
                  <Item class="ModuleScript" referent="317">
                    <Properties>
                      <string name="Name">Accuracy</string>
                      <string name="Source">-- enumName, enumValue, additionalProperty
-- in this case, additionalProperty is the delay between each check
return {
	{"Low", 	1,	1.0},
	{"Medium",	2,	0.5},
	{"High",	3,	0.1},
	{"Precise",	4,	0.0},
}</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="318">
                    <Properties>
                      <string name="Name">Detection</string>
                      <string name="Source">-- Important note: Precision checks currently only for 'players' and the 'localplayer', not 'parts'.

-- enumName, enumValue, additionalProperty
return {
	{"WholeBody", 1}, -- Multiple checks will be casted over an entire players character
	{"Centre", 2}, -- A singular check will be performed on the players HumanoidRootPart
	--{"Automatic", 3}, -- REMOVED DUE TO UNECESSARY COMPLEXITY. ZonePlus will dynamically switch between 'WholeBody' and 'Centre' depending upon the number of players in a server (this typically only occurs for servers with 100+ players when volume checks begin to exceed 0.5% in script performance).
}</string>
                    </Properties>
                  </Item>
                </Item>
                <Item class="ModuleScript" referent="319">
                  <Properties>
                    <string name="Name">Janitor</string>
                    <string name="Source">-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark
-- LinkToInstance fixed by Elttob.

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat

local IndicesReference = newproxy(true)
getmetatable(IndicesReference).__tostring = function()
	return "IndicesReference"
end

local LinkToInstanceIndex = newproxy(true)
getmetatable(LinkToInstanceIndex).__tostring = function()
	return "LinkToInstanceIndex"
end

local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
--local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))"

local Janitor = {
	ClassName = "Janitor";
	__index = {
		CurrentlyCleaning = true;
		[IndicesReference] = nil;
	};
}

local TypeDefaults = {
	["function"] = true;
	RBXScriptConnection = "Disconnect";
}

--[[**
	Instantiates a new Janitor object.
	@returns [t:Janitor]
**--]]
function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false;
		[IndicesReference] = nil;
	}, Janitor)
end

--[[**
	Determines if the passed object is a Janitor.
	@param [t:any] Object The object you are checking.
	@returns [t:boolean] Whether or not the object is a Janitor.
**--]]
function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end

Janitor.is = Janitor.Is

--[[**
	Adds an `Object` to Janitor for later cleanup, where `MethodName` is the key of the method within `Object` which should be called at cleanup time. If the `MethodName` is `true` the `Object` itself will be called instead. If passed an index it will occupy a namespace which can be `Remove()`d or overwritten. Returns the `Object`.
	@param [t:any] Object The object you want to clean up.
	@param [t:string|true?] MethodName The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes `Destroy`.
	@param [t:any?] Index The index that can be used to clean up the object manually.
	@returns [t:any] The object that was passed.
**--]]
function Janitor.__index:Add(Object, MethodName, Index)
	if Index == nil then
		Index = newproxy(false)
	end

	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]
		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end
	--[[
	if Promise.is(Object) then
		local Id = newproxy(false)
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	end--]]

	MethodName = MethodName or TypeDefaults[typeof(Object)] or "Destroy"
	if type(Object) ~= "function" and not Object[MethodName] then
		warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil, 2)))
	end

	self[Object] = MethodName
	return Object, Index
end

Janitor.__index.Give = Janitor.__index.Add

-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.

--[[**
	Adds a promise to the janitor. If the janitor is cleaned up and the promise is not completed, the promise will be cancelled.
	@param [t:Promise] PromiseObject The promise you want to add to the janitor.
	@returns [t:Promise]
**--]]
--[[
function Janitor.__index:AddPromise(PromiseObject)
	if not Promise.is(PromiseObject) then
		error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
	end

	if PromiseObject:getStatus() == Promise.Status.Started then
		local Id = newproxy(false)
		local NewPromise = self:Add(Promise.resolve(PromiseObject), "cancel", Id)
		NewPromise:finallyCall(self.Remove, self, Id)
		return NewPromise, Id
	else
		return PromiseObject
	end
end
--]]

--Janitor.__index.GivePromise = Janitor.__index.AddPromise

-- This will assume whether or not the object is a Promise or a regular object.
function Janitor.__index:AddObject(Object)
	local Id = newproxy(false)
	--[[
	if Promise.is(Object) then
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	else
		return self:Add(Object, false, Id), Id
	end---]]
	return self:Add(Object, false, Id), Id
end

Janitor.__index.GiveObject = Janitor.__index.AddObject

--[[**
	Cleans up whatever `Object` was set to this namespace by the 3rd parameter of `:Add()`.
	@param [t:any] Index The index you want to remove.
	@returns [t:Janitor] The same janitor, for chaining reasons.
**--]]
function Janitor.__index:Remove(Index)
	local This = self[IndicesReference]

	if This then
		local Object = This[Index]

		if Object then
			local MethodName = self[Object]

			if MethodName then
				if MethodName == true then
					Object()
				else
					local ObjectMethod = Object[MethodName]
					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end

--[[**
	Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the job using `__index`.
	@param [t:any] Index The index that the object is stored under.
	@returns [t:any?] This will return the object if it is found, but it won't return anything if it doesn't exist.
**--]]
function Janitor.__index:Get(Index)
	local This = self[IndicesReference]
	if This then
		return This[Index]
	end
end

--[[**
	Calls each Object's `MethodName` (or calls the Object if `MethodName == true`) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor Object (so it can be used as a destructor callback).
	@returns [t:void]
**--]]
function Janitor.__index:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil
		for Object, MethodName in next, self do
			if Object == IndicesReference then
				continue
			end

			-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.
			local TypeOf = type(Object)
			if TypeOf == "string" or TypeOf == "number" then
				self[Object] = nil
				continue
			end

			if MethodName == true then
				Object()
			else
				local ObjectMethod = Object[MethodName]
				if ObjectMethod then
					ObjectMethod(Object)
				end
			end

			self[Object] = nil
		end

		local This = self[IndicesReference]
		if This then
			for Index in next, This do
				This[Index] = nil
			end

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end

Janitor.__index.Clean = Janitor.__index.Cleanup

--[[**
	Calls `:Cleanup()` and renders the Janitor unusable.
	@returns [t:void]
**--]]
function Janitor.__index:Destroy()
	self:Cleanup()
	--table.clear(self)
	--setmetatable(self, nil)
end

Janitor.__call = Janitor.__index.Cleanup

--- Makes the Janitor clean up when the instance is destroyed
-- @param Instance Instance The Instance the Janitor will wait for to be Destroyed
-- @returns Disconnectable table to stop Janitor from being cleaned up upon Instance Destroy (automatically cleaned up by Janitor, btw)
-- @author Corecii
local Disconnect = {Connected = true}
Disconnect.__index = Disconnect
function Disconnect:Disconnect()
	if self.Connected then
		self.Connected = false
		self.Connection:Disconnect()
	end
end

function Disconnect:__tostring()
	return "Disconnect&lt;" .. tostring(self.Connected) .. ">"
end

--[[**
	"Links" this Janitor to an Instance, such that the Janitor will `Cleanup` when the Instance is `Destroyed()` and garbage collected. A Janitor may only be linked to one instance at a time, unless `AllowMultiple` is true. When called with a truthy `AllowMultiple` parameter, the Janitor will "link" the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy `AllowMultiple` parameter, the Janitor will overwrite the previous link which was also called with a falsy `AllowMultiple` parameter, if applicable.
	@param [t:Instance] Object The instance you want to link the Janitor to.
	@param [t:boolean?] AllowMultiple Whether or not to allow multiple links on the same Janitor.
	@returns [t:RbxScriptConnection] A pseudo RBXScriptConnection that can be disconnected.
**--]]
function Janitor.__index:LinkToInstance(Object, AllowMultiple)
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, Disconnect)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				coroutine.wrap(function()
					Heartbeat:Wait()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							Heartbeat:Wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)()
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil
	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end

--[[**
	Links several instances to a janitor, which is then returned.
	@param [t:...Instance] ... All the instances you want linked.
	@returns [t:Janitor] A janitor that can be used to manually disconnect all LinkToInstances.
**--]]
function Janitor.__index:LinkToInstances(...)
	local ManualCleanup = Janitor.new()
	for _, Object in ipairs({...}) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end

for FunctionName, Function in next, Janitor.__index do
	local NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)
	Janitor.__index[NewFunctionName] = Function
end

return Janitor</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="320">
                  <Properties>
                    <string name="Name">OldSignal</string>
                    <string name="Source">local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local heartbeat = RunService.Heartbeat
local Signal = {}
Signal.__index = Signal
Signal.ClassName = "Signal"
Signal.totalConnections = 0



-- CONSTRUCTOR
function Signal.new(createConnectionsChangedSignal)
	local self = setmetatable({}, Signal)
	
	if createConnectionsChangedSignal then
		self.connectionsChanged = Signal.new()
	end

	self.connections = {}
	self.totalConnections = 0
	self.waiting = {}
	self.totalWaiting = 0

	return self
end



-- METHODS
function Signal:Fire(...)
	for _, connection in pairs(self.connections) do
		--connection.Handler(...)
		task.spawn(connection.Handler, ...)
	end
	if self.totalWaiting > 0 then
		local packedArgs = table.pack(...)
		for waitingId, _ in pairs(self.waiting) do
			self.waiting[waitingId] = packedArgs
		end
	end
end
Signal.fire = Signal.Fire

function Signal:Connect(handler)
	if not (type(handler) == "function") then
		error(("connect(%s)"):format(typeof(handler)), 2)
	end
	
	local signal = self
	local connectionId = HttpService:GenerateGUID(false)
	local connection = {}
	connection.Connected = true
	connection.ConnectionId = connectionId
	connection.Handler = handler
	self.connections[connectionId] = connection

	function connection:Disconnect()
		signal.connections[connectionId] = nil
		connection.Connected = false
		signal.totalConnections -= 1
		if signal.connectionsChanged then
			signal.connectionsChanged:Fire(-1)
		end
	end
	connection.Destroy = connection.Disconnect
	connection.destroy = connection.Disconnect
	connection.disconnect = connection.Disconnect
	self.totalConnections += 1
	if self.connectionsChanged then
		self.connectionsChanged:Fire(1)
	end

	return connection
end
Signal.connect = Signal.Connect

function Signal:Wait()
	local waitingId = HttpService:GenerateGUID(false)
	self.waiting[waitingId] = true
	self.totalWaiting += 1
	repeat heartbeat:Wait() until self.waiting[waitingId] ~= true
	self.totalWaiting -= 1
	local args = self.waiting[waitingId]
	self.waiting[waitingId] = nil
	return unpack(args)
end
Signal.wait = Signal.Wait

function Signal:Destroy()
	if self.bindableEvent then
		self.bindableEvent:Destroy()
		self.bindableEvent = nil
	end
	if self.connectionsChanged then
		self.connectionsChanged:Fire(-self.totalConnections)
		self.connectionsChanged:Destroy()
		self.connectionsChanged = nil
	end
	self.totalConnections = 0
	for connectionId, connection in pairs(self.connections) do
		self.connections[connectionId] = nil
	end
end
Signal.destroy = Signal.Destroy
Signal.Disconnect = Signal.Destroy
Signal.disconnect = Signal.Destroy



return Signal</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="321">
                  <Properties>
                    <string name="Name">Signal</string>
                    <string name="Source">--------------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- Licence:                                                                   --
--   Licenced under the MIT licence.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--------------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be 
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		_connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	assert(self._connected, "Can't disconnect a connection twice.", 2)
	self._connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
    local signal = self._signal
	if signal._handlerListHead == self then
		signal._handlerListHead = self._next
	else
		local prev = signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end

    if signal.connectionsChanged then
		signal.totalConnections -= 1
        signal.connectionsChanged:Fire(-1)
    end
end

-- Make Connection strict
setmetatable(Connection, {
	__index = function(tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

-- Signal class
local Signal = {}
Signal.__index = Signal

function Signal.new(createConnectionsChangedSignal)
	local self = setmetatable({
		_handlerListHead = false,	
	}, Signal)
    if createConnectionsChangedSignal then
        self.totalConnections = 0
		self.connectionsChanged = Signal.new()
	end
    return self
end

function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end

	if self.connectionsChanged then
        self.totalConnections += 1
		self.connectionsChanged:Fire(1)
	end
	return connection
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
function Signal:DisconnectAll()
	self._handlerListHead = false

    if self.connectionsChanged then
		self.connectionsChanged:Fire(-self.totalConnections)
		self.connectionsChanged:Destroy()
		self.connectionsChanged = nil
		self.totalConnections = 0
	end
end
Signal.Destroy = Signal.DisconnectAll
Signal.destroy = Signal.DisconnectAll

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item._connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

-- Implement Signal:Wait() in terms of a temporary connection using
-- a Signal:Connect() which disconnects itself.
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local cn;
	cn = self:Connect(function(...)
		cn:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end


return Signal</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="322">
                  <Properties>
                    <string name="Name">VERSION</string>
                    <string name="Source">-- v3.2.0</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="323">
                  <Properties>
                    <string name="Name">ZoneController</string>
                    <string name="Source">-- CONFIG
local WHOLE_BODY_DETECTION_LIMIT = 729000 -- This is roughly the volume where Region3 checks begin to exceed 0.5% in Script Performance



-- LOCAL
local Janitor = require(script.Parent.Janitor)
local Enum_ = require(script.Parent.Enum)
local Signal = require(script.Parent.Signal)
local Tracker = require(script.Tracker)
local CollectiveWorldModel = require(script.CollectiveWorldModel)
local enum = Enum_.enums
local players = game:GetService("Players")
local activeZones = {}
local activeZonesTotalVolume = 0
local activeTriggers = {}
local registeredZones = {}
local activeParts = {}
local activePartToZone = {}
local allParts = {}
local allPartToZone = {}
local activeConnections = 0
local runService = game:GetService("RunService")
local heartbeat = runService.Heartbeat
local heartbeatConnections = {}
local localPlayer = runService:IsClient() and players.LocalPlayer



-- PUBLIC
local ZoneController = {}
local trackers = {}
trackers.player = Tracker.new("player")
trackers.item = Tracker.new("item")
ZoneController.trackers = trackers



-- LOCAL FUNCTIONS
local function dictLength(dictionary)
	local count = 0
	for _, _ in pairs(dictionary) do
		count += 1
	end
	return count
end

local function fillOccupants(zonesAndOccupantsTable, zone, occupant)
	local occupantsDict = zonesAndOccupantsTable[zone]
	if not occupantsDict then
		occupantsDict = {}
		zonesAndOccupantsTable[zone] = occupantsDict
	end
	local prevCharacter = occupant:IsA("Player") and occupant.Character
	occupantsDict[occupant] = (prevCharacter or true)
end

local heartbeatActions = {
	["player"] = function(recommendedDetection)
		return ZoneController._getZonesAndItems("player", activeZones, activeZonesTotalVolume, true, recommendedDetection)
	end,
	["localPlayer"] = function(recommendedDetection)
		local zonesAndOccupants = {}
		local character = localPlayer.Character
		if not character then
			return zonesAndOccupants
		end
		local touchingZones = ZoneController.getTouchingZones(character, true, recommendedDetection, trackers.player)
		for _, zone in pairs(touchingZones) do
			if zone.activeTriggers["localPlayer"] then
				fillOccupants(zonesAndOccupants, zone, localPlayer)
			end
		end
		return zonesAndOccupants
	end,
	["item"] = function(recommendedDetection)
		return ZoneController._getZonesAndItems("item", activeZones, activeZonesTotalVolume, true, recommendedDetection)
	end,
}



-- PRIVATE FUNCTIONS
function ZoneController._registerZone(zone)
   	registeredZones[zone] = true
	local registeredJanitor = zone.janitor:add(Janitor.new(), "destroy")
	zone._registeredJanitor = registeredJanitor
	registeredJanitor:add(zone.updated:Connect(function()
		ZoneController._updateZoneDetails()
	end), "Disconnect")
   ZoneController._updateZoneDetails()
end

function ZoneController._deregisterZone(zone)
	registeredZones[zone] = nil
	zone._registeredJanitor:destroy()
	zone._registeredJanitor = nil
	ZoneController._updateZoneDetails()
end

function ZoneController._registerConnection(registeredZone, registeredTriggerType)
	local originalItems = dictLength(registeredZone.activeTriggers)
	activeConnections += 1
	if originalItems == 0 then
		activeZones[registeredZone] = true
		ZoneController._updateZoneDetails()
	end
	local currentTriggerCount = activeTriggers[registeredTriggerType]
	activeTriggers[registeredTriggerType] = (currentTriggerCount and currentTriggerCount+1) or 1
	registeredZone.activeTriggers[registeredTriggerType] = true
	if registeredZone.touchedConnectionActions[registeredTriggerType] then
		registeredZone:_formTouchedConnection(registeredTriggerType)
	end
	if heartbeatActions[registeredTriggerType] then
		ZoneController._formHeartbeat(registeredTriggerType)
	end
end

-- This decides what to do if detection is 'Automatic'
-- This is placed in ZoneController instead of the Zone object due to the ZoneControllers all-knowing group-minded logic
function ZoneController.updateDetection(zone)
	local detectionTypes = {
		["enterDetection"] = "_currentEnterDetection",
		["exitDetection"] = "_currentExitDetection",
	}
	for detectionType, currentDetectionName in pairs(detectionTypes) do
		local detection = zone[detectionType]
		local combinedTotalVolume = Tracker.getCombinedTotalVolumes()
		if detection == enum.Detection.Automatic then
			if combinedTotalVolume > WHOLE_BODY_DETECTION_LIMIT then
				detection = enum.Detection.Centre
			else
				detection = enum.Detection.WholeBody
			end
		end
		zone[currentDetectionName] = detection
	end
end

function ZoneController._formHeartbeat(registeredTriggerType)
	local heartbeatConnection = heartbeatConnections[registeredTriggerType]
	if heartbeatConnection then return end
	-- This will only ever connect once per triggerType per server
	-- This means instead of initiating a loop per-zone we can handle everything within
	-- a singular connection. This is particularly beneficial for player/item-orinetated
	-- checking, where a check only needs to be cast once per interval, as apposed
	-- to every zone per interval
	-- I utilise heartbeat with os.clock() to provide precision (where needed) and flexibility
	local nextCheck = 0
	heartbeatConnection = heartbeat:Connect(function()
		local clockTime = os.clock()
		if clockTime >= nextCheck then
			local lowestAccuracy
			local lowestDetection
			for zone, _ in pairs(activeZones) do
				if zone.activeTriggers[registeredTriggerType] then
					local zAccuracy = zone.accuracy
					if lowestAccuracy == nil or zAccuracy &lt; lowestAccuracy then
						lowestAccuracy = zAccuracy
					end
					ZoneController.updateDetection(zone)
					local zDetection = zone._currentEnterDetection
					if lowestDetection == nil or zDetection &lt; lowestDetection then
						lowestDetection = zDetection
					end
				end
			end
			local highestAccuracy = lowestAccuracy
			local zonesAndOccupants = heartbeatActions[registeredTriggerType](lowestDetection)

			-- If a zone belongs to a settingsGroup with 'onlyEnterOnceExitedAll = true' , and the occupant already exists in a member group, then
			-- ignore all incoming occupants for the other zones (preventing the enteredSignal from being fired until the occupant has left
			-- all other zones within the same settingGroup)
			local occupantsToBlock = {}
			local zonesToPotentiallyIgnore = {}
			for zone, newOccupants in pairs(zonesAndOccupants) do
				local settingsGroup = (zone.settingsGroupName and ZoneController.getGroup(zone.settingsGroupName))
				if settingsGroup and settingsGroup.onlyEnterOnceExitedAll == true then
					--local currentOccupants = zone.occupants[registeredTriggerType]
					--if currentOccupants then
						for newOccupant, _ in pairs(newOccupants) do
							--if currentOccupants[newOccupant] then
								local groupDetail = occupantsToBlock[zone.settingsGroupName]
								if not groupDetail then
									groupDetail = {}
									occupantsToBlock[zone.settingsGroupName] = groupDetail
								end
								groupDetail[newOccupant] = zone
							--end
						end
						zonesToPotentiallyIgnore[zone] = newOccupants
					--end
				end
			end
			for zone, newOccupants in pairs(zonesToPotentiallyIgnore) do
				local groupDetail = occupantsToBlock[zone.settingsGroupName]
				if groupDetail then
					for newOccupant, _ in pairs(newOccupants) do
						local occupantToKeepZone = groupDetail[newOccupant]
						if occupantToKeepZone and occupantToKeepZone ~= zone then
							newOccupants[newOccupant] = nil
						end
					end
				end
			end

			-- This deduces what signals should be fired
			local collectiveSignalsToFire = {{}, {}}
			for zone, _ in pairs(activeZones) do
				if zone.activeTriggers[registeredTriggerType] then
					local zAccuracy = zone.accuracy
					local occupantsDict = zonesAndOccupants[zone] or {}
					local occupantsPresent = false
					for k,v in pairs(occupantsDict) do
						occupantsPresent = true
						break
					end
					if occupantsPresent and zAccuracy > highestAccuracy then
						highestAccuracy = zAccuracy
					end
					local signalsToFire = zone:_updateOccupants(registeredTriggerType, occupantsDict)
					collectiveSignalsToFire[1][zone] = signalsToFire.exited
					collectiveSignalsToFire[2][zone] = signalsToFire.entered
				end
			end

			-- This ensures all exited signals and called before entered signals
			local indexToSignalType = {"Exited", "Entered"}
			for index, zoneAndOccupants in pairs(collectiveSignalsToFire) do
				local signalType = indexToSignalType[index]
				local signalName = registeredTriggerType..signalType
				for zone, occupants in pairs(zoneAndOccupants) do
					local signal = zone[signalName]
					if signal then
						for _, occupant in pairs(occupants) do
							signal:Fire(occupant)
						end
					end
				end
			end

			local cooldown = enum.Accuracy.getProperty(highestAccuracy)
			nextCheck = clockTime + cooldown
		end
	end)
	heartbeatConnections[registeredTriggerType] = heartbeatConnection
end

function ZoneController._deregisterConnection(registeredZone, registeredTriggerType)
	activeConnections -= 1
	if activeTriggers[registeredTriggerType] == 1 then
		activeTriggers[registeredTriggerType] = nil
		local heartbeatConnection = heartbeatConnections[registeredTriggerType]
		if heartbeatConnection then
			heartbeatConnections[registeredTriggerType] = nil
			heartbeatConnection:Disconnect()
		end
	else
		activeTriggers[registeredTriggerType] -= 1
	end
	registeredZone.activeTriggers[registeredTriggerType] = nil
	if dictLength(registeredZone.activeTriggers) == 0 then
		activeZones[registeredZone] = nil
		ZoneController._updateZoneDetails()
	end
	if registeredZone.touchedConnectionActions[registeredTriggerType] then
		registeredZone:_disconnectTouchedConnection(registeredTriggerType)
	end
end

function ZoneController._updateZoneDetails()
	activeParts = {}
	activePartToZone = {}
	allParts = {}
	allPartToZone = {}
	activeZonesTotalVolume = 0
	for zone, _ in pairs(registeredZones) do
		local isActive = activeZones[zone]
		if isActive then
			activeZonesTotalVolume += zone.volume
		end
		for _, zonePart in pairs(zone.zoneParts) do
			if isActive then
				table.insert(activeParts, zonePart)
				activePartToZone[zonePart] = zone
			end
			table.insert(allParts, zonePart)
			allPartToZone[zonePart] = zone
		end
	end
end

function ZoneController._getZonesAndItems(trackerName, zonesDictToCheck, zoneCustomVolume, onlyActiveZones, recommendedDetection)
	local totalZoneVolume = zoneCustomVolume
	if not totalZoneVolume then
		for zone, _ in pairs(zonesDictToCheck) do
			totalZoneVolume += zone.volume
		end
	end
	local zonesAndOccupants = {}
	local tracker = trackers[trackerName]
	if tracker.totalVolume &lt; totalZoneVolume then
		-- If the volume of all *characters/items* within the server is *less than* the total
		-- volume of all active zones (i.e. zones which listen for .playerEntered)
		-- then it's more efficient cast checks within each character and
		-- then determine the zones they belong to
		for _, item in pairs(tracker.items) do
			local touchingZones = ZoneController.getTouchingZones(item, onlyActiveZones, recommendedDetection, tracker)
			for _, zone in pairs(touchingZones) do
				if not onlyActiveZones or zone.activeTriggers[trackerName] then
					local finalItem = item
					if trackerName == "player" then
						finalItem = players:GetPlayerFromCharacter(item)
					end
					if finalItem then
						fillOccupants(zonesAndOccupants, zone, finalItem)
					end
				end
			end
		end
	else
		-- If the volume of all *active zones* within the server is *less than* the total
		-- volume of all characters/items, then it's more efficient to perform the
		-- checks directly within each zone to determine players inside
		for zone, _ in pairs(zonesDictToCheck) do
			if not onlyActiveZones or zone.activeTriggers[trackerName] then
				local result = CollectiveWorldModel:GetPartBoundsInBox(zone.region.CFrame, zone.region.Size, tracker.whitelistParams)
				local finalItemsDict = {}
				for _, itemOrChild in pairs(result) do
					local correspondingItem = tracker.partToItem[itemOrChild]
					if not finalItemsDict[correspondingItem] then
						finalItemsDict[correspondingItem] = true
					end
				end
				for item, _ in pairs(finalItemsDict) do
					if trackerName == "player" then
						local player = players:GetPlayerFromCharacter(item)
						if zone:findPlayer(player) then
							fillOccupants(zonesAndOccupants, zone, player)
						end
					elseif zone:findItem(item) then
						fillOccupants(zonesAndOccupants, zone, item)
					end
				end
			end
		end
	end
	return zonesAndOccupants
end



-- PUBLIC FUNCTIONS
function ZoneController.getZones()
	local registeredZonesArray = {}
	for zone, _ in pairs(registeredZones) do
		table.insert(registeredZonesArray, zone)
	end
	return registeredZonesArray
end

--[[
-- the player touched events which utilise active zones at the moment may change to the new CanTouch method for parts in the future
-- hence im disabling this as it may be depreciated quite soon
function ZoneController.getActiveZones()
	local zonesArray = {}
	for zone, _ in pairs(activeZones) do
		table.insert(zonesArray, zone)
	end
	return zonesArray
end
--]]

function ZoneController.getTouchingZones(item, onlyActiveZones, recommendedDetection, tracker)
	local exitDetection, finalDetection
	if tracker then
		exitDetection = tracker.exitDetections[item]
		tracker.exitDetections[item] = nil
	end
	finalDetection = exitDetection or recommendedDetection

	local itemSize, itemCFrame
	local itemIsBasePart = item:IsA("BasePart")
	local itemIsCharacter = not itemIsBasePart
	local bodyPartsToCheck = {}
	if itemIsBasePart then
		itemSize, itemCFrame = item.Size, item.CFrame
		table.insert(bodyPartsToCheck, item)
	elseif finalDetection == enum.Detection.WholeBody then
		itemSize, itemCFrame = Tracker.getCharacterSize(item)
		bodyPartsToCheck = item:GetChildren()
	else
		local hrp = item:FindFirstChild("HumanoidRootPart")
		if hrp then
			itemSize, itemCFrame = hrp.Size, hrp.CFrame
			table.insert(bodyPartsToCheck, hrp)
		end
	end
	if not itemSize or not itemCFrame then return {} end

	--[[
	local part = Instance.new("Part")
	part.Size = itemSize
	part.CFrame = itemCFrame
	part.Anchored = true
	part.CanCollide = false
	part.Color = Color3.fromRGB(255, 0, 0)
	part.Transparency = 0.4
	part.Parent = workspace
	game:GetService("Debris"):AddItem(part, 2)
	--]]
	local partsTable = (onlyActiveZones and activeParts) or allParts
	local partToZoneDict = (onlyActiveZones and activePartToZone) or allPartToZone

	local boundParams = OverlapParams.new()
	boundParams.FilterType = Enum.RaycastFilterType.Whitelist
	boundParams.MaxParts = #partsTable
	boundParams.FilterDescendantsInstances = partsTable

	-- This retrieves the bounds (the rough shape) of all parts touching the item/character
	-- If the corresponding zone is made up of *entirely* blocks then the bound will
	-- be the actual shape of the part.
	local touchingPartsDictionary = {}
	local zonesDict = {}
	local boundParts = CollectiveWorldModel:GetPartBoundsInBox(itemCFrame, itemSize, boundParams)
	local boundPartsThatRequirePreciseChecks = {}
	for _, boundPart in pairs(boundParts) do
		local correspondingZone = partToZoneDict[boundPart]
		if correspondingZone and correspondingZone.allZonePartsAreBlocks then
			zonesDict[correspondingZone] = true
			touchingPartsDictionary[boundPart] = correspondingZone
		else
			table.insert(boundPartsThatRequirePreciseChecks, boundPart)
		end
	end

	-- If the bound parts belong to a zone that isn't entirely made up of blocks, then
	-- we peform additional checks using GetPartsInPart which enables shape
	-- geometries to be precisely determined for non-block baseparts.
	local totalRemainingBoundParts = #boundPartsThatRequirePreciseChecks
	local precisePartsCount = 0
	if totalRemainingBoundParts > 0 then
		
		local preciseParams = OverlapParams.new()
		preciseParams.FilterType = Enum.RaycastFilterType.Whitelist
		preciseParams.MaxParts = totalRemainingBoundParts
		preciseParams.FilterDescendantsInstances = boundPartsThatRequirePreciseChecks

		local character = item
		for _, bodyPart in pairs(bodyPartsToCheck) do
			local endCheck = false
			if not bodyPart:IsA("BasePart") or (itemIsCharacter and Tracker.bodyPartsToIgnore[bodyPart.Name]) then
				continue
			end
			local preciseParts = CollectiveWorldModel:GetPartsInPart(bodyPart, preciseParams)
			for _, precisePart in pairs(preciseParts) do
				if not touchingPartsDictionary[precisePart] then
					local correspondingZone = partToZoneDict[precisePart]
					if correspondingZone then
						zonesDict[correspondingZone] = true
						touchingPartsDictionary[precisePart] = correspondingZone
						precisePartsCount += 1
					end
					if precisePartsCount == totalRemainingBoundParts then
						endCheck = true
						break
					end
				end
			end
			if endCheck then
				break
			end
		end
	end
	
	local touchingZonesArray = {}
	local newExitDetection
	for zone, _ in pairs(zonesDict) do
		if newExitDetection == nil or zone._currentExitDetection &lt; newExitDetection then
			newExitDetection = zone._currentExitDetection
		end
		table.insert(touchingZonesArray, zone)
	end
	if newExitDetection and tracker then
		tracker.exitDetections[item] = newExitDetection
	end
	return touchingZonesArray, touchingPartsDictionary
end

local settingsGroups = {}
function ZoneController.setGroup(settingsGroupName, properties)
	local group = settingsGroups[settingsGroupName]
	if not group then
		group = {}
		settingsGroups[settingsGroupName] = group
	end
	

	-- PUBLIC PROPERTIES --
	group.onlyEnterOnceExitedAll = true
	
	-- PRIVATE PROPERTIES --
	group._name = settingsGroupName
	group._memberZones = {}


	if typeof(properties) == "table" then
		for k, v in pairs(properties) do
			group[k] = v
		end
	end
	return group
end

function ZoneController.getGroup(settingsGroupName)
	return settingsGroups[settingsGroupName]
end

local workspaceContainer
local workspaceContainerName = string.format("ZonePlus%sContainer", (runService:IsClient() and "Client") or "Server")
function ZoneController.getWorkspaceContainer()
	local container = workspaceContainer or workspace:FindFirstChild(workspaceContainerName)
	if not container then
		container = Instance.new("Folder")
		container.Name = workspaceContainerName
		container.Parent = workspace
		workspaceContainer = container
	end
	return container
end



return ZoneController</string>
                  </Properties>
                  <Item class="ModuleScript" referent="324">
                    <Properties>
                      <string name="Name">CollectiveWorldModel</string>
                      <string name="Source">local CollectiveWorldModel = {}
local worldModel
local runService = game:GetService("RunService")



-- FUNCTIONS
function CollectiveWorldModel.setupWorldModel(zone)
	if worldModel then
		return worldModel
	end
	local location = (runService:IsClient() and "ReplicatedStorage") or "ServerStorage"
	worldModel = Instance.new("WorldModel")
	worldModel.Name = "ZonePlusWorldModel"
	worldModel.Parent = game:GetService(location)
	return worldModel
end



-- METHODS
function CollectiveWorldModel:_getCombinedResults(methodName, ...)
	local results = workspace[methodName](workspace, ...)
	if worldModel then
		local additionalResults = worldModel[methodName](worldModel, ...)
		for _, result in pairs(additionalResults) do
			table.insert(results, result)
		end
	end
	return results
end

function CollectiveWorldModel:GetPartBoundsInBox(cframe, size, overlapParams)
	return self:_getCombinedResults("GetPartBoundsInBox", cframe, size, overlapParams)
end

function CollectiveWorldModel:GetPartBoundsInRadius(position, radius, overlapParams)
	return self:_getCombinedResults("GetPartBoundsInRadius", position, radius, overlapParams)
end

function CollectiveWorldModel:GetPartsInPart(part, overlapParams)
	return self:_getCombinedResults("GetPartsInPart", part, overlapParams)
end



return CollectiveWorldModel</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="325">
                    <Properties>
                      <string name="Name">Tracker</string>
                      <string name="Source">-- This enables data on volumes, HumanoidRootParts, etc to be handled on an event-basis, instead of being retrieved every interval

-- LOCAL
local players = game:GetService("Players")
local runService = game:GetService("RunService")
local heartbeat = runService.Heartbeat
local Signal = require(script.Parent.Parent.Signal)
local Janitor = require(script.Parent.Parent.Janitor)



-- PUBLIC
local Tracker = {}
Tracker.__index = Tracker
local trackers = {}
Tracker.trackers = trackers
Tracker.itemAdded = Signal.new()
Tracker.itemRemoved = Signal.new()
Tracker.bodyPartsToIgnore = {
	-- We ignore these due to their insignificance (e.g. we ignore the lower and
	-- upper torso because the HumanoidRootPart also covers these areas)
	-- This ultimately reduces the burden on the player region checks
	UpperTorso = true,
	LowerTorso = true,
	Torso = true,
	LeftHand = true,
	RightHand = true,
	LeftFoot = true,
	RightFoot = true,
}



-- FUNCTIONS
function Tracker.getCombinedTotalVolumes()
	local combinedVolume = 0
	for tracker, _ in pairs(trackers) do
		combinedVolume += tracker.totalVolume
	end
	return combinedVolume
end

function Tracker.getCharacterSize(character)
	local head = character and character:FindFirstChild("Head")
	local hrp = character and character:FindFirstChild("HumanoidRootPart")
	if not(hrp and head) then return nil end
	if not head:IsA("BasePart") then
		head = hrp
	end
	local headY = head.Size.Y
	local hrpSize = hrp.Size
	local charSize = (hrpSize * Vector3.new(2, 2, 1)) + Vector3.new(0, headY, 0)
	local charCFrame = hrp.CFrame * CFrame.new(0, headY/2 - hrpSize.Y/2, 0)
	return charSize, charCFrame
end



-- CONSTRUCTOR
function Tracker.new(name)
	local self = {}
	setmetatable(self, Tracker)
	
	self.name = name
	self.totalVolume = 0
	self.parts = {}
	self.partToItem = {}
	self.items = {}
	self.whitelistParams = nil
	self.characters = {}
	self.baseParts = {}
	self.exitDetections = {}
	self.janitor = Janitor.new()

	if name == "player" then
		local function updatePlayerCharacters()
			local characters = {}
			for _, player in pairs(players:GetPlayers()) do
				local character = player.Character
				if character then
					characters[character] = true
				end
			end
			self.characters = characters
		end
		
		local function playerAdded(player)
			local function charAdded(character)
				local humanoid = character:WaitForChild("Humanoid", 3)
				if humanoid then
					updatePlayerCharacters()
					self:update()
					for _, valueInstance in pairs(humanoid:GetChildren()) do
						if valueInstance:IsA("NumberValue") then
							valueInstance.Changed:Connect(function()
								self:update()
							end)
						end
					end
				end
			end
			if player.Character then
				charAdded(player.Character)
			end
			player.CharacterAdded:Connect(charAdded)
			player.CharacterRemoving:Connect(function(removingCharacter)
				self.exitDetections[removingCharacter] = nil
			end)
		end
		
		players.PlayerAdded:Connect(playerAdded)
		for _, player in pairs(players:GetPlayers()) do
			playerAdded(player)
		end
		
		players.PlayerRemoving:Connect(function(player)
			updatePlayerCharacters()
			self:update()
		end)


	elseif name == "item" then
		local function updateItem(itemDetail, newValue)
			if itemDetail.isCharacter then
				self.characters[itemDetail.item] = newValue
			elseif itemDetail.isBasePart then
				self.baseParts[itemDetail.item] = newValue
			end
			self:update()
		end
		Tracker.itemAdded:Connect(function(itemDetail)
			updateItem(itemDetail, true)
		end)
		Tracker.itemRemoved:Connect(function(itemDetail)
			self.exitDetections[itemDetail.item] = nil
			updateItem(itemDetail, nil)
		end)
	end

	trackers[self] = true
	task.defer(self.update, self)
	return self
end



-- METHODS
function Tracker:_preventMultiFrameUpdates(methodName, ...)
	-- This prevents the funtion being called twice within a single frame
	-- If called more than once, the function will initally be delayed again until the next frame, then all others cancelled
	self._preventMultiDetails = self._preventMultiDetails or {}
	local detail = self._preventMultiDetails[methodName]
	if not detail then
		detail = {
			calling = false,
			callsThisFrame = 0,
			updatedThisFrame = false,
		}
		self._preventMultiDetails[methodName] = detail
	end

	detail.callsThisFrame += 1
	if detail.callsThisFrame == 1 then
		local args = table.pack(...)
		task.defer(function()
			local newCallsThisFrame = detail.callsThisFrame
			detail.callsThisFrame = 0
			if newCallsThisFrame > 1 then
				self[methodName](self, unpack(args))
			end
		end)
		return false
	end
	return true
end

function Tracker:update()
	if self:_preventMultiFrameUpdates("update") then
		return
	end
	
	self.totalVolume = 0
	self.parts = {}
	self.partToItem = {}
	self.items = {}
	
	-- This tracks the bodyparts of a character
	for character, _ in pairs(self.characters) do
		local charSize = Tracker.getCharacterSize(character)
		if not charSize then
			continue
		end
		local rSize = charSize
		local charVolume = rSize.X*rSize.Y*rSize.Z
		self.totalVolume += charVolume
		
		local characterJanitor = self.janitor:add(Janitor.new(), "destroy", "trackCharacterParts-"..self.name)
		local function updateTrackerOnParentChanged(instance)
			characterJanitor:add(instance.AncestryChanged:Connect(function()
				if not instance:IsDescendantOf(game) then
					if instance.Parent == nil and characterJanitor ~= nil then
						characterJanitor:destroy()
						characterJanitor = nil
						self:update()
					end
				end
			end), "Disconnect")
		end

		for _, part in pairs(character:GetChildren()) do
			if part:IsA("BasePart") and not Tracker.bodyPartsToIgnore[part.Name] then
				self.partToItem[part] = character
				table.insert(self.parts, part)
				updateTrackerOnParentChanged(part)
			end
		end
		updateTrackerOnParentChanged(character)
		table.insert(self.items, character)
	end

	-- This tracks any additional baseParts
	for additionalPart, _ in pairs(self.baseParts) do
		local rSize = additionalPart.Size
		local partVolume = rSize.X*rSize.Y*rSize.Z
		self.totalVolume += partVolume
		self.partToItem[additionalPart] = additionalPart
		table.insert(self.parts, additionalPart)
		table.insert(self.items, additionalPart)
	end
	
	-- This creates the whitelist so that
	self.whitelistParams = OverlapParams.new()
	self.whitelistParams.FilterType = Enum.RaycastFilterType.Whitelist
	self.whitelistParams.MaxParts = #self.parts
	self.whitelistParams.FilterDescendantsInstances = self.parts
end



return Tracker</string>
                    </Properties>
                  </Item>
                </Item>
                <Item class="ModuleScript" referent="326">
                  <Properties>
                    <string name="Name">ZonePlusReference</string>
                    <string name="Source">-- This module enables you to place Zone wherever you like within the data model while
-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it
-- This is necessary to prevent two ZonePlus applications initiating at runtime which would
-- diminish it's overall efficiency

local replicatedStorage = game:GetService("ReplicatedStorage")
local ZonePlusReference = {}

function ZonePlusReference.addToReplicatedStorage()
    local existingItem = replicatedStorage:FindFirstChild(script.Name)
    if existingItem then
        return false
    end
    local objectValue = Instance.new("ObjectValue")
    objectValue.Name = script.Name
    objectValue.Value = script.Parent
    objectValue.Parent = replicatedStorage
    local locationValue = Instance.new("BoolValue")
    locationValue.Name = (game:GetService("RunService"):IsClient() and "Client") or "Server"
    locationValue.Value = true
    locationValue.Parent = objectValue
    return objectValue
end

function ZonePlusReference.getObject()
    local objectValue = replicatedStorage:FindFirstChild(script.Name)
    if objectValue then
        return objectValue
    end
    return false
end

return ZonePlusReference</string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="327">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Folder" referent="328">
      <Properties>
        <string name="Name">TS</string>
      </Properties>
      <Item class="Folder" referent="329">
        <Properties>
          <string name="Name">classes</string>
        </Properties>
        <Item class="Folder" referent="330">
          <Properties>
            <string name="Name">EnvironmentEffects</string>
          </Properties>
          <Item class="ModuleScript" referent="331">
            <Properties>
              <string name="Name">Hazard</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local HazardTag = "Hazard"
return nil
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="332">
          <Properties>
            <string name="Name">components</string>
          </Properties>
          <Item class="ModuleScript" referent="333">
            <Properties>
              <string name="Name">HazardComponent</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--[[
	* Hazard Component
	 * This component handles the hazard logic for the game, including damage application and visual effects.
	 * It is responsible for managing the state of hazards, applying damage to players, and triggering visual effects.
	 *
	 * @file        HazardComponent.ts
	 * @module      HazardComponent
	 * @layer       Server/Classes/Components
	 * @description Handles hazard logic, including damage application and visual effects.
	 * * ╭───────────────────────────────╮
	 * * │  Soul Steel · Coding Guide    │
	 * * │  Fusion v4 · Strict TS · ECS  │
	 * * ╰───────────────────────────────╯
	 * * @author Trembus
	 * * @license MIT
	 * * @since 0.2.0
	 * * @lastUpdated 2025-06-27 by Trembus – Initial creation
	 * * @dependencies
	 * *  @rbxts/fusion ^0.4.0
	 * *  @rbxts/services ^0.4.0
	 *
	 
]]
local component = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib").component
local testComponent = component("HazardComponent", {
	damage = 0,
	duration = 0,
	visualEffect = nil,
})
return nil
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="334">
          <Properties>
            <string name="Name">npc</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/server/entity/npc/index.ts
	 * @module      NPCIndex
	 * @layer       Server/Entity
	 * @description Barrel export for NPC classes.
	 
]]
for _k, _v in TS.import(script, game:GetService("ServerScriptService"), "TS", "classes", "npc", "NPC") or {} do
	exports[_k] = _v
end
return exports
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="335">
            <Properties>
              <string name="Name">NPC</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        NPC.ts
	 * @module      NPC
	 * @layer       Server/Entity
	 * @description Runtime representation of an NPC spawned from NPCMetaMap.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-07-02 by Codex – Redesigned to use new NPC definitions
	 
]]
local _NPC = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "NPC")
local NPCMetaMap = _NPC.NPCMetaMap
local FIRST_NAMES = _NPC.FIRST_NAMES
local LAST_NAMES = _NPC.LAST_NAMES
local MONIKERS = _NPC.MONIKERS
local _shared = TS.import(script, game:GetService("ReplicatedStorage"), "TS")
local AbilitiesMeta = _shared.AbilitiesMeta
local loadAnimation = _shared.loadAnimation
local NPC
do
	NPC = setmetatable({}, {
		__tostring = function()
			return "NPC"
		end,
	})
	NPC.__index = NPC
	function NPC.new(...)
		local self = setmetatable({}, NPC)
		return self:constructor(...) or self
	end
	function NPC:constructor(key, cFrame)
		if cFrame == nil then
			cFrame = CFrame.new()
		end
		self.key = key
		self.meta = NPCMetaMap[key]
		self.model = self.meta.modelTemplate:Clone()
		self.humanoid = self.model:FindFirstChildOfClass("Humanoid")
		local _object = table.clone(self.meta.baseStats)
		setmetatable(_object, nil)
		self.stats = _object
		self.name = NPC:generateName(key)
		self.model.Name = self.name
		self.model:PivotTo(cFrame)
		self.model.Parent = game.Workspace
		local _exp = self.meta.abilities
		-- ▼ ReadonlyArray.forEach ▼
		local _callback = function(abilityKey)
			local _exp_1 = self.model
			local _result = AbilitiesMeta[abilityKey]
			if _result ~= nil then
				_result = _result.animationKey
			end
			loadAnimation(_exp_1, _result)
		end
		for _k, _v in _exp do
			_callback(_v, _k - 1, _exp)
		end
		-- ▲ ReadonlyArray.forEach ▲
		print(`NPC spawned: {self.name} ({key})`)
	end
	function NPC:Destroy()
		self.model:Destroy()
	end
	function NPC:randomOf(array)
		return array[math.random(0, #array - 1) + 1]
	end
	function NPC:generateName(key)
		local first = self:randomOf(FIRST_NAMES)
		local last = self:randomOf(LAST_NAMES)
		local moniker = self:randomOf(MONIKERS[key])
		return `{first} {last} {moniker}`
	end
end
return {
	NPC = NPC,
}
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="336">
          <Properties>
            <string name="Name">playground</string>
          </Properties>
          <Item class="ModuleScript" referent="337">
            <Properties>
              <string name="Name">AlienBob</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        AlienBob.ts
	 * @module      AlienBob
	 * @layer       Server/Entity
	 * @description Represents the Alien Bob NPC entity.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 
]]
local Workspace = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Workspace
local MUTATION_KEYS = { "ColorChange", "SizeChange", "SpeedBoost", "HealthBoost", "EnergyBoost" }
local AlienBob
do
	AlienBob = setmetatable({}, {
		__tostring = function()
			return "AlienBob"
		end,
	})
	AlienBob.__index = AlienBob
	function AlienBob.new(...)
		local self = setmetatable({}, AlienBob)
		return self:constructor(...) or self
	end
	function AlienBob:constructor()
		print("AlienBob initialized.")
	end
	function AlienBob:Start()
		if self._instance == nil then
			self._instance = AlienBob.new()
			self:_initialize()
		end
		return self._instance
	end
	function AlienBob:_initialize()
		local alienBob = Workspace:FindFirstChild("Alien_Bob")
		if alienBob and alienBob:IsA("Model") then
			print("Alien Bob NPC found in the workspace.")
			self.BobOrganism = alienBob
		else
			warn("Alien Bob NPC not found in the workspace.")
		end
	end
	function AlienBob:MutateBob()
		if self.BobOrganism then
			local randomnumber = math.random(1, 10)
		end
	end
end
return {
	MUTATION_KEYS = MUTATION_KEYS,
	AlienBob = AlienBob,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="338">
            <Properties>
              <string name="Name">AlienOrganism</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        AlienOrganism.ts
	 * @module      AlienOrganism
	 * @layer       Server/Entity
	 * @description Basic alien entity with simple bias-driven actions.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 
]]
local ACTION_KEY = { "Rest", "Hunt", "Explore" }
local AlienOrganism
do
	AlienOrganism = setmetatable({}, {
		__tostring = function()
			return "AlienOrganism"
		end,
	})
	AlienOrganism.__index = AlienOrganism
	function AlienOrganism.new(...)
		local self = setmetatable({}, AlienOrganism)
		return self:constructor(...) or self
	end
	function AlienOrganism:constructor(name, cframe)
		self.AlienModel = Instance.new("Model")
		self.Alive = true
		self.Health = 100
		self.Energy = 100
		self.ActionBias = {
			Rest = 0.5,
			Hunt = 0.3,
			Explore = 0.2,
		}
		self.AlienModel.Name = name
		local primaryPart = Instance.new("Part")
		primaryPart.Name = "AlienPrimaryPart"
		primaryPart.Size = Vector3.new(22, 22, 22)
		primaryPart.Anchored = true
		primaryPart.CanCollide = false
		primaryPart.BrickColor = BrickColor.random()
		primaryPart.Material = Enum.Material.Plastic
		-- Set the primary part of the model
		primaryPart.Parent = self.AlienModel
		self.AlienModel.Parent = game.Workspace
		-- Pivot the model to the specified CFrame
		self.AlienModel:PivotTo(cframe)
		warn(`AlienOrganism created: {self.AlienModel.Name} at: `, self.AlienModel:GetPivot().Position)
	end
end
return {
	AlienOrganism = AlienOrganism,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="339">
            <Properties>
              <string name="Name">Manifestation</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/server/entity/Manifestation.ts
	 * @module      Manifestation
	 * @layer       Server/Entity
	 * @description Handles the manifestation of game objects.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local function CreateManifestationGem(dataGems)
	local gem = Instance.new("Model")
	gem.Name = "ManifestationGem"
	local basePart = Instance.new("Part")
	basePart.Name = "Base"
	basePart.Size = Vector3.new(1, 1, 1)
	basePart.Anchored = true
	basePart.CanCollide = false
	basePart.BrickColor = BrickColor.random()
	basePart.Material = Enum.Material.Plastic
	gem.PrimaryPart = basePart
	return gem
end
return {
	CreateManifestationGem = CreateManifestationGem,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="340">
            <Properties>
              <string name="Name">OrganismFood</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        OrganismFood.ts
	 * @module      OrganismFood
	 * @layer       Server/Entity
	 * @description Spawns a simple collectible OrganismFood model.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 
]]
local OrganismFood
do
	OrganismFood = setmetatable({}, {
		__tostring = function()
			return "OrganismFood"
		end,
	})
	OrganismFood.__index = OrganismFood
	function OrganismFood.new(...)
		local self = setmetatable({}, OrganismFood)
		return self:constructor(...) or self
	end
	function OrganismFood:constructor(model, amount)
		self.model = model
		local _result = model
		if _result ~= nil then
			_result = _result.PrimaryPart
		end
		local _condition = _result
		if not _condition then
			_condition = Instance.new("Part")
		end
		self.part = _condition
		self.amount = amount
		local _result_1 = self.connectionPartTouched
		if _result_1 ~= nil then
			_result_1:Disconnect()
		end
		self.connectionPartTouched = self.part.Touched:Connect(function(hit)
			print(`Resource touched by: {hit.Name}`)
			if hit.Parent and hit.Parent:IsA("Model") then
				print(`Resource touched by: {hit.Parent.Name}`)
				self:UpdateResource(-10)
			end
		end)
		print(`EntityResource created with amount: {self.amount}`)
		self.model.Parent = game.Workspace
	end
	function OrganismFood:SpawnResource(location)
		local amount = math.random(1, 100)
		local model = Instance.new("Model")
		model.Name = "Resource"
		local part = Instance.new("Part")
		part.Name = "ResourcePart"
		part.Size = Vector3.new(5, 5, 5)
		part.Color = Color3.fromRGB(0, 255 * (amount / 100), 0)
		part.Transparency = 0.5
		part.Anchored = true
		part.CanCollide = false
		part.CanTouch = true
		part.Parent = model
		model.PrimaryPart = part
		model:PivotTo(location)
		local resource = OrganismFood.new(model, amount)
		return resource
	end
	function OrganismFood:UpdateResource(amount)
		self.amount += amount
		self.part.Color = Color3.fromRGB(0, 255 * (self.amount / 100), 0)
		if self.amount <= 0 then
			local _result = self.connectionPartTouched
			if _result ~= nil then
				_result:Disconnect()
			end
			self.model:Destroy()
		end
		print(`Resource amount updated: {self.amount}`)
	end
end
return {
	OrganismFood = OrganismFood,
}
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="Script" referent="341">
        <Properties>
          <string name="Name">main</string>
          <token name="RunContext">0</token>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        main.server.ts
	 * @module      ServerMain
	 * @layer       Server
	 * @description Entry point for server-side logic.
	 
]]
-- =============================================== Imports =============================================== 
local _services = TS.import(script, game:GetService("ServerScriptService"), "TS", "services")
local ManifestationForgeService = _services.ManifestationForgeService
local DataProfileController = _services.DataProfileController
local BattleRoomService = _services.BattleRoomService
local ResourcesService = _services.ResourcesService
local SettingsService = _services.SettingsService
-- =============================================== Initialization ========================================= 
DataProfileController:Start()
ManifestationForgeService:Start()
BattleRoomService:Start()
ResourcesService:Start()
SettingsService:Start()
--OrganismFood.SpawnResource(new CFrame(0, 10, 0));
-- task.spawn(() => {
-- 	while (Players.GetPlayers().size() >= 0) {
-- 		Players.GetPlayers().forEach((player) => {
-- 			ResourcesService.ModifyResource(player, "Health", -1);
-- 		});
-- 		task.wait(1);
-- 		print("HB: Tick");
-- 	}
-- 	print("Server is now running.");
-- });
print("Server main script initialized successfully.")
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="342">
        <Properties>
          <string name="Name">network</string>
        </Properties>
        <Item class="ModuleScript" referent="343">
          <Properties>
            <string name="Name">ServerDispatch</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--[[
	*
	 * @file        src/client/network/ServerDispatch.ts
	 * @module      ServerDispatch
	 * @layer       Server/Network
	 * @description Handles server-side network dispatching for game events.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
-- =============================================== Imports =============================================== 
local ServerDispatch = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "network", "Definitions").ServerDispatch
-- ================================================ Events =============================================== 
local ResourceUpdated = ServerDispatch.Server:Get("ResourceUpdated")
-- ================================================ Dispatches =============================================== 
local UpdateResource = function(player, resourceKey, current, max)
	--print(`Updating resource for player ${player.Name}: ${resourceKey} - Current: ${current}, Max: ${max}`);
	ResourceUpdated:SendToPlayer(player, resourceKey, current, max)
end
return {
	UpdateResource = UpdateResource,
}
]]></string>
          </Properties>
        </Item>
        <Item class="Script" referent="344">
          <Properties>
            <string name="Name">listener</string>
            <token name="RunContext">0</token>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/server/network/network.server.ts
	 * @module      NetworkServer
	 * @layer       Server/Network
	 * @description Handles network communication for the server.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
-- =============================================== Imports =============================================== 
local _network = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "network")
local ClientDispatch = _network.ClientDispatch
local Network = _network.Network
local TestNetwork = _network.TestNetwork
-- Custom Services 
local _services = TS.import(script, game:GetService("ServerScriptService"), "TS", "services")
local BattleRoomService = _services.BattleRoomService
local SettingsService = _services.SettingsService
local NPCService = _services.NPCService
local AbilityService = _services.AbilityService
local DataProfileController = _services.DataProfileController
local AttributesService = _services.AttributesService
-- Factories and Types 
-- Attibutes -----------------------------------------------------
Network.Server:OnEvent("IncreaseAttribute", function(player, attributeKey, amount)
	AttributesService:Increase(player, attributeKey, amount)
end)
-- Resources -----------------------------------------------------
-- Abilities -----------------------------------------------------
Network.Server:OnEvent("ActivateAbility", function(player, abilityKey)
	AbilityService:Activate(player, abilityKey)
end)
-- Network.Server.Get("GetPlayerAbilities").SetCallback((player) => {
-- 	return AbilityService.GetAbilities(player);
-- });
-- MATCHMAKING -----------------------------------------------------
Network.Server:Get("CreateRoom"):SetCallback(function(player)
	return BattleRoomService:CreateRoom(player)
end)
Network.Server:OnEvent("JoinRoom", function(player, roomId)
	BattleRoomService:JoinRoom(player, roomId)
end)
-- Gems -----------------------------------------------------
Network.Server:OnEvent("SetActiveGem", function(player, roomId, gemId)
	BattleRoomService:SetActiveGem(player, roomId, gemId)
end)
-- SETTINGS -----------------------------------------------------
Network.Server:Get("GetPlayerSettings"):SetCallback(function(player)
	return SettingsService:GetSettings(player)
end)
Network.Server:OnEvent("UpdatePlayerSetting", function(player, key, value)
	SettingsService:SetSettings(player, key, value)
end)
-- Admin Actions -----------------------------------------------------
TestNetwork.Server:OnEvent("SPAWN_NPC", function(player, npcKey)
	local playerCharacter = player.Character or (player.CharacterAdded:Wait())
	if playerCharacter == nil then
		warn(`Player {player.Name} has no character to spawn NPC into.`)
		return nil
	end
	local playerCFrame = playerCharacter:GetPivot()
	local _cFrame = CFrame.new(0, 0, -5)
	local spawnCFrame = playerCFrame * _cFrame
	NPCService:Spawn(npcKey, spawnCFrame)
end)
ClientDispatch.Server:Get("GetData"):SetCallback(function(player, dataKey)
	local playerProfile = DataProfileController:GetProfile(player)
	if playerProfile == nil then
		warn(`Profile not found for {player.Name}`)
		return nil
	end
	if playerProfile.Data[dataKey] == nil then
		warn(`Profile data not found for {player.Name}: {dataKey}`)
		return nil
	end
	return playerProfile.Data[dataKey]
end)
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="345">
        <Properties>
          <string name="Name">services</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/server/services/index.ts
	 * @module      ServerServicesIndex
	 * @layer       Server/Services
	 * @description Barrel index file for server services, exporting all components.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
for _k, _v in TS.import(script, game:GetService("ServerScriptService"), "TS", "services", "DataService") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ServerScriptService"), "TS", "services", "ManifestationForgeService") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ServerScriptService"), "TS", "services", "BattleRoomService") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ServerScriptService"), "TS", "services", "SettingsService") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ServerScriptService"), "TS", "services", "NPCService") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ServerScriptService"), "TS", "services", "AbilityService") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ServerScriptService"), "TS", "services", "StatusEffectService") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ServerScriptService"), "TS", "services", "ResourcesService") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ServerScriptService"), "TS", "services", "AttributesService") or {} do
	exports[_k] = _v
end
return exports
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="346">
          <Properties>
            <string name="Name">AbilityService</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        AbilityService.ts
	 * @module      AbilityService
	 * @layer       Server/Services
	 * @classType   Singleton
	 * @description Manages player abilities and activation cooldowns.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-07-03 by Codex – Initial creation
	 
]]
-- =============================================== Imports =============================================== 
local _shared = TS.import(script, game:GetService("ReplicatedStorage"), "TS")
local AbilitiesMeta = _shared.AbilitiesMeta
local loadAnimation = _shared.loadAnimation
local playAnimation = _shared.playAnimation
local DataProfileController = TS.import(script, game:GetService("ServerScriptService"), "TS", "services", "DataService").DataProfileController
local CooldownTimer = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "classes", "CooldownTimer").CooldownTimer
-- =============================================== Service =============================================== 
local AbilityService
do
	AbilityService = setmetatable({}, {
		__tostring = function()
			return "AbilityService"
		end,
	})
	AbilityService.__index = AbilityService
	function AbilityService.new(...)
		local self = setmetatable({}, AbilityService)
		return self:constructor(...) or self
	end
	function AbilityService:constructor()
		self._cooldowns = {}
		print("AbilityService initialized.")
	end
	function AbilityService:Start()
		if not self._instance then
			self._instance = AbilityService.new()
		end
		return self._instance
	end
	function AbilityService:GetAbilities(player)
		local profile = DataProfileController:GetProfile(player)
		local _result = profile
		if _result ~= nil then
			_result = _result.Data.Abilities
		end
		return _result
	end
	function AbilityService:Activate(player, abilityKey)
		local svc = self:Start()
		local abilities = self:GetAbilities(player)
		local _condition = not abilities
		if not _condition then
			local _abilityKey = abilityKey
			_condition = not (table.find(abilities, _abilityKey) ~= nil)
		end
		if _condition then
			warn(`Player {player.Name} does not have ability {abilityKey}.`)
			return nil
		end
		local __cooldowns = svc._cooldowns
		local _player = player
		local playerCooldowns = __cooldowns[_player]
		if not playerCooldowns then
			playerCooldowns = {}
			local __cooldowns_1 = svc._cooldowns
			local _player_1 = player
			local _playerCooldowns = playerCooldowns
			__cooldowns_1[_player_1] = _playerCooldowns
		end
		local _playerCooldowns = playerCooldowns
		local _abilityKey = abilityKey
		local existing = _playerCooldowns[_abilityKey]
		if existing and not existing:isReady() then
			warn(`Ability {abilityKey} on cooldown for player {player.Name}.`)
			return nil
		end
		local _result = AbilitiesMeta[abilityKey]
		if _result ~= nil then
			_result = _result.cooldown
		end
		local _condition_1 = _result
		if _condition_1 == nil then
			_condition_1 = 0
		end
		local cooldown = _condition_1
		local timer = CooldownTimer.new(cooldown)
		local _playerCooldowns_1 = playerCooldowns
		local _abilityKey_1 = abilityKey
		_playerCooldowns_1[_abilityKey_1] = timer
		timer:start()
		local character = player.Character or (player.CharacterAdded:Wait())
		loadAnimation(character, AbilitiesMeta[abilityKey].animationKey)
		playAnimation(character, AbilitiesMeta[abilityKey].animationKey)
	end
end
-- Auto-start on import
AbilityService:Start()
return {
	AbilityService = AbilityService,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="347">
          <Properties>
            <string name="Name">AttributesService</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        AttributesService.ts
	 * @module      AttributesService
	 * @layer       Server/Services
	 * @classType   Singleton
	 * @description Validates and mutates player attribute values.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-07-03 by Codex – Initial creation
	 
]]
-- =============================================== Imports ===================== 
local clampAttr = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "ProfileDefinitions", "Attributes").clampAttr
local DataProfileController = TS.import(script, game:GetService("ServerScriptService"), "TS", "services", "DataService").DataProfileController
local ResourcesService = TS.import(script, game:GetService("ServerScriptService"), "TS", "services", "ResourcesService").ResourcesService
-- =============================================== Service ===================== 
local AttributesService
do
	AttributesService = setmetatable({}, {
		__tostring = function()
			return "AttributesService"
		end,
	})
	AttributesService.__index = AttributesService
	function AttributesService.new(...)
		local self = setmetatable({}, AttributesService)
		return self:constructor(...) or self
	end
	function AttributesService:constructor()
		print("AttributesService initialized.")
	end
	function AttributesService:Start()
		local _value = self._instance
		if not (_value ~= 0 and _value == _value and _value ~= "" and _value) then
			self._instance = AttributesService.new()
		end
		return self._instance
	end
	function AttributesService:Increase(player, key, amount)
		local profile = DataProfileController:GetProfile(player)
		if not profile then
			return nil
		end
		local attrs = profile.Data.Attributes
		local newValue = clampAttr(key, attrs[key] + amount)
		local delta = newValue - attrs[key]
		if delta == 0 then
			return nil
		end
		attrs[key] = newValue
		attrs.SpentPoints += delta
		attrs.AvailablePoints = math.max(attrs.AvailablePoints - delta, 0)
		ResourcesService:Recalculate(player)
	end
	function AttributesService:Get(player)
		local _result = DataProfileController:GetProfile(player)
		if _result ~= nil then
			_result = _result.Data.Attributes
		end
		return _result
	end
end
-- Auto-start on import
AttributesService:Start()
return {
	AttributesService = AttributesService,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="348">
          <Properties>
            <string name="Name">BattleRoomService</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        BattleRoomService.ts
	 * @module      BattleRoomService
	 * @layer       Server/Services
	 * @classType   Singleton
	 * @description Handles creation of battle rooms and teleports players to the battle place.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 
]]
-- =============================================== Imports ================================== 
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local HttpService = _services.HttpService
local TeleportService = _services.TeleportService
local Network = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "network").Network
-- =============================================== Constants ================================= 
local COUNTDOWN_TIME = 10
local BATTLE_PLACE_ID = 78520415943353
-- =============================================== Types ===================================== 
-- =============================================== Service =================================== 
local BattleRoomService
do
	BattleRoomService = setmetatable({}, {
		__tostring = function()
			return "BattleRoomService"
		end,
	})
	BattleRoomService.__index = BattleRoomService
	function BattleRoomService.new(...)
		local self = setmetatable({}, BattleRoomService)
		return self:constructor(...) or self
	end
	function BattleRoomService:constructor()
		print("BattleRoomService initialized.")
	end
	function BattleRoomService:Start()
		if self._instance == nil then
			self._instance = BattleRoomService.new()
		end
		return self._instance
	end
	function BattleRoomService:CreateRoom(owner)
		print(`Creating battle room for player: {owner.Name}`)
		self:Start()
		local id = HttpService:GenerateGUID(false)
		local room = {
			id = id,
			players = {},
		}
		self._rooms[id] = room
		self:JoinRoom(owner, id)
		return id
	end
	function BattleRoomService:JoinRoom(player, roomId)
		print(`Player {player.Name} joining room: {roomId}`)
		local __rooms = self._rooms
		local _roomId = roomId
		local room = __rooms[_roomId]
		if not room then
			warn(`BattleRoom {roomId} not found`)
			return nil
		end
		local _players = room.players
		local _player = player
		if not (_players[_player] ~= nil) then
			local _players_1 = room.players
			local _player_1 = player
			_players_1[_player_1] = ""
		end
		if not room.countdownTask then
			self:_startCountdown(room)
		end
	end
	function BattleRoomService:SetActiveGem(player, roomId, gemId)
		print(`Setting active gem for player {player.Name} in room {roomId} to {gemId}`)
		local __rooms = self._rooms
		local _roomId = roomId
		local room = __rooms[_roomId]
		if not room then
			return nil
		end
		local _players = room.players
		local _player = player
		if _players[_player] ~= nil then
			local _players_1 = room.players
			local _player_1 = player
			local _gemId = gemId
			_players_1[_player_1] = _gemId
		end
	end
	function BattleRoomService:_startCountdown(room)
		print(`Starting countdown for room: {room.id}`)
		room.countdownTask = task.spawn(function()
			for remaining = COUNTDOWN_TIME, 1, -1 do
				local players = self:_collectPlayers(room)
				Network.Server:Get("RoomCountdown"):SendToPlayers(players, room.id, remaining)
				print(`Countdown for room {room.id}: {remaining} seconds remaining`)
				task.wait(1)
			end
			self:_launchRoom(room)
		end)
	end
	function BattleRoomService:_collectPlayers(room)
		local result = {}
		local _exp = room.players
		-- ▼ ReadonlyMap.forEach ▼
		local _callback = function(_, p)
			local _p = p
			table.insert(result, _p)
			return #result
		end
		for _k, _v in _exp do
			_callback(_v, _k, _exp)
		end
		-- ▲ ReadonlyMap.forEach ▲
		if #result == 0 then
			warn(`No players in room {room.id}`)
			return result
		end
		local _exp_1 = room.id
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#result)
		local _callback_1 = function(p)
			return p.Name
		end
		for _k, _v in result do
			_newValue[_k] = _callback_1(_v, _k - 1, result)
		end
		-- ▲ ReadonlyArray.map ▲
		print(`Collecting players for room {_exp_1}: {table.concat(_newValue, ", ")}`)
		return result
	end
	function BattleRoomService:_launchRoom(room)
		local players = self:_collectPlayers(room)
		local teleportsResult = TeleportService:TeleportAsync(BATTLE_PLACE_ID, players)
		print(`Launching battle room {room.id} with code: {teleportsResult}`)
		local __rooms = self._rooms
		local _id = room.id
		__rooms[_id] = nil
		print(`Battle room {room.id} launched and deleted.`)
	end
	BattleRoomService._rooms = {}
end
return {
	BattleRoomService = BattleRoomService,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="349">
          <Properties>
            <string name="Name">DataService</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        DataService.ts
	 * @module      DataService
	 * @layer       Server/Services
	 * @description Wrapper around ProfileService for player data.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 
]]
-- =============================================== Imports ====================================================== 
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local ProfileService = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "profileservice", "src")
-- DTO
local DefaultAttributes = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions").DefaultAttributes
local CodeSettings = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "constants", "CodeSettings").CodeSettings
-- ========================================== Profile Store Setup =============================================== 
-- Datastore Name
local DATASTORE_NAME = "A_SoulSteelPlayerProfile"
local DefaultProfileData = {
	Abilities = { "earthquake", "fireball", "ice_shard" },
	Attributes = DefaultAttributes,
}
-- Data Profile Controller 
local DataProfileController
do
	DataProfileController = setmetatable({}, {
		__tostring = function()
			return "DataProfileController"
		end,
	})
	DataProfileController.__index = DataProfileController
	function DataProfileController.new(...)
		local self = setmetatable({}, DataProfileController)
		return self:constructor(...) or self
	end
	function DataProfileController:constructor()
		print("DataProfileController Initialized.")
	end
	function DataProfileController:Start()
		if self._instance == nil then
			self._instance = DataProfileController.new()
			self:_initializeConnections()
		end
		return self._instance
	end
	function DataProfileController:_initializeConnections()
		-- Player Added 
		local _result = self._playerAddedConnection
		if _result ~= nil then
			_result:Disconnect()
		end
		self._playerAddedConnection = Players.PlayerAdded:Connect(function(player)
			self:_onPlayerJoining(player)
		end)
		-- Player Removing 
		local _result_1 = self._playerRemovingConnection
		if _result_1 ~= nil then
			_result_1:Disconnect()
		end
		self._playerRemovingConnection = Players.PlayerRemoving:Connect(function(player)
			self:_onPlayerLeaving(player)
		end)
	end
	DataProfileController._onPlayerJoining = TS.async(function(self, player)
		-- Create Player Key 
		local playerKey = player.Name .. "_" .. tostring(player.UserId)
		local _exitType, _returns = TS.try(function()
			-- Attempt to load the profile for the player
			local profile = TS.await(self._profileStore:LoadProfileAsync(playerKey))
			-- Warn if the profile is nil
			if profile == nil then
				warn(`ProfileService: (1) - Failed to load profile for player: {player.Name}`)
				return TS.TRY_RETURN, {}
			end
			-- Store the profile in the map
			local __profileMap = self._profileMap
			local _player = player
			__profileMap[_player] = profile
			-- Reconcile the profile to ensure it has the correct data structure
			profile:Reconcile()
			-- Listen for logout and release events
			profile:ListenToRelease(function()
				print(`[{player.Name}] - Profile released.`)
				local __profileMap_1 = self._profileMap
				local _player_1 = player
				__profileMap_1[_player_1] = nil
			end)
		end, function(err)
			warn(`ProfileService: (2) - Error loading profile for player {player.Name}: {err}`)
		end)
		if _exitType then
			return unpack(_returns)
		end
		if CodeSettings.DEBUG_DATASERVICE then
			local _exp = `DataProfileController._onPlayerJoining({player.Name}) called.`
			local __profileMap = self._profileMap
			local _player = player
			print(_exp, (__profileMap[_player]))
		end
	end)
	function DataProfileController:_onPlayerLeaving(player)
		--print(`Player leaving: ${player.Name}`);
		local __profileMap = self._profileMap
		local _player = player
		__profileMap[_player] = nil
	end
	function DataProfileController:GetProfile(player)
		if CodeSettings.DEBUG_DATASERVICE then
			local _exp = `DataProfileController.GetProfile({player.Name}) called.`
			local __profileMap = self._profileMap
			local _player = player
			print(_exp, (__profileMap[_player]))
		end
		local __profileMap = self._profileMap
		local _player = player
		return __profileMap[_player]
	end
	DataProfileController._profileStore = ProfileService.GetProfileStore(DATASTORE_NAME, DefaultProfileData)
	DataProfileController._profileMap = {}
end
return {
	DataProfileController = DataProfileController,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="350">
          <Properties>
            <string name="Name">ManifestationForgeService</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        ManifestationForgeService.ts
	 * @module      ManifestationForgeService
	 * @layer       Server/Services
	 * @classType   Singleton
	 * @description Service for handling the manifestation forge logic. Validates uuid, builds DTO, persists to profile
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 
]]
-- =============================================== Imports ====================================================== 
-- Data Profile Controller 
local ManifestationForgeService
do
	ManifestationForgeService = setmetatable({}, {
		__tostring = function()
			return "ManifestationForgeService"
		end,
	})
	ManifestationForgeService.__index = ManifestationForgeService
	function ManifestationForgeService.new(...)
		local self = setmetatable({}, ManifestationForgeService)
		return self:constructor(...) or self
	end
	function ManifestationForgeService:constructor()
		print("ManifestationForgeService initialized.")
	end
	function ManifestationForgeService:Start()
		if self._instance == nil then
			self._instance = ManifestationForgeService.new()
		end
		return self._instance
	end
	function ManifestationForgeService:ForgeManifestation(player, formId, abilityId, bonusId)
		-- Validate the UUIDs and other parameters here
		print(`Forging manifestation for player {player.Name} with formId: {formId}, abilityId: {abilityId}, bonusId: {bonusId}`)
		return true
	end
end
return {
	ManifestationForgeService = ManifestationForgeService,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="351">
          <Properties>
            <string name="Name">NPCService</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        NPCService.ts
	 * @module      NPCService
	 * @layer       Server/Services
	 * @classType   Singleton
	 * @description Spawns and tracks NPC instances using NPC definitions.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-07-02 by Codex – Initial creation
	 
]]
local NPC = TS.import(script, game:GetService("ServerScriptService"), "TS", "classes", "npc").NPC
local NPCService
do
	NPCService = setmetatable({}, {
		__tostring = function()
			return "NPCService"
		end,
	})
	NPCService.__index = NPCService
	function NPCService.new(...)
		local self = setmetatable({}, NPCService)
		return self:constructor(...) or self
	end
	function NPCService:constructor()
		self._npcs = {}
		print("NPCService initialized.")
	end
	function NPCService:Start()
		if not self._instance then
			self._instance = NPCService.new()
		end
		return self._instance
	end
	function NPCService:Spawn(key, cFrame)
		local svc = self:Start()
		local npc = NPC.new(key, cFrame)
		svc._npcs[npc] = true
		return npc
	end
	function NPCService:Remove(npc)
		local svc = self:Start()
		local __npcs = svc._npcs
		local _npc = npc
		if __npcs[_npc] ~= nil then
			local __npcs_1 = svc._npcs
			local _npc_1 = npc
			__npcs_1[_npc_1] = nil
			npc:Destroy()
		end
	end
end
return {
	NPCService = NPCService,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="352">
          <Properties>
            <string name="Name">ResourcesService</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        ResourcesService.ts
	 * @module      ResourcesService
	 * @layer       Server/Services
	 * @classType   Singleton
	 * @description Tracks player resources like Health, Mana and Stamina.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-07-03 by Codex – Initial creation
	 
]]
-- =============================================== Imports ===================== 
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local Players = _services.Players
local RunService = _services.RunService
local _Resources = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "Resources")
local RESOURCE_KEYS = _Resources.RESOURCE_KEYS
local DEFAULT_RESOURCES = _Resources.DEFAULT_RESOURCES
local DefaultAttributes = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "ProfileDefinitions", "Attributes").DefaultAttributes
local DataProfileController = TS.import(script, game:GetService("ServerScriptService"), "TS", "services", "DataService").DataProfileController
local ResourceFormula = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "calculations", "ResourceCalculator").ResourceFormula
local ServerDispatch = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "network", "Definitions").ServerDispatch
-- =============================================== Service ===================== 
local ResourcesService
do
	ResourcesService = setmetatable({}, {
		__tostring = function()
			return "ResourcesService"
		end,
	})
	ResourcesService.__index = ResourcesService
	function ResourcesService.new(...)
		local self = setmetatable({}, ResourcesService)
		return self:constructor(...) or self
	end
	function ResourcesService:constructor()
		self._map = {}
		print("ResourcesService initialized.")
		self:_setupConnections()
	end
	function ResourcesService:Start()
		if not self._instance then
			self._instance = ResourcesService.new()
		end
		return self._instance
	end
	function ResourcesService:GetResources(player)
		local __map = self:Start()._map
		local _player = player
		return __map[_player]
	end
	function ResourcesService:ModifyResource(player, key, delta)
		local svc = self:Start()
		local __map = svc._map
		local _player = player
		local resources = __map[_player]
		if not resources then
			return nil
		end
		local data = resources[key]
		if not data then
			return nil
		end
		local newCurrent = math.clamp(data.current + delta, 0, data.max)
		if newCurrent == data.current then
			return nil
		end
		data.current = newCurrent
		ServerDispatch.Server:Get("ResourceUpdated"):SendToPlayer(player, key, data.current, data.max)
	end
	function ResourcesService:Recalculate(player)
		local svc = self:Start()
		local profile = DataProfileController:GetProfile(player)
		local _result = profile
		if _result ~= nil then
			_result = _result.Data.Attributes
		end
		local _condition = _result
		if _condition == nil then
			_condition = DefaultAttributes
		end
		local attrs = _condition
		local _result_1 = profile
		if _result_1 ~= nil then
			_result_1 = _result_1.Data
			if _result_1 ~= nil then
				_result_1 = _result_1.Level
			end
		end
		local _condition_1 = _result_1
		if _condition_1 == nil then
			_condition_1 = 1
		end
		local level = _condition_1
		local __map = svc._map
		local _player = player
		local resources = __map[_player]
		if not resources then
			local _object = table.clone(DEFAULT_RESOURCES)
			setmetatable(_object, nil)
			resources = _object
			local __map_1 = svc._map
			local _player_1 = player
			local _resources = resources
			__map_1[_player_1] = _resources
		end
		-- ▼ ReadonlyArray.forEach ▼
		local _callback = function(key)
			local max = ResourceFormula[key](attrs, level)
			local data = resources[key]
			local changed = data.max ~= max
			data.max = max
			if data.current > max then
				data.current = max
			end
			if changed then
				ServerDispatch.Server:Get("ResourceUpdated"):SendToPlayer(player, key, data.current, data.max)
			end
		end
		for _k, _v in RESOURCE_KEYS do
			_callback(_v, _k - 1, RESOURCE_KEYS)
		end
		-- ▲ ReadonlyArray.forEach ▲
	end
	function ResourcesService:_setupConnections()
		Players.PlayerAdded:Connect(function(p)
			return self:_onJoin(p)
		end)
		Players.PlayerRemoving:Connect(function(p)
			return self:_onLeave(p)
		end)
		local _exp = Players:GetPlayers()
		-- ▼ ReadonlyArray.forEach ▼
		local _callback = function(p)
			return self:_onJoin(p)
		end
		for _k, _v in _exp do
			_callback(_v, _k - 1, _exp)
		end
		-- ▲ ReadonlyArray.forEach ▲
		-- Heartbeat Connection 
		local _result = ResourcesService.heartbeat
		if _result ~= nil then
			_result:Disconnect()
		end
		local lastHeartbeat = tick()
		ResourcesService.heartbeat = RunService.Heartbeat:Connect(function()
			if tick() - lastHeartbeat < 1 then
				return nil
			end
			lastHeartbeat = tick()
			-- Periodically recalculate resources for all players
			local _exp_1 = Players:GetPlayers()
			-- ▼ ReadonlyArray.forEach ▼
			local _callback_1 = function(player)
				local __map = self._map
				local _player = player
				local resources = __map[_player]
				if not resources then
					return nil
				end
				-- Regenerate resources over time
				-- ▼ ReadonlyArray.forEach ▼
				local _callback_2 = function(key)
					local data = resources[key]
					if data.current < data.max then
						data.current = math.min(data.current + 1, data.max)
						ServerDispatch.Server:Get("ResourceUpdated"):SendToPlayer(player, key, data.current, data.max)
					end
				end
				for _k, _v in RESOURCE_KEYS do
					_callback_2(_v, _k - 1, RESOURCE_KEYS)
				end
				-- ▲ ReadonlyArray.forEach ▲
			end
			for _k, _v in _exp_1 do
				_callback_1(_v, _k - 1, _exp_1)
			end
			-- ▲ ReadonlyArray.forEach ▲
		end)
		print("ResourcesService heartbeat started.")
	end
	function ResourcesService:_onJoin(player)
		task.defer(function()
			ResourcesService:Recalculate(player)
		end)
	end
	function ResourcesService:_onLeave(player)
		local __map = self._map
		local _player = player
		__map[_player] = nil
	end
end
-- Auto-start on import
ResourcesService:Start()
return {
	ResourcesService = ResourcesService,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="353">
          <Properties>
            <string name="Name">SettingsService</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        SettingsService.ts
	 * @module      SettingsService
	 * @layer       Server/Services
	 * @classType   Singleton
	 * @description Maintains per-player settings values.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 
]]
-- -------------- Imports ----------------------------------------------------- //
local DefaultSettings = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "ProfileDefinitions", "Settings").DefaultSettings
-- -------------- Service ----------------------------------------------------- //
local SettingsService
do
	SettingsService = setmetatable({}, {
		__tostring = function()
			return "SettingsService"
		end,
	})
	SettingsService.__index = SettingsService
	function SettingsService.new(...)
		local self = setmetatable({}, SettingsService)
		return self:constructor(...) or self
	end
	function SettingsService:constructor()
		print("SettingsService initialized.")
	end
	function SettingsService:Start()
		if self._instance == nil then
			self._instance = SettingsService.new()
		end
		return self._instance
	end
	function SettingsService:GetSettings(player)
		local __settings = self._settings
		local _player = player
		local existing = __settings[_player]
		if existing then
			return existing
		end
		local _object = table.clone(DefaultSettings)
		setmetatable(_object, nil)
		local defaults = _object
		local __settings_1 = self._settings
		local _player_1 = player
		__settings_1[_player_1] = defaults
		return defaults
	end
	function SettingsService:SetSettings(player, key, value)
		local settings = self:GetSettings(player)
		settings[key] = value
	end
	SettingsService._settings = {}
end
-- Start service on import
SettingsService:Start()
return {
	SettingsService = SettingsService,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="354">
          <Properties>
            <string name="Name">StatusEffectService</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        StatusEffectService.ts
	 * @module      StatusEffectService
	 * @layer       Server/Services
	 * @classType   Singleton
	 * @description Applies and tracks status effects on players.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-07-03 by Codex – Initial creation
	 
]]
-- =============================================== Imports =============================================== 
local StatusEffectMeta = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "StatusEffect").StatusEffectMeta
-- =============================================== Service =============================================== 
local StatusEffectService
do
	StatusEffectService = setmetatable({}, {
		__tostring = function()
			return "StatusEffectService"
		end,
	})
	StatusEffectService.__index = StatusEffectService
	function StatusEffectService.new(...)
		local self = setmetatable({}, StatusEffectService)
		return self:constructor(...) or self
	end
	function StatusEffectService:constructor()
		self._effects = {}
		print("StatusEffectService initialized.")
	end
	function StatusEffectService:Start()
		if not self._instance then
			self._instance = StatusEffectService.new()
		end
		return self._instance
	end
	function StatusEffectService:AddEffect(player, effectKey)
		local meta = StatusEffectMeta[effectKey]
		local svc = self:Start()
		local __effects = svc._effects
		local _player = player
		local map = __effects[_player]
		if not map then
			map = {}
			local __effects_1 = svc._effects
			local _player_1 = player
			local _map = map
			__effects_1[_player_1] = _map
		end
		local _map = map
		local _effectKey = effectKey
		if _map[_effectKey] ~= nil then
			return nil
		end
		local runner = task.spawn(function()
			while true do
				local _map_1 = map
				local _effectKey_1 = effectKey
				if not (_map_1[_effectKey_1] ~= nil) then
					break
				end
				print(`Applying {effectKey} to {player.Name}: {meta.amount}`)
				task.wait(meta.tickRate)
			end
		end)
		local _map_1 = map
		local _effectKey_1 = effectKey
		_map_1[_effectKey_1] = runner
	end
	function StatusEffectService:RemoveEffect(player, effectKey)
		local svc = self:Start()
		local __effects = svc._effects
		local _player = player
		local map = __effects[_player]
		if not map then
			return nil
		end
		local _effectKey = effectKey
		local th = map[_effectKey]
		if th then
			task.cancel(th)
		end
		local _effectKey_1 = effectKey
		map[_effectKey_1] = nil
	end
	function StatusEffectService:ClearEffects(player)
		local svc = self:Start()
		local __effects = svc._effects
		local _player = player
		local map = __effects[_player]
		if not map then
			return nil
		end
		-- ▼ ReadonlyMap.forEach ▼
		local _callback = function(th)
			return task.cancel(th)
		end
		for _k, _v in map do
			_callback(_v, _k, map)
		end
		-- ▲ ReadonlyMap.forEach ▲
		local __effects_1 = svc._effects
		local _player_1 = player
		__effects_1[_player_1] = nil
	end
end
-- Auto-start on import
StatusEffectService:Start()
return {
	StatusEffectService = StatusEffectService,
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="355">
        <Properties>
          <string name="Name">zones</string>
        </Properties>
        <Item class="ModuleScript" referent="356">
          <Properties>
            <string name="Name">LobbyZone</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Zone = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "zone-plus", "src").Zone
local Workspace = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Workspace
local BattleRoomService = TS.import(script, game:GetService("ServerScriptService"), "TS", "services").BattleRoomService
local AlienOrganism = TS.import(script, game:GetService("ServerScriptService"), "TS", "classes", "playground", "AlienOrganism").AlienOrganism
--[[
	*
	 * @file        src/server/zones/LobbyZone.ts
	 * @module      LobbyZone
	 * @layer       Server
	 * @description Zone for the lobby area of the game.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/zone-plus ^1.0.0
	 
]]
local LobbyZone
do
	LobbyZone = setmetatable({}, {
		__tostring = function()
			return "LobbyZone"
		end,
	})
	LobbyZone.__index = LobbyZone
	function LobbyZone.new(...)
		local self = setmetatable({}, LobbyZone)
		return self:constructor(...) or self
	end
	function LobbyZone:constructor()
	end
	function LobbyZone:Start()
		if LobbyZone.instance == nil then
			LobbyZone.instance = LobbyZone.new()
			LobbyZone.ZoneContainer = Workspace:WaitForChild("LobbyZoneContainer")
			LobbyZone.ZoneInstance = Zone.new(LobbyZone.ZoneContainer)
			LobbyZone:initializeConnections()
			warn(`LobbyZone started: {LobbyZone.Name} - {LobbyZone.Description}`)
		end
		return LobbyZone.instance
	end
	function LobbyZone:initializeConnections()
		-- Connect player joining events
		self.PlayerJoinedConnection = LobbyZone.ZoneInstance.playerEntered:Connect(function(player)
			print(`Player {player.Name} has entered the Lobby Zone.`)
			LobbyZone:onPlayerJoined(player)
		end)
		-- Connect player exiting events
		self.PlayerLeftConnection = LobbyZone.ZoneInstance.playerExited:Connect(function(player)
			print(`Player {player.Name} has exited the Lobby Zone.`)
			LobbyZone:onPlayerExited(player)
		end)
	end
	function LobbyZone:onPlayerJoined(player)
		local _playersInZone = LobbyZone.PlayersInZone
		local _userId = player.UserId
		if not (_playersInZone[_userId] ~= nil) then
			local _playersInZone_1 = LobbyZone.PlayersInZone
			local _userId_1 = player.UserId
			local _player = player
			_playersInZone_1[_userId_1] = _player
			BattleRoomService:CreateRoom(player)
			local testAlien = AlienOrganism.new(`TestAlien-{player.Name}`, CFrame.new(0, 5, 0))
			print(`Player {player.Name} has joined the Lobby Zone.`)
		end
	end
	function LobbyZone:onPlayerExited(player)
		local _playersInZone = LobbyZone.PlayersInZone
		local _userId = player.UserId
		if _playersInZone[_userId] ~= nil then
			local _playersInZone_1 = LobbyZone.PlayersInZone
			local _userId_1 = player.UserId
			_playersInZone_1[_userId_1] = nil
			print(`Player {player.Name} has left the Lobby Zone.`)
		end
	end
	LobbyZone.Name = "LobbyZone"
	LobbyZone.Description = "A zone for the lobby area where players can gather before starting the game."
	LobbyZone.PlayersInZone = {}
end
return {
	LobbyZone = LobbyZone,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="357">
          <Properties>
            <string name="Name">ZoneBase</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Zone = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "zone-plus", "src").Zone
local CollectionService = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").CollectionService
local currentHazardZones = CollectionService:GetTagged("ResourceHazard")
local ZoneBase = function(container, onPlayerEntered, onPlayerExited)
	local zoneInstance = Zone.new(container)
	zoneInstance.playerEntered:Connect(onPlayerEntered)
	zoneInstance.playerExited:Connect(onPlayerExited)
	return zoneInstance
end
local EffectZone = function(container, effectKey, OnPlayerEntered, OnPlayerExited)
	local zoneInstance = Zone.new(container)
	zoneInstance.playerEntered:Connect(OnPlayerEntered)
	zoneInstance.playerExited:Connect(OnPlayerExited)
	return zoneInstance
end
return {
	currentHazardZones = currentHazardZones,
	ZoneBase = ZoneBase,
	EffectZone = EffectZone,
}
]]></string>
          </Properties>
        </Item>
        <Item class="Script" referent="358">
          <Properties>
            <string name="Name">zone</string>
            <token name="RunContext">0</token>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Workspace = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Workspace
local ZoneBase = TS.import(script, game:GetService("ServerScriptService"), "TS", "zones", "ZoneBase").ZoneBase
local StatusEffectService = TS.import(script, game:GetService("ServerScriptService"), "TS", "services").StatusEffectService
--[[
	*
	 * @file        zone.server.ts
	 * @module      ZoneServer
	 * @layer       Server/Zones
	 * @description Module for managing zones in the game.
	 
]]
-- ================================================ Containers =============================================== 
local ZoneContainer = Workspace:WaitForChild("Zones")
-- Lobby Zone 
local Containers = {
	LobbyZone = ZoneContainer:WaitForChild("LobbyZone"),
	BattleZone = ZoneContainer:WaitForChild("BattleZone"),
}
local function onPlayerEnteredZone(player, zoneName)
	print(`Player {player.Name} has entered the {zoneName}.`)
	StatusEffectService:AddEffect(player, "Bleeding")
	-- Additional logic for when a player enters a zone can be added here
end
local function onPlayerExitedZone(player, zoneName)
	print(`Player {player.Name} has exited the {zoneName}.`)
	-- Additional logic for when a player exits a zone can be added here
end
local Lobby = ZoneBase(Containers.LobbyZone, function(player)
	onPlayerEnteredZone(player, "Lobby Zone")
end, function(player)
	onPlayerExitedZone(player, "Lobby Zone")
end)
local Battle = ZoneBase(Containers.BattleZone, function(player)
	onPlayerEnteredZone(player, "Battle Zone")
end, function(player)
	onPlayerExitedZone(player, "Battle Zone")
end)
]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="SoundService" referent="359">
    <Properties>
      <string name="Name">SoundService</string>
      <bool name="RespectFilteringEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="StarterPlayer" referent="360">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="361">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="Folder" referent="362">
        <Properties>
          <string name="Name">TS</string>
        </Properties>
        <Item class="LocalScript" referent="363">
          <Properties>
            <string name="Name">main</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/client/main.client.ts
	 * @module      ClientMain
	 * @layer       Client
	 * @description Main entry point for the client-side application.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
-- =============================================== External Imports ============================================= 
local _screens = TS.import(script, script.Parent, "ui", "screens")
local GemForgeScreen = _screens.GemForgeScreen
local PlayerHUDScreen = _screens.PlayerHUDScreen
local QuestsScreen = _screens.QuestsScreen
local CharacterScreen = TS.import(script, script.Parent, "ui", "screens", "CharacterScreen").CharacterScreen
local InventoryScreen = TS.import(script, script.Parent, "ui", "screens", "InventoryScreen").InventoryScreen
local SettingsScreen = TS.import(script, script.Parent, "ui", "screens", "SettingsScreen").SettingsScreen
local ShopScreen = TS.import(script, script.Parent, "ui", "screens", "ShopScreen").ShopScreen
local TeleportScreen = TS.import(script, script.Parent, "ui", "screens", "TeleportScreen").TeleportScreen
local Dispatch = TS.import(script, script.Parent, "network", "ClientDispatch")
-- =============================================== References ============================================= 
PlayerHUDScreen()
GemForgeScreen()
SettingsScreen()
TeleportScreen()
QuestsScreen()
ShopScreen()
CharacterScreen()
InventoryScreen()
-- =============================================== Network Tests ============================================= 
warn("Testing network calls...")
-- Dispatch.ActivateAbility("earthquake");
-- Dispatch.UpdatePlayerSetting("musicEnabled", true);
-- Dispatch.UpdatePlayerSetting("nickname", "PlayerOne");
-- Dispatch.IncreaseAttribute("str", 10);
Dispatch.GetProfileData("Abilities"):andThen(function(abilities)
	local _result = abilities
	if _result ~= nil then
		_result = table.concat(_result, ", ")
	end
	print(`Player Abilities: {_result}`)
end)
-- Dispatch.GetPlayerSettings().then((settings) => {
-- 	print(`Player Settings:`, settings);
-- });
-- Dispatch.GetProfileData("Abilities")
-- 	.then((abilities) => {
-- 		print(`Profile Abilities: ${abilities?.join(", ")}`);
-- 	})
-- 	.catch((err) => {
-- 		warn(`Error fetching profile data: ${err}`);
-- 	});
warn("Network tests completed.")
]]></string>
          </Properties>
        </Item>
        <Item class="Folder" referent="364">
          <Properties>
            <string name="Name">network</string>
          </Properties>
          <Item class="ModuleScript" referent="365">
            <Properties>
              <string name="Name">ClientDispatch</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local _shared = TS.import(script, game:GetService("ReplicatedStorage"), "TS")
local Network = _shared.Network
local ClientDispatch = _shared.ClientDispatch
-- Event Signals 
local ActivateAbilitySignal = Network.Client:Get("ActivateAbility")
local UpdateSettingSignal = Network.Client:Get("UpdatePlayerSetting")
-- Function Signals 
local GetPlayerSettingsSignal = Network.Client:Get("GetPlayerSettings")
local GetProfileDataSignal = ClientDispatch.Client:Get("GetData")
-- ============================================= Client Get Data ==================================================== 
-- export async function GetPlayerAbilities(): Promise<AbilityKey[] | undefined> {
-- 	return await GetPlayerAbilitiesSignal.CallServerAsync(Players.LocalPlayer);
-- }
local GetPlayerSettings = TS.async(function()
	return TS.await(GetPlayerSettingsSignal:CallServerAsync(Players.LocalPlayer))
end)
local GetProfileData = TS.async(function(key)
	print(`CallServer: GetProfileData({key}) called.`)
	return TS.await(GetProfileDataSignal:CallServerAsync(key))
end)
-- ============================================= Client Update Requests ==================================================== 
local function UpdatePlayerSetting(key, value)
	UpdateSettingSignal:SendToServer(key, value)
end
local function ActivateAbility(abilityKey)
	ActivateAbilitySignal:SendToServer(abilityKey)
end
local IncreaseAttribute = TS.async(function(attributeKey, amount)
	print(`CallServer: IncreaseAttribute({attributeKey}, {amount}) called.`)
	TS.await(ClientDispatch.Client:Get("IncreaseAttribute"):SendToServer(attributeKey, amount))
end)
return {
	GetPlayerSettings = GetPlayerSettings,
	GetProfileData = GetProfileData,
	UpdatePlayerSetting = UpdatePlayerSetting,
	ActivateAbility = ActivateAbility,
	IncreaseAttribute = IncreaseAttribute,
}
]]></string>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="366">
            <Properties>
              <string name="Name">listener</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local PlayerState = TS.import(script, script.Parent.Parent, "states", "PlayerState").default
local ServerDispatch = TS.import(script, game:GetService("ReplicatedStorage"), "TS").ServerDispatch
-- ------------------------------------ Network Listener ------------------------------------ 
-- PLAYER RESOURCE: Listen for resource updates from the server
ServerDispatch.Client:OnEvent("ResourceUpdated", function(key, current, max)
	local playerState = PlayerState:getInstance()
	local resource = playerState.Resources[key]
	if resource then
		resource.Current:set(current)
		resource.Max:set(max)
	else
		warn(`Resource {key} not found in PlayerState.`)
	end
end)
-- // Profile Changed: Listen for profile changes from the server
-- Network.Client.OnEvent("ProfileChanged", (data) => {
-- 	print("Profile changed:", data);
-- });
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="367">
          <Properties>
            <string name="Name">states</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/shared/states/index.ts
	 * @module      states
	 * @layer       Shared
	 * @description Barrel index file for the shared states module, exporting all state management utilities.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
-- export * from "./GemForgeState";
-- export * from "./InventoryState";
for _k, _v in TS.import(script, script, "PlayerState") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "ScreenState") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "ThemeState") or {} do
	exports[_k] = _v
end
exports.SettingsState = TS.import(script, script, "SettingsState").default
return exports
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="368">
            <Properties>
              <string name="Name">PlayerState</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Observer = _fusion.Observer
local Value = _fusion.Value
local Computed = _fusion.Computed
local _definitions = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions")
local ATTR_KEYS = _definitions.ATTR_KEYS
local DefaultAttributes = _definitions.DefaultAttributes
local CURRENCY_KEY = _definitions.CURRENCY_KEY
local DefaultCurrency = _definitions.DefaultCurrency
local _Resources = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "Resources")
local RESOURCE_KEYS = _Resources.RESOURCE_KEYS
local DEFAULT_RESOURCES = _Resources.DEFAULT_RESOURCES
local GetProfileData = TS.import(script, script.Parent.Parent, "network", "ClientDispatch").GetProfileData
--[[
	*
	 * @file        src/client/states/PlayerState.ts
	 * @module      PlayerState
	 * @layer       Client
	 * @description Defines the player's health, mana, and stamina states.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local PlayerState
do
	PlayerState = setmetatable({}, {
		__tostring = function()
			return "PlayerState"
		end,
	})
	PlayerState.__index = PlayerState
	function PlayerState.new(...)
		local self = setmetatable({}, PlayerState)
		return self:constructor(...) or self
	end
	function PlayerState:constructor()
		self.Abilities = {}
		self.Attributes = {}
		self.AttributeAvailable = Value(0)
		self.AttributeSpent = Value(0)
		self.Currency = {}
		self.StatusEffects = Value({})
		self.Resources = {}
		PlayerState.instance = self
		-- initialize attribute values
		for _, key in ATTR_KEYS do
			self.Attributes[key] = Value(DefaultAttributes[key])
		end
		self.AttributeAvailable:set(DefaultAttributes.AvailablePoints)
		self.AttributeSpent:set(DefaultAttributes.SpentPoints)
		-- initialize currency
		for _, key in CURRENCY_KEY do
			self.Currency[key] = Value(DefaultCurrency[key])
		end
		-- initialize resources using defaults
		for _, key in RESOURCE_KEYS do
			local data = DEFAULT_RESOURCES[key]
			local current = Value(data.current)
			local max = Value(data.max)
			self.Resources[key] = {
				Current = current,
				Max = max,
				Percent = Computed(function()
					return current:get() / math.max(max:get(), 1)
				end),
			}
		end
		self:debugObserverInit()
		self:fetchFromServer()
	end
	function PlayerState:debugObserverInit()
		local inst = PlayerState:getInstance()
		local res = inst.Resources
		Observer(res.Health.Current):onChange(function()
			print(`Health: {res.Health.Current:get()}/{res.Health.Max:get()}`)
		end)
		Observer(res.Mana.Current):onChange(function()
			print(`Mana: {res.Mana.Current:get()}/{res.Mana.Max:get()}`)
		end)
		Observer(res.Stamina.Current):onChange(function()
			print(`Stamina: {res.Stamina.Current:get()}/{res.Stamina.Max:get()}`)
		end)
	end
	PlayerState.fetchFromServer = TS.async(function(self)
		local abilities = TS.await(GetProfileData("Abilities"))
		if abilities then
			table.clear(abilities)
			-- ▼ ReadonlyArray.forEach ▼
			local _callback = function(ability)
				local abilityValue = Value(ability)
				local _exp = self.Abilities
				table.insert(_exp, abilityValue)
			end
			for _k, _v in abilities do
				_callback(_v, _k - 1, abilities)
			end
			-- ▲ ReadonlyArray.forEach ▲
		end
		local attrs = TS.await(GetProfileData("Attributes"))
		if attrs then
			local data = attrs
			for _, key in ATTR_KEYS do
				self.Attributes[key]:set(data[key])
			end
			self.AttributeAvailable:set(data.AvailablePoints)
			self.AttributeSpent:set(data.SpentPoints)
		end
	end)
	function PlayerState:getInstance()
		if not PlayerState.instance then
			PlayerState.instance = PlayerState.new()
		end
		return PlayerState.instance
	end
end
return {
	default = PlayerState,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="369">
            <Properties>
              <string name="Name">ScreenState</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--[[
	*
	 * @file        ScreenState.ts
	 * @module      ScreenState
	 * @layer       shared/states
	 * @description Manages the visibility state of various game screens.
	 *
	 * ╭──────────────────────────────╮
	 * │  Soul Steel · Coding Guide   │
	 * │  Fusion v4 · Strict TS · ECS │
	 * ╰──────────────────────────────╯
	 *
	 * @since        0.1.0
	 * @lastUpdated  2025-06-10 by Trembus
	 
]]
local Value = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").Value
--[[
	*
	 * Ordered list of all HUD-related screen keys.
	 
]]
local SCREEN_KEYS = { "Settings", "Inventory", "Character", "Quests", "Shop", "Teleport", "GemForge" }
local ScreenState = {
	Settings = Value(false),
	Inventory = Value(false),
	Character = Value(false),
	Quests = Value(false),
	Shop = Value(false),
	Teleport = Value(false),
	GemForge = Value(false),
}
local ScreenOrder = {
	Settings = 1,
	Inventory = 2,
	Character = 3,
	Quests = 4,
	Shop = 5,
	Teleport = 6,
	GemForge = 7,
}
--[[
	*
	 * Sets the given screen to visible while hiding all others.
	 *
	 * @param key - Screen to show.
	 
]]
local function ShowScreen(key)
	for _, screenKey in SCREEN_KEYS do
		ScreenState[screenKey]:set(screenKey == key)
	end
end
return {
	ShowScreen = ShowScreen,
	SCREEN_KEYS = SCREEN_KEYS,
	ScreenOrder = ScreenOrder,
	ScreenState = ScreenState,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="370">
            <Properties>
              <string name="Name">SettingsState</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        SettingsState.ts
	 * @module      SettingsState
	 * @layer       Client
	 * @description Reactive container for player settings.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
local Value = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").Value
local _Settings = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "ProfileDefinitions", "Settings")
local DefaultSettings = _Settings.DefaultSettings
local SETTING_KEYS = _Settings.SETTING_KEYS
local GetPlayerSettings = TS.import(script, script.Parent.Parent, "network", "ClientDispatch").GetPlayerSettings
local SettingsState
do
	SettingsState = setmetatable({}, {
		__tostring = function()
			return "SettingsState"
		end,
	})
	SettingsState.__index = SettingsState
	function SettingsState.new(...)
		local self = setmetatable({}, SettingsState)
		return self:constructor(...) or self
	end
	function SettingsState:constructor()
		self.Settings = {}
		for _, key in SETTING_KEYS do
			self.Settings[key] = Value(DefaultSettings[key])
		end
		self:fetchFromServer()
	end
	SettingsState.fetchFromServer = TS.async(function(self)
		local data = TS.await(GetPlayerSettings())
		if data ~= nil then
			for _, key in SETTING_KEYS do
				local val = data[key]
				self.Settings[key]:set(val)
			end
		end
	end)
	function SettingsState:getInstance()
		if not self.instance then
			self.instance = SettingsState.new()
		end
		return self.instance
	end
	function SettingsState:set(key, value)
		self.Settings[key]:set(value)
	end
end
return {
	default = SettingsState,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="371">
            <Properties>
              <string name="Name">ThemeState</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        ThemeState.ts
	 * @module      ThemeState
	 * @layer       Client
	 * @description Reactive theme store powered by Fusion.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
local Fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local _ThemeKey = TS.import(script, script.Parent.Parent.Parent, "Theme", "ThemeKey")
local ThemeKey = _ThemeKey.ThemeKey
local DEFAULT_THEME = _ThemeKey.DEFAULT_THEME
local cyberGothic = TS.import(script, script.Parent.Parent.Parent, "Theme", "tokens", "cyberGothic").cyberGothic
local solarDrift = TS.import(script, script.Parent.Parent.Parent, "Theme", "tokens", "solarDrift").solarDrift
local _binding = Fusion
local Value = _binding.Value
local Computed = _binding.Computed
local themeKey = Value(DEFAULT_THEME)
local themeMap = {
	[ThemeKey.CyberGothic] = cyberGothic,
	[ThemeKey.SolarDrift] = solarDrift,
}
local currentTokens = Computed(function()
	return themeMap[themeKey:get()]
end)
local ThemeState = {
	set = function(key)
		return themeKey:set(key)
	end,
	key = themeKey,
	tokens = currentTokens,
}
return {
	ThemeState = ThemeState,
}
]]></string>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="372">
            <Properties>
              <string name="Name">state</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local PlayerState = TS.import(script, script.Parent, "PlayerState").default
local playerState = PlayerState:getInstance()
print(playerState)
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="373">
          <Properties>
            <string name="Name">ui</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/ui/index.ts
	 * @module      UIMainIndex
	 * @layer       Client
	 * @description Barrel index file for the UI module, exporting all atoms and components.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
for _k, _v in TS.import(script, script, "helpers") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "atoms") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "molecules") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "organisms") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "screens") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "tokens") or {} do
	exports[_k] = _v
end
return exports
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="374">
            <Properties>
              <string name="Name">atoms</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/ui/atoms/index.ts
	 * @module      UIAtomsIndex
	 * @layer       Client/UI/Atoms
	 * @description Barrel index file for Atoms in the UI module, exporting all components.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-25 by Trembus – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
for _k, _v in TS.import(script, script, "Button") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "Container") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "DragDetector") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "Image") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "Text") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "Gem") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "Screen") or {} do
	exports[_k] = _v
end
return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="375">
              <Properties>
                <string name="Name">Button</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/client/ui/atoms/Button/index.ts
	 * @module      UIButtonIndex
	 * @layer       Client/UI/Atoms
	 * @description Barrel export for button atoms.
	 
]]
for _k, _v in TS.import(script, script, "UIButton") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "DraggableButton") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "GameButton") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "IconButton") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "ItemButton") or {} do
	exports[_k] = _v
end
return exports
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="376">
                <Properties>
                  <string name="Name">DraggableButton</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        DraggableButton.ts
	 * @module      DraggableButton
	 * @layer       Client/UI/Atoms
	 * @description Thin wrapper around `UIButton` with drag enabled.
	 
]]
local UIButton = TS.import(script, script.Parent, "UIButton").UIButton
local DraggableButton = function(p)
	local _condition = p.Icon
	if _condition == nil then
		_condition = p.Image
	end
	local icon = _condition
	local _object = table.clone(p)
	setmetatable(_object, nil)
	local props = _object
	props.Image = nil
	props.Icon = nil
	local _object_1 = {
		Draggable = true,
		Variant = "flat",
		Icon = icon,
	}
	for _k, _v in props do
		_object_1[_k] = _v
	end
	return UIButton(_object_1)
end
return {
	DraggableButton = DraggableButton,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="377">
                <Properties>
                  <string name="Name">GameButton</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        GameButton.ts
	 * @module      GameButton
	 * @layer       Client/UI/Atoms
	 * @description Panel-style button wrapper around `UIButton`.
	 
]]
local UIButton = TS.import(script, script.Parent, "UIButton").UIButton
local GameButton = function(p)
	local _condition = p.Icon
	if _condition == nil then
		_condition = p.Image
	end
	local icon = _condition
	local _object = table.clone(p)
	setmetatable(_object, nil)
	local props = _object
	props.Image = nil
	props.Icon = nil
	local _object_1 = {
		Icon = icon,
		Variant = "panel",
	}
	for _k, _v in props do
		_object_1[_k] = _v
	end
	return UIButton(_object_1)
end
return {
	GameButton = GameButton,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="378">
                <Properties>
                  <string name="Name">IconButton</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        IconButton.ts
	 * @module      IconButton
	 * @layer       Client/UI/Atoms
	 * @description Thin icon button wrapper around `UIButton`.
	 
]]
local UIButton = TS.import(script, script.Parent, "UIButton").UIButton
local IconButton = function(p)
	local _condition = p.Icon
	if _condition == nil then
		_condition = p.Image
	end
	local icon = _condition
	local _object = table.clone(p)
	setmetatable(_object, nil)
	local props = _object
	props.Image = nil
	props.Icon = nil
	local _object_1 = {
		Icon = icon,
		Variant = "flat",
	}
	for _k, _v in props do
		_object_1[_k] = _v
	end
	return UIButton(_object_1)
end
return {
	IconButton = IconButton,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="379">
                <Properties>
                  <string name="Name">ItemButton</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        ItemButton.ts
	 * @module      ItemButton
	 * @layer       Client/UI/Atoms
	 * @description Inventory item button wrapper using `UIButton`.
	 
]]
local UIButton = TS.import(script, script.Parent, "UIButton").UIButton
local sampleItemMetadata
sampleItemMetadata = {
	DisplayName = "Sample Item",
	Rarity = "Common",
	itemId = "sample-item-123",
	Icon = "rbxassetid://124443221759409",
	OnClick = function()
		print(`Item clicked: {sampleItemMetadata.itemId}`)
	end,
}
local ItemButton = function(id)
	local meta = sampleItemMetadata
	return UIButton({
		Icon = meta.Icon,
		Label = meta.DisplayName,
		Rarity = meta.Rarity,
		Variant = "panel",
		Draggable = true,
		OnClick = meta.OnClick,
	})
end
return {
	ItemButton = ItemButton,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="380">
                <Properties>
                  <string name="Name">UIButton</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        UIButton.ts
	 * @module      UIButton
	 * @layer       Client/UI/Atoms
	 * @description Unified button primitive used by all button wrappers.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
-- -------------- Imports ------------- //
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Children = _fusion.Children
local Computed = _fusion.Computed
local New = _fusion.New
local OnEvent = _fusion.OnEvent
local Value = _fusion.Value
local GamePanel = TS.import(script, script.Parent.Parent, "Container").GamePanel
local GameText = TS.import(script, script.Parent.Parent, "Text").GameText
local BorderImage = TS.import(script, script.Parent.Parent, "Image").BorderImage
local GameImages = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets").GameImages
local ButtonSizes = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "constants", "sizes").ButtonSizes
local useToken = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "Theme", "hooks").useToken
-- -------------- Helpers -------------- //
local function resolveIcon(icon)
	if icon == nil then
		return ""
	end
	local lookup = GameImages[icon]
	local _condition = lookup
	if _condition == nil then
		_condition = icon
	end
	return _condition
end
local function resolveBorder(rarity)
	if not rarity then
		return nil
	end
	repeat
		if rarity == "Common" then
			return BorderImage.CommonRarity()
		end
		if rarity == "Uncommon" then
			return BorderImage.CommonRarity()
		end
		if rarity == "Rare" then
			return BorderImage.RareRarity()
		end
		if rarity == "Epic" then
			return BorderImage.EpicRarity()
		end
		if rarity == "Legendary" then
			return BorderImage.LegendaryRarity()
		end
	until true
end
-- -------------- Props ---------------- //
-- -------------- UIButton Component --------------- //
local UIButton = function(props)
	local variant = props.Variant or "flat"
	local _condition = props.Selected
	if _condition == nil then
		_condition = false
	end
	local selected = Value(_condition)
	local bg = useToken("panelBg")
	local borderColour = useToken("panelBorder")
	local background = Computed(function()
		return if selected:get() then borderColour:get() else bg:get()
	end)
	local borderTransparency = Computed(function()
		return if selected:get() then 0 else 1
	end)
	local drag = if props.Draggable then New("UIDragDetector")({
		Name = "DragDetector",
		Enabled = true,
		DragRelativity = Enum.UIDragDetectorDragRelativity.Absolute,
		DragStyle = Enum.UIDragDetectorDragStyle.Scriptable,
		[OnEvent("DragStart")] = props.OnDragStart,
		[OnEvent("DragContinue")] = props.OnDragContinue,
		[OnEvent("DragEnd")] = props.OnDragEnd,
	}) else nil
	local _fn = New("ImageButton")
	local _object = {}
	local _left = "Name"
	local _condition_1 = props.Name
	if _condition_1 == nil then
		_condition_1 = "UIButton"
	end
	_object[_left] = _condition_1
	_object.Size = props.Size or ButtonSizes.Icon()
	_object.AnchorPoint = props.AnchorPoint or Vector2.new(0.5, 0.5)
	_object.Position = props.Position or UDim2.fromScale(0.5, 0.5)
	local _left_1 = "BackgroundTransparency"
	local _result
	if variant == "flat" then
		_result = 1
	else
		local _condition_2 = props.BackgroundTransparency
		if _condition_2 == nil then
			_condition_2 = 0
		end
		_result = _condition_2
	end
	_object[_left_1] = _result
	_object.BackgroundColor3 = if variant == "panel" then background else (props.BackgroundColor3 or Color3.new(1, 1, 1))
	_object.Image = resolveIcon(props.Icon)
	_object.ImageColor3 = props.ImageColor3 or Color3.new(1, 1, 1)
	_object[OnEvent("Activated")] = function()
		return props.OnClick and props.OnClick()
	end
	local _left_2 = Children
	local _object_1 = {}
	local _left_3 = "Label"
	local _value = props.Label
	_object_1[_left_3] = if _value ~= "" and _value then GameText({
		Name = "Label",
		TextStateValue = Value(props.Label),
		AnchorPoint = Vector2.new(0.5, 1),
		Position = UDim2.fromScale(0.5, 1),
		Size = UDim2.fromScale(1, 0.25),
		BackgroundTransparency = 1,
		TextSize = 14,
	}) else nil
	_object_1.Border = if props.Rarity then (function()
		local b = resolveBorder(props.Rarity)
		if b then
			b.AnchorPoint = Vector2.new(0.5, 0.5)
			b.Position = UDim2.fromScale(0.5, 0.5)
			b.Size = UDim2.fromScale(1, 1)
			b.ImageTransparency = borderTransparency
		end
		return b
	end)() else nil
	_object_1.Drag = if variant == "flat" then drag else nil
	_object[_left_2] = _object_1
	local button = _fn(_object)
	if variant == "panel" then
		local _object_2 = {}
		local _left_4 = "Name"
		local _condition_2 = props.Name
		if _condition_2 == nil then
			_condition_2 = "UIButton"
		end
		_object_2[_left_4] = `{_condition_2}Panel`
		_object_2.Size = props.Size or ButtonSizes.Icon()
		_object_2.BackgroundTransparency = 0.2
		_object_2.Content = {
			Button = button,
			Drag = drag,
		}
		return GamePanel(_object_2)
	end
	return button
end
return {
	UIButton = UIButton,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="381">
              <Properties>
                <string name="Name">Container</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/client/ui/atoms/Container/index.ts
	 * @module      UIContainerIndex
	 * @layer       Client/UI/Atoms
	 * @description Barrel export for container atoms.
	 
]]
for _k, _v in TS.import(script, script, "BaseContainer") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "VerticalContainer") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "HorizontalContainer") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "GridContainer") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "GamePanel") or {} do
	exports[_k] = _v
end
return exports
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="382">
                <Properties>
                  <string name="Name">BaseContainer</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        BaseContainer.ts
	 * @module      BaseContainer
	 * @layer       Client/UI/Atoms
	 * @description Simple frame wrapper used by container variants.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Children = _fusion.Children
local New = _fusion.New
local useToken = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "Theme", "hooks").useToken
local BaseContainer = function(props)
	local bg = useToken("panelBg")
	local _fn = New("Frame")
	local _object = {}
	local _left = "Name"
	local _condition = props.Name
	if _condition == nil then
		_condition = "BaseContainer"
	end
	_object[_left] = _condition
	_object.AnchorPoint = props.AnchorPoint or Vector2.new(0.5, 0.5)
	_object.Position = props.Position or UDim2.fromScale(0.5, 0.5)
	_object.Size = props.Size or UDim2.fromScale(1, 1)
	_object.BackgroundColor3 = props.BackgroundColor3 or bg
	local _left_1 = "BackgroundTransparency"
	local _condition_1 = props.BackgroundTransparency
	if _condition_1 == nil then
		_condition_1 = 0.2
	end
	_object[_left_1] = _condition_1
	local _left_2 = Children
	local _object_1 = {
		Padding = props.Padding,
		BorderImage = props.BorderImage,
	}
	for _k, _v in (props.Content or {}) do
		_object_1[_k] = _v
	end
	_object[_left_2] = _object_1
	return _fn(_object)
end
return {
	BaseContainer = BaseContainer,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="383">
                <Properties>
                  <string name="Name">GamePanel</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        GamePanel.ts
	 * @module      GamePanel
	 * @layer       Client/Atom
	 * @description Core(Foundational Atom that serves as the base of any custom component that would use a Frame object).
	 * There are additional properties that can be used to customize the component, such as scrolling, hover effects, drag functionality, and more.
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-05-29 by Trembus – Update
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 *
	 
]]
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local New = _fusion.New
local Children = _fusion.Children
local Computed = _fusion.Computed
local Value = _fusion.Value
local OnEvent = _fusion.OnEvent
local _tokens = TS.import(script, script.Parent.Parent.Parent, "tokens")
local Layout = _tokens.Layout
local Stroke = _tokens.Stroke
local useToken = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "Theme", "hooks").useToken
-- =============================================== GamePanel Props ========================================= 
-- =============================================== Scroll Component ========================================= 
local function ScrollContent(children, layout)
	local bg = useToken("panelBg")
	local _fn = New("ScrollingFrame")
	local _object = {
		Name = "ScrollContent",
		BackgroundTransparency = 0.8,
		BackgroundColor3 = bg,
		Size = UDim2.fromScale(1, 1),
		ScrollBarThickness = 2,
		ScrollBarImageTransparency = 0.5,
	}
	local _left = Children
	local _object_1 = {
		Layout = layout or Layout.Grid(10, UDim2.fromOffset(100, 100)),
	}
	if children then
		for _k, _v in children do
			_object_1[_k] = _v
		end
	end
	_object[_left] = _object_1
	return _fn(_object)
end
-- =============================================== Content Component ========================================= 
local function Content(children, layout)
	local _fn = New("Frame")
	local _object = {
		Name = "Content",
		BackgroundTransparency = 1,
		Size = UDim2.fromScale(1, 1),
	}
	local _left = Children
	local _object_1 = {
		Layout = layout or {},
	}
	if children then
		for _k, _v in children do
			_object_1[_k] = _v
		end
	end
	_object[_left] = _object_1
	return _fn(_object)
end
-- =============================================== GamePanel Component ========================================= 
local GamePanel = function(props)
	-- ----- State Setup ----- 
	-- Hover State
	local isHovered = Value(false)
	local bg = useToken("panelBg")
	local borderColor = useToken("panelBorder")
	-- UI Stroke Hover Effect
	local strokeColor = Computed(function()
		return if isHovered:get() and props.HoverEffect then borderColor:get() else borderColor:get()
	end)
	-- Stroke Thickness
	local strokeThickness = Computed(function()
		return if isHovered:get() then 1.4 else 0.9
	end)
	-- Content (Scrollable or not)
	local content = if props.Scrolling then ScrollContent(props.Content or {}, props.Layout) else Content(props.Content or {}, props.Layout)
	-- ----- Component Defaults Setup ----- 
	-- -- Frame Properties -- 
	local _condition = props.Name
	if _condition == nil then
		_condition = "GamePanel"
	end
	props.Name = _condition
	props.AnchorPoint = props.AnchorPoint or Vector2.new(0, 0)
	props.BackgroundColor3 = props.BackgroundColor3 or bg
	local _condition_1 = props.BackgroundTransparency
	if _condition_1 == nil then
		_condition_1 = 1
	end
	props.BackgroundTransparency = _condition_1
	props.Position = props.Position or UDim2.fromScale(0, 0)
	props.Size = props.Size or UDim2.fromScale(1, 1)
	local _condition_2 = props.LayoutOrder
	if _condition_2 == nil then
		_condition_2 = 1
	end
	props.LayoutOrder = _condition_2
	-- -- Special Properties -- 
	local _condition_3 = props.HoverEffect
	if _condition_3 == nil then
		_condition_3 = true
	end
	props.HoverEffect = _condition_3
	local _condition_4 = props.DragEnabled
	if _condition_4 == nil then
		_condition_4 = false
	end
	props.DragEnabled = _condition_4
	props.BorderImage = props.BorderImage or nil
	props.FlexInstance = props.FlexInstance or nil
	props.Padding = props.Padding or nil
	props.Stroke = props.Stroke or Stroke({
		Thickness = strokeThickness,
		Color = strokeColor,
	})
	props.OnDragStart = props.OnDragStart or (function()
		return print("Drag started")
	end)
	props.OnDragEnd = props.OnDragEnd or (function()
		return print("Drag ended")
	end)
	-- ----- Template ----- 
	local customComponent = New("Frame")({
		Name = props.Name,
		AnchorPoint = props.AnchorPoint,
		BackgroundColor3 = props.BackgroundColor3,
		BackgroundTransparency = props.BackgroundTransparency,
		Position = props.Position,
		Size = props.Size,
		LayoutOrder = props.LayoutOrder,
		[OnEvent("MouseEnter")] = function()
			return isHovered:set(true)
		end,
		[OnEvent("MouseLeave")] = function()
			return isHovered:set(false)
		end,
		[Children] = {
			Gradient = props.Gradient,
			BorderImage = props.BorderImage,
			Padding = props.Padding,
			FlexInstance = props.FlexInstance,
			Content = {
				Padding = props.Padding,
				Content = content,
			},
			StyleChildren = props.StyleChildren or {},
		},
	})
	return customComponent
end
return {
	GamePanel = GamePanel,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="384">
                <Properties>
                  <string name="Name">GridContainer</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        GridContainer.ts
	 * @module      GridContainer
	 * @layer       Client/UI/Atoms
	 * @description BaseContainer with grid layout helper.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
local BaseContainer = TS.import(script, script.Parent, "BaseContainer").BaseContainer
local Layout = TS.import(script, script.Parent.Parent.Parent, "tokens").Layout
local GridContainer = function(props)
	local _object = {
		Layout = Layout.Grid(props.Gap, props.CellSize),
	}
	for _k, _v in (props.Content or {}) do
		_object[_k] = _v
	end
	local content = _object
	local _object_1 = table.clone(props)
	setmetatable(_object_1, nil)
	_object_1.Content = content
	return BaseContainer(_object_1)
end
return {
	GridContainer = GridContainer,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="385">
                <Properties>
                  <string name="Name">HorizontalContainer</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        HorizontalContainer.ts
	 * @module      HorizontalContainer
	 * @layer       Client/UI/Atoms
	 * @description Wrapper that arranges children horizontally.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
local BaseContainer = TS.import(script, script.Parent, "BaseContainer").BaseContainer
local Layout = TS.import(script, script.Parent.Parent.Parent, "tokens").Layout
local HorizontalContainer = function(props)
	local _object = {
		Layout = Layout.HorizontalSet(props.Gap),
	}
	for _k, _v in (props.Content or {}) do
		_object[_k] = _v
	end
	local content = _object
	local _object_1 = table.clone(props)
	setmetatable(_object_1, nil)
	_object_1.Content = content
	return BaseContainer(_object_1)
end
return {
	HorizontalContainer = HorizontalContainer,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="386">
                <Properties>
                  <string name="Name">VerticalContainer</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        VerticalContainer.ts
	 * @module      VerticalContainer
	 * @layer       Client/UI/Atoms
	 * @description Wrapper that stacks children vertically.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
local BaseContainer = TS.import(script, script.Parent, "BaseContainer").BaseContainer
local Layout = TS.import(script, script.Parent.Parent.Parent, "tokens").Layout
local VerticalContainer = function(props)
	local _object = {
		Layout = Layout.VerticalSet(props.Gap),
	}
	for _k, _v in (props.Content or {}) do
		_object[_k] = _v
	end
	local content = _object
	local _object_1 = table.clone(props)
	setmetatable(_object_1, nil)
	_object_1.Content = content
	return BaseContainer(_object_1)
end
return {
	VerticalContainer = VerticalContainer,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="387">
              <Properties>
                <string name="Name">DragDetector</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, script, "DragDetector") or {} do
	exports[_k] = _v
end
return exports
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="388">
                <Properties>
                  <string name="Name">DragDetector</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        DragDetector.ts
	 * @module      DragDetector
	 * @layer       Client/UI/Atoms
	 * @description Wrapper component for `UIDragDetector` with typed events.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-07-03 by Codex – Added documentation header
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local New = _fusion.New
local OnEvent = _fusion.OnEvent
local Children = _fusion.Children
local function DragDetector(props)
	local _binding = props
	local OnDragStart = _binding.OnDragStart
	local OnDragContinue = _binding.OnDragContinue
	local OnDragEnd = _binding.OnDragEnd
	local _fn = New("UIDragDetector")
	local _object = {}
	local _left = "Name"
	local _condition = props.Name
	if _condition == nil then
		_condition = "DragDetectorZ"
	end
	_object[_left] = _condition
	local _left_1 = "Enabled"
	local _condition_1 = props.Enabled
	if _condition_1 == nil then
		_condition_1 = false
	end
	_object[_left_1] = _condition_1
	_object.DragAxis = props.DragAxis or Vector2.one
	_object.DragRelativity = props.DragRelativity or Enum.UIDragDetectorDragRelativity.Absolute
	_object.DragStyle = props.DragStyle or Enum.UIDragDetectorDragStyle.Scriptable
	_object.BoundingUI = props.BoundingUI or nil
	_object[Children] = props[Children]
	_object[OnEvent("DragStart")] = OnDragStart
	_object[OnEvent("DragContinue")] = OnDragContinue
	_object[OnEvent("DragEnd")] = OnDragEnd
	return _fn(_object)
end
return {
	DragDetector = DragDetector,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="389">
              <Properties>
                <string name="Name">Gem</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, script, "GemSlot") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "RingSlot") or {} do
	exports[_k] = _v
end
return exports
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="390">
                <Properties>
                  <string name="Name">GemSlot</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        GemSlot.ts
	 * @module      GemSlot
	 * @layer       Client/UI/Atoms
	 * @description Clickable inventory gem slot with rarity border and icon.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-07-01 by Codex – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
-- #AGENT_ATOM
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Children = _fusion.Children
local New = _fusion.New
local OnEvent = _fusion.OnEvent
local GameImages = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets").GameImages
local BorderImage = TS.import(script, script.Parent.Parent, "Image").BorderImage
local GameImage = TS.import(script, script.Parent.Parent, "Image", "GameImage").GameImage
local GameButton = TS.import(script, script.Parent.Parent, "Button").GameButton
local function GemSlot(props)
	local border = function()
		local _exp = props.Rarity
		repeat
			if _exp == "Rare" then
				return BorderImage.RareRarity()
			end
			if _exp == "Epic" then
				return BorderImage.EpicRarity()
			end
			if _exp == "Legendary" then
				return BorderImage.LegendaryRarity()
			end
			return BorderImage.GothicMetal()
		until true
	end
	local _object = {}
	local _left = "Name"
	local _condition = props.Name
	if _condition == nil then
		_condition = "GemSlot"
	end
	_object[_left] = _condition
	_object.Size = props.Size or UDim2.fromOffset(70, 70)
	_object.BackgroundTransparency = 0.5
	_object.ImageTransparency = 1
	_object[OnEvent("Activated")] = function()
		return props.OnClick and props.OnClick()
	end
	local _left_1 = Children
	local _object_1 = {
		Dragger = New("UIDragDetector")({
			Name = "GemSlotDragger",
			Enabled = true,
			[OnEvent("DragStart")] = function()
				print("Drag started on gem slot")
			end,
			[OnEvent("DragEnd")] = function()
				print("Drag ended on gem slot")
			end,
		}),
		Border = border(),
	}
	local _left_2 = "Icon"
	local _object_2 = {}
	local _left_3 = "Image"
	local _condition_1 = props.Icon
	if _condition_1 == nil then
		_condition_1 = GameImages.Gems.Colorable
	end
	_object_2[_left_3] = _condition_1
	_object_2.Size = UDim2.fromScale(0.8, 0.8)
	_object_2.Position = UDim2.fromScale(0.5, 0.5)
	_object_2.AnchorPoint = Vector2.new(0.5, 0.5)
	_object_1[_left_2] = GameImage(_object_2)
	_object[_left_1] = _object_1
	return GameButton(_object)
end
return {
	GemSlot = GemSlot,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="391">
                <Properties>
                  <string name="Name">RingSlot</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        RingSlot.ts
	 * @module      RingSlot
	 * @layer       Client/UI/Atoms
	 * @description Circular drop slot used in the Gem Forge rings.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-07-01 by Codex – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
-- #AGENT_ATOM
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local New = _fusion.New
local OnEvent = _fusion.OnEvent
local Value = _fusion.Value
local Computed = _fusion.Computed
local Children = _fusion.Children
local GameImages = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets").GameImages
local function RingSlot(props)
	local hovered = Value(false)
	local highlight = Computed(function()
		return if hovered:get() then (props.HighlightColor or Color3.new(1, 1, 1)) else Color3.new(1, 1, 1)
	end)
	local transparency = Computed(function()
		return if hovered:get() then 0.4 else 0.8
	end)
	local _fn = New("ImageButton")
	local _object = {}
	local _left = "Name"
	local _condition = props.Name
	if _condition == nil then
		_condition = "RingSlot"
	end
	_object[_left] = _condition
	_object.BackgroundTransparency = 1
	_object.Image = GameImages.TextureImage.Mystical
	_object.ImageColor3 = highlight
	_object.ImageTransparency = transparency
	_object.ScaleType = Enum.ScaleType.Fit
	_object.Size = props.Size or UDim2.fromOffset(64, 64)
	_object[OnEvent("MouseEnter")] = function()
		return hovered:set(true)
	end
	_object[OnEvent("MouseLeave")] = function()
		return hovered:set(false)
	end
	_object[Children] = {}
	return _fn(_object)
end
return {
	RingSlot = RingSlot,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="392">
              <Properties>
                <string name="Name">Image</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, script, "GameImage") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "BorderImage") or {} do
	exports[_k] = _v
end
return exports
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="393">
                <Properties>
                  <string name="Name">BorderImage</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local GameImage = TS.import(script, script.Parent, "GameImage").GameImage
local GameImages = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets", "image").GameImages
-- =============================================== SliceImage ========================================= 
local SliceImage = function(props)
	local _object = {
		Image = props.Image,
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = props.SliceCenter or Rect.new(250, 250, 250, 250),
	}
	local _left = "ZIndex"
	local _condition = props.ZIndex
	if _condition == nil then
		_condition = 100
	end
	_object[_left] = _condition
	return GameImage(_object)
end
-- =============================================== Slice Constants ========================================= 
-- =============================================== BorderImage Component (9-Slice) ========================================= 
local BorderImage = {
	GothicMetal = function()
		return SliceImage({
			Image = GameImages.Borders.GothicMetal,
		})
	end,
	RedThick = function()
		return SliceImage({
			Image = GameImages.Borders.RedThick,
		})
	end,
	CommonRarity = function()
		return SliceImage({
			Image = GameImages.Borders.CommonSet,
		})
	end,
	RareRarity = function()
		return SliceImage({
			Image = GameImages.Borders.RareSet,
		})
	end,
	EpicRarity = function()
		return SliceImage({
			Image = GameImages.Borders.EpicSet,
		})
	end,
	LegendaryRarity = function()
		return SliceImage({
			Image = GameImages.Borders.LegendarySet,
		})
	end,
}
return {
	SliceImage = SliceImage,
	BorderImage = BorderImage,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="394">
                <Properties>
                  <string name="Name">GameImage</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        GameImage.ts
	 * @module      GameImage
	 * @layer       Client/Atom
	 * @description Lightweight wrapper around `ImageLabel`.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-05-29 by Luminesa – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
-- =============================================== Imports ========================================= 
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Children = _fusion.Children
local New = _fusion.New
-- =============================================== Props ========================================= 
-- =============================================== GameImage Component ========================================= 
local function GameImage(props)
	local _fn = New("ImageLabel")
	local _object = {}
	local _left = "Name"
	local _condition = props.Name
	if _condition == nil then
		_condition = "GameImage"
	end
	_object[_left] = _condition
	_object.AnchorPoint = props.AnchorPoint or Vector2.new(0.5, 0.5)
	_object.BackgroundTransparency = 1
	local _left_1 = "Image"
	local _condition_1 = props.Image
	if _condition_1 == nil then
		_condition_1 = "rbxassetid://121566852339881"
	end
	_object[_left_1] = _condition_1
	_object.Size = props.Size or UDim2.fromScale(1, 1)
	_object.Position = props.Position or UDim2.fromScale(0.5, 0.5)
	local _left_2 = "ZIndex"
	local _condition_2 = props.ZIndex
	if _condition_2 == nil then
		_condition_2 = 1
	end
	_object[_left_2] = _condition_2
	_object.ScaleType = props.ScaleType or Enum.ScaleType.Fit
	_object.SliceCenter = props.SliceCenter or Rect.new(0, 0, 0, 0)
	_object.ImageRectOffset = props.ImageRectOffset or Vector2.new(0, 0)
	_object.ImageRectSize = props.ImageRectSize or Vector2.new(0, 0)
	local _left_3 = Children
	local _object_1 = {}
	local _left_4 = "RatioConstraint"
	local _value = props.RatioConstraint
	_object_1[_left_4] = if _value ~= 0 and _value == _value and _value then New("UIAspectRatioConstraint")({
		AspectRatio = props.RatioConstraint,
		DominantAxis = Enum.DominantAxis.Height,
	}) else nil
	_object[_left_3] = _object_1
	return _fn(_object)
end
return {
	GameImage = GameImage,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="395">
              <Properties>
                <string name="Name">Screen</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, script, "GameScreen") or {} do
	exports[_k] = _v
end
return exports
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="396">
                <Properties>
                  <string name="Name">GameScreen</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        GameScreen.ts
	 * @module      GameScreen
	 * @layer       Client/UI/Atoms
	 * @description Base ScreenGui container with standard defaults.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-07-02 by Codex – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
-- #AGENT_ATOM
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Children = _fusion.Children
local New = _fusion.New
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local GameScreen = function(props)
	local _condition = props.Name
	if _condition == nil then
		_condition = "GameScreen"
	end
	props.Name = _condition
	local _condition_1 = props.DisplayOrder
	if _condition_1 == nil then
		_condition_1 = 1000
	end
	props.DisplayOrder = _condition_1
	local _condition_2 = props.ResetOnSpawn
	if _condition_2 == nil then
		_condition_2 = false
	end
	props.ResetOnSpawn = _condition_2
	local _condition_3 = props.Enabled
	if _condition_3 == nil then
		_condition_3 = true
	end
	props.Enabled = _condition_3
	local parent = props.Parent or Players.LocalPlayer:WaitForChild("PlayerGui")
	return New("ScreenGui")({
		Name = props.Name,
		DisplayOrder = props.DisplayOrder,
		ResetOnSpawn = props.ResetOnSpawn,
		Enabled = props.Enabled,
		Parent = parent,
		[Children] = props.Content or {},
	})
end
return {
	GameScreen = GameScreen,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="397">
              <Properties>
                <string name="Name">Text</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, script, "GameText") or {} do
	exports[_k] = _v
end
return exports
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="398">
                <Properties>
                  <string name="Name">GameText</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Fusion = _fusion
local Computed = _fusion.Computed
local OnEvent = _fusion.OnEvent
local Value = _fusion.Value
local useToken = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "Theme", "hooks").useToken
local function GameText(props)
	print("GameText Component Rendered", props.Size, props.TextStateValue:get())
	local HoveredState = Value(false)
	local colour = useToken("textPrimary")
	local regularFont = Font.new("SourceSans", Enum.FontWeight.Regular, Enum.FontStyle.Normal)
	local boldFont = Font.new("SourceSans", Enum.FontWeight.Bold, Enum.FontStyle.Normal)
	local font = Computed(function()
		if HoveredState:get() or props.Title then
			return boldFont
		end
		return regularFont
	end)
	local _fn = Fusion.New("TextLabel")
	local _object = {}
	local _left = "Name"
	local _condition = props.Name
	if _condition == nil then
		_condition = "GameText"
	end
	_object[_left] = _condition
	_object.AnchorPoint = props.AnchorPoint or Vector2.new(0.5, 0.5)
	_object.Position = props.Position or UDim2.fromScale(0.5, 0.5)
	_object.Size = props.Size or UDim2.fromScale(0.5, 0.5)
	_object.TextColor3 = colour
	local _left_1 = "BackgroundTransparency"
	local _condition_1 = props.BackgroundTransparency
	if _condition_1 == nil then
		_condition_1 = 1
	end
	_object[_left_1] = _condition_1
	_object.Text = Computed(function()
		return props.TextStateValue:get()
	end)
	local _left_2 = "TextSize"
	local _condition_2 = props.TextSize
	if _condition_2 == nil then
		_condition_2 = 14
	end
	_object[_left_2] = _condition_2
	local _left_3 = "ZIndex"
	local _condition_3 = props.ZIndex
	if _condition_3 == nil then
		_condition_3 = 1
	end
	_object[_left_3] = _condition_3
	local _left_4 = "LayoutOrder"
	local _condition_4 = props.LayoutOrder
	if _condition_4 == nil then
		_condition_4 = 0
	end
	_object[_left_4] = _condition_4
	_object[OnEvent("MouseEnter")] = function()
		return HoveredState:set(true)
	end
	_object[OnEvent("MouseLeave")] = function()
		return HoveredState:set(false)
	end
	local GameTextComponent = _fn(_object)
	return GameTextComponent
end
return {
	GameText = GameText,
}
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="399">
            <Properties>
              <string name="Name">helpers</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/client/ui/helpers/index.ts
	 * @module      HelpersIndex
	 * @layer       Client/UI
	 * @description Barrel export for UI helper utilities.
	 
]]
for _k, _v in TS.import(script, script, "dragHelpers") or {} do
	exports[_k] = _v
end
return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="400">
              <Properties>
                <string name="Name">dragHelpers</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        dragHelpers.ts
	 * @module      DragHelpers
	 * @layer       Client/UI
	 * @description Utility helpers for drag-and-drop interactions.
	 
]]
-- --------------------------------- Drop Detection -------------------------- 
local function DroppedInside(drop, obj)
	local dp = drop.AbsolutePosition
	local ds = drop.AbsoluteSize
	local op = obj.AbsolutePosition
	local os = obj.AbsoluteSize
	local cx = op.X + os.X / 2
	local cy = op.Y + os.Y / 2
	return cx >= dp.X and cx <= dp.X + ds.X and cy >= dp.Y and cy <= dp.Y + ds.Y
end
return {
	DroppedInside = DroppedInside,
}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="401">
            <Properties>
              <string name="Name">molecules</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, script, "AbilityInfoPanel") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "FillBar", "BarMeter") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "CountdownTimer") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "GameWindow") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "Button") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "SettingListItem") or {} do
	exports[_k] = _v
end
return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="402">
              <Properties>
                <string name="Name">AbilityInfoPanel</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local AbilitiesMeta = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "ProfileDefinitions", "Ability").AbilitiesMeta
local _atoms = TS.import(script, script.Parent.Parent, "atoms")
local GamePanel = _atoms.GamePanel
local GameImage = _atoms.GameImage
local GameText = _atoms.GameText
local Value = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").Value
local Layout = TS.import(script, script.Parent.Parent, "tokens").Layout
local function AbilityInfoPanel(_param)
	local abilityKey = _param.abilityKey
	local abilityMeta = AbilitiesMeta[abilityKey]
	local abilityIcon = GameImage({
		Name = `AbilityIcon-{abilityKey}`,
		Image = abilityMeta.iconId,
		Size = UDim2.fromScale(0.2, 1),
	})
	local abilityName = GameText({
		Name = `AbilityName-{abilityKey}`,
		TextStateValue = Value(abilityMeta.displayName),
		Size = UDim2.fromScale(0.8, 1),
	})
	local abilityDescription = GameText({
		Name = `AbilityDescription-{abilityKey}`,
		TextStateValue = Value(abilityMeta.description),
		Size = UDim2.fromScale(1, 0.3),
		TextWrapped = true,
	})
	local abilityCooldown = GameText({
		Name = `AbilityCooldown-{abilityKey}`,
		TextStateValue = Value(`Cooldown: {abilityMeta.cooldown} seconds`),
		Size = UDim2.fromScale(1, 0.3),
		BackgroundTransparency = 1,
		TextColor3 = Color3.fromRGB(255, 100, 100),
	})
	local abilityPower = GameText({
		Name = `AbilityPower-{abilityKey}`,
		TextStateValue = Value(`Base Power: {abilityMeta.basePower}`),
		BackgroundTransparency = 1,
		TextColor3 = Color3.fromRGB(100, 255, 100),
		Size = UDim2.fromScale(1, 0.3),
	})
	return GamePanel({
		Name = `AbilityInfoPanel-{abilityKey}`,
		Size = UDim2.fromOffset(300, 200),
		Layout = Layout.VerticalSet(2),
		Content = {
			TopRow = GamePanel({
				Name = `TopRow-{abilityKey}`,
				Layout = Layout.HorizontalSet(2),
				Size = UDim2.fromScale(1, 0.3),
				Content = {
					AbilityIcon = abilityIcon,
					AbilityName = abilityName,
				},
			}),
			BottomRow = GamePanel({
				Name = `BottomRow-{abilityKey}`,
				Layout = Layout.VerticalSet(2),
				Size = UDim2.fromScale(1, 0.7),
				Content = {
					AbilityDescription = abilityDescription,
					AbilityCooldown = abilityCooldown,
					AbilityPower = abilityPower,
				},
			}),
		},
	})
end
return {
	AbilityInfoPanel = AbilityInfoPanel,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="403">
              <Properties>
                <string name="Name">AvatarBust</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local New = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").New
local _atoms = TS.import(script, script.Parent.Parent, "atoms")
local BorderImage = _atoms.BorderImage
local GamePanel = _atoms.GamePanel
local AvatarBust = function(userId, layoutOrder)
	local _fn = New("ImageLabel")
	local _object = {
		Name = "AvatarImage",
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundTransparency = 1,
	}
	local _left = "LayoutOrder"
	local _condition = layoutOrder
	if _condition == nil then
		_condition = 0
	end
	_object[_left] = _condition
	_object.Image = (Players:GetUserThumbnailAsync(userId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420))
	local avatarImage = _fn(_object)
	return GamePanel({
		Name = "AvatarBust",
		Size = UDim2.new(0, 100, 0, 100),
		BackgroundTransparency = 1,
		BorderImage = BorderImage.GothicMetal(),
		Content = {
			Image = avatarImage,
		},
	})
end
return {
	AvatarBust = AvatarBust,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="404">
              <Properties>
                <string name="Name">Button</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/ui/molecules/Button/index.ts
	 * @module      MoleculeButtonsIndex
	 * @layer       Client/UI/Molecules
	 * @description Barrel file exporting button molecules.
	 
]]
for _k, _v in TS.import(script, script, "HUDMenuButton") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "AbilityButton") or {} do
	exports[_k] = _v
end
return exports
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="405">
                <Properties>
                  <string name="Name">AbilityButton</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--[[
	*
	 * @file AbilityButton.ts
	 * @module AbilityButton
	 * @layer Client/UI/Organisms
	 * @description Contains buttons for various game events like spawning manifestations, increasing attributes, and creating gems
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 * @author Trembus
	 * @license MIT
	 * @since 0.2.0
	 * @lastUpdated 2025-06-25 by Trembus – Initial creation
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local New = _fusion.New
local Value = _fusion.Value
local OnEvent = _fusion.OnEvent
local Computed = _fusion.Computed
local Children = _fusion.Children
local AbilitiesMeta = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions").AbilitiesMeta
local GamePanel = TS.import(script, script.Parent.Parent.Parent, "atoms").GamePanel
local Layout = TS.import(script, script.Parent.Parent.Parent, "tokens").Layout
local BarMeter = TS.import(script, script.Parent.Parent, "FillBar").BarMeter
local CooldownTimer = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "classes", "CooldownTimer").CooldownTimer
local GameImages = TS.import(script, game:GetService("ReplicatedStorage"), "TS").GameImages
local ActivateAbility = TS.import(script, script.Parent.Parent.Parent.Parent, "network", "ClientDispatch").ActivateAbility
local function AbilityButton(props)
	local meta = AbilitiesMeta[props.abilityKey]
	local remaining = Value(0)
	-- Timer 
	local cooldownTimer = CooldownTimer.new(meta.cooldown)
	-- Cooldown Bar 
	local cooldownBar = BarMeter({
		Size = UDim2.fromOffset(64, 16),
		ProgressState = Computed(function()
			local progress = cooldownTimer.Progress:get()
			return progress
		end),
		Text = meta.displayName,
	})
	-- Image Button 
	local button = New("ImageButton")({
		Size = UDim2.fromOffset(64, 64),
		Image = GameImages.Ability.Background,
		BackgroundTransparency = 1,
		[Children] = {
			Icon = New("ImageLabel")({
				Size = UDim2.fromScale(0.8, 0.8),
				Position = UDim2.fromScale(0.1, 0.1),
				BackgroundTransparency = 1,
				Image = meta.iconId,
			}),
		},
		[OnEvent("Activated")] = function()
			if cooldownTimer.Progress:get() <= 0 then
				print(`Activating ability: {props.abilityKey}`)
				ActivateAbility(props.abilityKey)
				cooldownTimer:start()
			end
		end,
	})
	-- tick down timer using RunService or similar
	return GamePanel({
		Size = UDim2.fromOffset(80, 90),
		Layout = Layout.VerticalSet(2),
		Content = {
			ButtonIcon = button,
			CooldownBar = cooldownBar,
		},
	})
end
return {
	AbilityButton = AbilityButton,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="406">
                <Properties>
                  <string name="Name">HUDMenuButton</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        HUDMenuButton.ts
	 * @module      HUDMenuButton
	 * @layer       Client/UI/Molecules/Button
	 * @description Toggle button used in the HUD menu bar to show or hide screens.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @since        0.2.1
	 * @lastUpdated  2025-07-05 by Codex – Documentation cleanup
	 
]]
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Children = _fusion.Children
local Computed = _fusion.Computed
local New = _fusion.New
local OnEvent = _fusion.OnEvent
local Value = _fusion.Value
local GameImage = TS.import(script, script.Parent.Parent.Parent, "atoms").GameImage
local _shared = TS.import(script, game:GetService("ReplicatedStorage"), "TS")
local GameImages = _shared.GameImages
local MenuButtonImageMap = _shared.MenuButtonImageMap
local _states = TS.import(script, script.Parent.Parent.Parent.Parent, "states")
local ShowScreen = _states.ShowScreen
local ScreenState = _states.ScreenState
-- =============================== HUDMenuButton Component ====================== 
local HUDMenuButton = function(props)
	local SelectedState = ScreenState[props.ScreenKey] or Value(false)
	local Hovered = Value(false)
	local computedBGColor = Computed(function()
		if SelectedState:get() then
			return Color3.new(0.75, 0.29, 0.29)
		elseif Hovered:get() then
			return Color3.new(0.87, 0.94, 0.53)
		end
		return Color3.new(0.08, 0.04, 0.04)
	end)
	local _fn = New("ImageButton")
	local _object = {}
	local _left = "Name"
	local _condition = props.Name
	if _condition == nil then
		_condition = "ToggleMenuButton"
	end
	_object[_left] = _condition
	_object.Size = props.Size or UDim2.fromOffset(50, 50)
	_object.Image = GameImages.MenuButtonImage
	_object.BackgroundColor3 = computedBGColor
	_object[OnEvent("MouseEnter")] = function()
		return Hovered:set(true)
	end
	_object[OnEvent("MouseLeave")] = function()
		return Hovered:set(false)
	end
	_object[OnEvent("Activated")] = function()
		SelectedState:set(not SelectedState:get())
		if SelectedState:get() then
			ShowScreen(props.ScreenKey)
		else
			ScreenState[props.ScreenKey]:set(false)
		end
	end
	local _left_1 = Children
	local _object_1 = {}
	local _left_2 = "ButtonIcon"
	local _object_2 = {
		Name = "SoulForgeIcon",
	}
	local _left_3 = "Image"
	local _condition_1 = MenuButtonImageMap[props.ScreenKey]
	if _condition_1 == nil then
		_condition_1 = GameImages.MenuButtonImage
	end
	_object_2[_left_3] = _condition_1
	_object_2.Size = UDim2.fromScale(0.8, 0.8)
	_object_2.BackgroundTransparency = 1
	_object_2.Position = UDim2.fromScale(0.5, 0.5)
	_object_2.AnchorPoint = Vector2.new(0.5, 0.5)
	_object_2.ImageColor3 = Color3.new(1, 1, 1)
	_object_1[_left_2] = GameImage(_object_2)
	_object[_left_1] = _object_1
	local button = _fn(_object)
	return button
end
return {
	HUDMenuButton = HUDMenuButton,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="407">
                <Properties>
                  <string name="Name">PanelSelector</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Children = _fusion.Children
local Value = _fusion.Value
local EquipmentSlotMeta = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "PanelSlots", "Equipment").EquipmentSlotMeta
local _atoms = TS.import(script, script.Parent.Parent.Parent, "atoms")
local GameButton = _atoms.GameButton
local GameText = _atoms.GameText
--[[
	*
	 * @file        src/client/ui/molecules/PanelSelector.ts
	 * @module      PanelSelector
	 * @layer       Client/UI/Molecules
	 * @description Rectangular panel with an imagebutton that opens a grid of selectable items. Once selected, the panel displays the selected item and its metadata.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-07-02 by Codex – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local PanelSelector = function(props)
	local SelectorMetaData = EquipmentSlotMeta[props.SelectorKey]
	local CategoryText = GameText({
		TextStateValue = Value(SelectorMetaData.displayName),
		TextSize = 14,
		TextColor3 = Color3.fromRGB(255, 255, 255),
		TextXAlignment = Enum.TextXAlignment.Left,
		TextYAlignment = Enum.TextYAlignment.Top,
		Size = UDim2.new(1, -10, 1, -10),
		Position = UDim2.new(0, 5, 0, 5),
		BackgroundTransparency = 1,
		Font = Enum.Font.Gotham,
	})
	local SelectorButton = GameButton({
		Name = `{props.SelectorKey}SelectorButton`,
		Size = UDim2.new(1, 0, 0, 50),
		BackgroundColor3 = Color3.fromRGB(50, 50, 50),
		BorderSizePixel = 0,
		Image = SelectorMetaData.iconId,
		ImageColor3 = Color3.fromRGB(255, 255, 255),
		[Children] = {
			CategoryText = CategoryText,
		},
	})
	return SelectorButton
end
return {
	PanelSelector = PanelSelector,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="408">
              <Properties>
                <string name="Name">Container</string>
              </Properties>
              <Item class="ModuleScript" referent="409">
                <Properties>
                  <string name="Name">InventoryGrid</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        InventoryGrid.ts
	 * @module      InventoryGrid
	 * @layer       Client/Organisms
	 * @description Placeholder grid container for inventory slots.
	 
]]
local ForPairs = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").ForPairs
local _atoms = TS.import(script, script.Parent.Parent.Parent, "atoms")
local GamePanel = _atoms.GamePanel
local GemSlot = _atoms.GemSlot
local Layout = TS.import(script, script.Parent.Parent.Parent, "tokens").Layout
local InventoryGrid = function(props)
	return GamePanel({
		Name = "InventoryGrid",
		Scrolling = true,
		Layout = Layout.Grid(5, UDim2.fromOffset(70, 70)),
		Content = {
			Slots = ForPairs(props.items, function(id, data)
				return id, GemSlot({
					Name = `Slot-{id}`,
					Icon = data.icon,
					Rarity = data.rarity,
				})
			end),
		},
	})
end
return {
	InventoryGrid = InventoryGrid,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="410">
              <Properties>
                <string name="Name">CountdownTimer</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        CountdownTimer.ts
	 * @module      CountdownTimer
	 * @layer       Client/UI/Molecules
	 * @description Displays a stylized countdown value for battle rooms.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-07-02 by Codex – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Computed = _fusion.Computed
local Value = _fusion.Value
local GameText = TS.import(script, script.Parent.Parent, "atoms").GameText
local function CountdownTimer(props)
	local text = Computed(function()
		return `Battle starts in: {props.remaining:get()}s`
	end)
	return GameText({
		Name = "CountdownTimer",
		TextStateValue = Value(text:get()),
		TextSize = 28,
	})
end
return {
	CountdownTimer = CountdownTimer,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="411">
              <Properties>
                <string name="Name">FillBar</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, script, "BarMeter") or {} do
	exports[_k] = _v
end
return exports
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="412">
                <Properties>
                  <string name="Name">BarMeter</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        BarMeter.ts
	 * @module      BarMeter
	 * @layer       Client/UI/Molecules
	 * @description Simple horizontal progress bar used for capacity meters.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-07-01 by Codex – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Children = _fusion.Children
local New = _fusion.New
local Value = _fusion.Value
local Computed = _fusion.Computed
local _atoms = TS.import(script, script.Parent.Parent.Parent, "atoms")
local BorderImage = _atoms.BorderImage
local GamePanel = _atoms.GamePanel
local GameText = _atoms.GameText
local ComponentSizes = TS.import(script, game:GetService("ReplicatedStorage"), "Constants").ComponentSizes
local function BarMeter(props)
	local _condition = props.Text
	if _condition == nil then
		_condition = "Bar Meter"
	end
	local TextValue = Value(_condition)
	-- Fill Bar 
	local _fn = New("Frame")
	local _object = {
		Name = "FillBar",
		Size = Computed(function()
			local _result = props.ProgressState
			if _result ~= nil then
				_result = _result:get()
			end
			local _condition_1 = _result
			if _condition_1 == nil then
				_condition_1 = 0
			end
			local progress = _condition_1
			return UDim2.new(progress, 0, 1, 0)
		end),
		ZIndex = 90,
	}
	local _left = Children
	local _object_1 = {}
	local _left_1 = "Gradient"
	local _condition_1 = props.Gradient
	if _condition_1 == nil then
		_condition_1 = {}
	end
	_object_1[_left_1] = _condition_1
	_object[_left] = _object_1
	local fillBar = _fn(_object)
	-- Text Label 
	local TextLabel = GameText({
		TextStateValue = TextValue,
		Size = UDim2.fromScale(0.9, 0.9),
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5, 0, 0.5, 0),
		TextScaled = true,
		TextColor3 = Color3.fromRGB(255, 255, 255),
		ZIndex = 100,
	})
	-- Container 
	local container = GamePanel({
		Name = "BarMeter",
		Size = props.Size or ComponentSizes.ResourceBar,
		AnchorPoint = props.AnchorPoint or Vector2.new(0.5, 0.5),
		Position = props.Position or UDim2.new(0.5, 0, 0.5, 0),
		BorderImage = BorderImage.GothicMetal(),
		Content = {
			FillBar = fillBar,
			Text = TextLabel,
		},
	})
	return container
end
return {
	BarMeter = BarMeter,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="413">
              <Properties>
                <string name="Name">GameWindow</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        GameWindow.ts
	 * @module      GameWindow
	 * @layer       Client/UI/Molecules
	 * @description Panel-based window component with a title bar.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-07-02 by Codex – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Children = _fusion.Children
local New = _fusion.New
local OnEvent = _fusion.OnEvent
local GamePanel = TS.import(script, script.Parent.Parent, "atoms").GamePanel
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local GameImages = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets").GameImages
local ScreenState = TS.import(script, script.Parent.Parent.Parent, "states").ScreenState
local Padding = TS.import(script, script.Parent.Parent, "tokens").Padding
local ComponentSizes = TS.import(script, game:GetService("ReplicatedStorage"), "Constants").ComponentSizes
local function GameWindow(props)
	local _condition = props.Name
	if _condition == nil then
		_condition = "GameWindow"
	end
	props.Name = _condition
	props.Size = props.Size or ComponentSizes.HUDPanel
	local _condition_1 = props.Title
	if _condition_1 == nil then
		_condition_1 = `{props.ScreenKey} Window`
	end
	props.Title = _condition_1
	props.AnchorPoint = props.AnchorPoint or Vector2.new(0.5, 0.5)
	props.Position = props.Position or UDim2.fromScale(0.5, 0.5)
	props.Parent = props.Parent or Players.LocalPlayer:WaitForChild("PlayerGui")
	-- Title Bar 
	local titleBar = New("TextLabel")({
		Name = "TitleText",
		Size = UDim2.fromScale(1, 0.1),
		Position = UDim2.fromScale(0, 0),
		Text = props.Title,
		BackgroundTransparency = 0.95,
		TextColor3 = Color3.fromRGB(255, 255, 255),
		TextStrokeColor3 = Color3.fromRGB(0, 0, 0),
		TextStrokeTransparency = 0.5,
		TextSize = 25,
		Font = Enum.Font.SourceSansBold,
		TextXAlignment = Enum.TextXAlignment.Center,
		TextYAlignment = Enum.TextYAlignment.Center,
		[Children] = {},
	})
	-- Window Content 
	local windowContent = GamePanel({
		Name = "WindowContent",
		Size = UDim2.fromScale(1, 0.9),
		Position = UDim2.fromScale(0, 0.1),
		BackgroundTransparency = 0.1,
		Padding = Padding(4),
		BorderSizePixel = 0,
		ClipsDescendants = true,
		Content = {
			ContainerContents = props.Content or {},
		},
	})
	-- Window Container 
	local windowContainer = New("Frame")({
		Name = "WindowContainer",
		Size = props.Size,
		Position = props.Position,
		AnchorPoint = props.AnchorPoint,
		BackgroundTransparency = 0.2,
		[Children] = {
			Corner = New("UICorner")({
				CornerRadius = UDim.new(0, 5),
			}),
			TitleBar = titleBar,
			WindowContent = windowContent,
			CloseButton = New("ImageButton")({
				Name = "CloseButton",
				Size = UDim2.fromOffset(30, 30),
				AnchorPoint = Vector2.new(0.5, 0.5),
				Position = UDim2.fromScale(1, 0),
				BackgroundTransparency = 1,
				Image = GameImages.Control.Close,
				[OnEvent("Activated")] = function()
					return ScreenState[props.ScreenKey]:set(false)
				end,
			}),
		},
	})
	-- Screen GUI 
	local screenGUI = New("ScreenGui")({
		Name = props.Name,
		Parent = props.Parent,
		ResetOnSpawn = false,
		DisplayOrder = 1,
		Enabled = ScreenState[props.ScreenKey],
		[Children] = {
			WindowContainer = windowContainer,
		},
	})
	return screenGUI
end
return {
	GameWindow = GameWindow,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="414">
              <Properties>
                <string name="Name">SettingListItem</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        SettingListItem.ts
	 * @module      SettingListItem
	 * @layer       Client/UI/Molecules
	 * @description Theme-aware list item for modifying a player setting.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
-- -------------- Imports ----------------------------------------------------- //
local Value = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").Value
local _atoms = TS.import(script, script.Parent.Parent, "atoms")
local GamePanel = _atoms.GamePanel
local GameButton = _atoms.GameButton
local GameText = _atoms.GameText
local _tokens = TS.import(script, script.Parent.Parent, "tokens")
local Layout = _tokens.Layout
local Padding = _tokens.Padding
local SettingsMeta = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "ProfileDefinitions", "Settings").SettingsMeta
-- -------------- Props ------------------------------------------------------- //
-- -------------- Component --------------------------------------------------- //
local SettingListItem = function(props)
	local meta = SettingsMeta[props.SettingKey]
	local ContainerSize = UDim2.new(1, 0, 0, 50)
	local newContainer = GamePanel({
		Name = "SettingListItemContainer",
		Size = props.Size or ContainerSize,
		Layout = Layout.HorizontalSet(2),
		Padding = Padding(4),
		Content = {
			Title = GameText({
				Name = "SettingTitle",
				TextStateValue = Value(meta.displayName),
				TextSize = 14,
				Size = UDim2.fromScale(0.4, 1),
				BackgroundTransparency = 1,
				LayoutOrder = 1,
				TextXAlignment = Enum.TextXAlignment.Left,
			}),
			Control = GameButton({
				Name = "SettingControl",
				Size = UDim2.fromScale(0.6, 1),
				BackgroundTransparency = 0.3,
				LayoutOrder = 2,
				OnClick = function()
					print("SettingControl Clicked", props.SettingKey, props.Value:get())
					if meta.controlType == "boolean" then
						local newValue = not (props.Value:get())
						props.Value:set(newValue)
						local _result = props.OnChanged
						if _result ~= nil then
							_result(newValue)
						end
					elseif meta.controlType == "string" then
						-- Handle string input, e.g., open a text input dialog
						local newValue = "New Value"
						props.Value:set(newValue)
						local _result = props.OnChanged
						if _result ~= nil then
							_result(newValue)
						end
					end
				end,
			}),
		},
	})
	local control
	-- if (meta.controlType === "boolean") {
	-- 	const label = Computed(() => ((props.Value.get() as boolean) ? "On" : "Off"));
	-- 	control = GameButton({
	-- 		Name: "ToggleButton",
	-- 		Size: UDim2.fromOffset(60, 24),
	-- 		OnClick: () => {
	-- 			const newValue = !(props.Value.get() as boolean);
	-- 			props.Value.set(newValue);
	-- 			props.OnChanged?.(newValue);
	-- 		},
	-- 		[Children]: {
	-- 			Label: GameText({
	-- 				Name: "ToggleLabel",
	-- 				TextStateValue: label as unknown as Value<string>,
	-- 				TextSize: 14,
	-- 			}),
	-- 		},
	-- 	});
	-- } else {
	-- 	control = New("TextBox")({
	-- 		Name: "TextInput",
	-- 		Size: UDim2.fromOffset(120, 24),
	-- 		Text: props.Value as Value<string>,
	-- 		BackgroundTransparency: 0.3,
	-- 		[OnChange("Text")]: (txt: string) => {
	-- 			props.Value.set(txt);
	-- 			props.OnChanged?.(txt);
	-- 		},
	-- 	});
	-- }
	return newContainer
end
return {
	SettingListItem = SettingListItem,
}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="415">
            <Properties>
              <string name="Name">organisms</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, script, "ResourceBar") or {} do
	exports[_k] = _v
end
--export * from "./InventoryGrid";
for _k, _v in TS.import(script, script, "ButtonBars", "EventButtons") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "CharacterInfoCard") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "ButtonBars") or {} do
	exports[_k] = _v
end
return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="416">
              <Properties>
                <string name="Name">ButtonBars</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, script, "AdminBar") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "AbilityBar") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "EventButtons") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "HUDMenuBar") or {} do
	exports[_k] = _v
end
return exports
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="417">
                <Properties>
                  <string name="Name">AbilityBar</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--[[
	*
	 * @file        AbilityBar.ts
	 * @module      AbilityBar
	 * @layer       Client/UI/Organisms
	 * @description Contains buttons for various game events like spawning manifestations, increasing attributes, and creating gems
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 * @author Trembus
	 * @license MIT
	 * @since 0.2.0
	 * @lastUpdated 2025-06-27 by Trembus – Initial creation
	 * @dependencies
	 *  @rbxts/fusion ^0.4.0
	 * * @remarks
	 *  This file defines the AbilityBar component, which displays a set of ability buttons for the player to interact with.
	 *  Each button corresponds to an ability and includes a cooldown bar.
	 *  The buttons are dynamically generated based on the abilities available to the player.
	 *  The component uses Fusion for reactive UI updates and layout management.
	 *  It is designed to be flexible and easily extendable for future abilities.
	 *  The component is styled using the GamePanel atom for consistent UI appearance.
	 *  The buttons are arranged horizontally with a set layout and spacing.
	 *  The component is intended to be used within the player HUD screen, providing quick access to
	 *  abilities during gameplay.
	 
]]
local Computed = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").Computed
local PlayerState = TS.import(script, script.Parent.Parent.Parent.Parent, "states", "PlayerState").default
local GamePanel = TS.import(script, script.Parent.Parent.Parent, "atoms").GamePanel
local AbilityButton = TS.import(script, script.Parent.Parent.Parent, "molecules").AbilityButton
local Layout = TS.import(script, script.Parent.Parent.Parent, "tokens").Layout
local AbilityBarComponent
local AbilityBarClass
do
	AbilityBarClass = setmetatable({}, {
		__tostring = function()
			return "AbilityBarClass"
		end,
	})
	AbilityBarClass.__index = AbilityBarClass
	function AbilityBarClass.new(...)
		local self = setmetatable({}, AbilityBarClass)
		return self:constructor(...) or self
	end
	function AbilityBarClass:constructor()
		self.DestroyComponent = function(x)
			print("Destroying AbilityBar component")
			if not x then
				print("Attempted to destroy a null AbilityBar component.")
				return nil
			end
			--x.Destroy();
		end
		self.EquippedAbilities = PlayerState:getInstance().Abilities
		self.Bar = Computed(function()
			local _exp = self.EquippedAbilities
			-- ▼ ReadonlyArray.map ▼
			local _newValue = table.create(#_exp)
			local _callback = function(ability)
				return ability:get()
			end
			for _k, _v in _exp do
				_newValue[_k] = _callback(_v, _k - 1, _exp)
			end
			-- ▲ ReadonlyArray.map ▲
			print("Rendering AbilityBar:", _newValue)
			local abilities = {}
			local _exp_1 = self.EquippedAbilities
			-- ▼ ReadonlyArray.forEach ▼
			local _callback_1 = function(ability)
				local _arg0 = ability:get()
				table.insert(abilities, _arg0)
			end
			for _k, _v in _exp_1 do
				_callback_1(_v, _k - 1, _exp_1)
			end
			-- ▲ ReadonlyArray.forEach ▲
			return AbilityBarComponent(abilities)
		end, function(x)
			return self.DestroyComponent(x)
		end)
	end
	function AbilityBarClass:getBar()
		return self.Bar
	end
	function AbilityBarClass:getAbilityArray()
		local _exp = self.EquippedAbilities
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_exp)
		local _callback = function(ability)
			return ability:get()
		end
		for _k, _v in _exp do
			_newValue[_k] = _callback(_v, _k - 1, _exp)
		end
		-- ▲ ReadonlyArray.map ▲
		return _newValue
	end
	function AbilityBarClass:getAbilityStateArray()
		return self.EquippedAbilities
	end
	function AbilityBarClass:activateAbility(abilityKey)
		-- This method can be used to activate an ability when the button is clicked.
		print(`Activating ability: {abilityKey}`)
		-- Here you would typically trigger the ability's effect, such as spawning a manifestation or
	end
end
function AbilityBarComponent(abilityKeyArray)
	local _object = {
		Name = "AbilityBar",
		Size = UDim2.new(1, 0, 0, 100),
		AnchorPoint = Vector2.new(0.5, 1),
		Position = UDim2.new(0.5, 0, 1, -10),
		BackgroundTransparency = 0.5,
		Layout = Layout.HorizontalSet(10),
	}
	local _left = "Content"
	local _object_1 = {}
	local _left_1 = "Buttons"
	-- ▼ ReadonlyArray.map ▼
	local _newValue = table.create(#abilityKeyArray)
	local _callback = function(ability)
		return AbilityButton({
			abilityKey = ability,
		})
	end
	for _k, _v in abilityKeyArray do
		_newValue[_k] = _callback(_v, _k - 1, abilityKeyArray)
	end
	-- ▲ ReadonlyArray.map ▲
	_object_1[_left_1] = _newValue
	_object[_left] = _object_1
	return GamePanel(_object)
end
return {
	AbilityBarClass = AbilityBarClass,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="418">
                <Properties>
                  <string name="Name">AbilityBar.spec</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/testez/globals" />
local Value = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").Value
local PlayerState = TS.import(script, script.Parent.Parent.Parent.Parent, "states", "PlayerState").default
local AbilityBarClass = TS.import(script, script.Parent.Parent).AbilityBarClass
return function()
	describe("AbilityBar UI", function()
		it("shows equipped abilities in order", function()
			local bar = AbilityBarClass.new()
			PlayerState:getInstance().Abilities = { Value("fireball"), Value("earthquake"), Value("melee") }
			expect(bar:activateAbility("earthquake")).to.be.ok()
			expect(bar:getAbilityArray()).to.equal({ "fireball", "earthquake", "melee" })
			expect(bar:getAbilityStateArray()[1]:get()).to.equal("fireball")
			PlayerState:getInstance().Abilities = { Value("fireball") }
			expect(bar:getAbilityArray()).to.equal({ "fireball" })
			expect(bar:getAbilityStateArray()[1]:get()).to.equal("fireball")
			expect(bar:getBar():get()).to.be.ok()
			bar:activateAbility("fireball")
		end)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="419">
                <Properties>
                  <string name="Name">AdminBar</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--[[
	*
	 * @file        AdminBar.ts
	 * @module      AdminBar
	 * @layer       Client/UI/Organisms
	 * @description Contains buttons for various admin actions like spawning NPCs, managing players, and viewing analytics
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 * @author Trembus
	 * @license MIT
	 * @since 0.2.0
	 * @lastUpdated 2025-07-02 by Trembus – Initial creation
	 * @dependencies
	 *  @rbxts/fusion ^0.4.0
	
	 
]]
local _atoms = TS.import(script, script.Parent.Parent.Parent, "atoms")
local GameButton = _atoms.GameButton
local GamePanel = _atoms.GamePanel
local Layout = TS.import(script, script.Parent.Parent.Parent, "tokens").Layout
local _shared = TS.import(script, game:GetService("ReplicatedStorage"), "TS")
local GameImages = _shared.GameImages
local TestNetwork = _shared.TestNetwork
-- =============================================== Client to Server Events =============================================== 
local SpawnNPCEvent = TestNetwork.Client:Get("SPAWN_NPC")
-- =============================================== Admin Bar =============================================== 
local function AdminBar(visibleState)
	local adminButtons = {
		SpawnNPCButton = GameButton({
			Icon = GameImages.DefaultUnassigned,
			Name = "SpawnNPCButton",
			Size = UDim2.new(0, 50, 0, 50),
			OnClick = function()
				print("Spawning Mecha Monkey NPC")
				-- Logic to spawn an NPC
				SpawnNPCEvent:SendToServer("MECHA_MONKEY")
			end,
		}),
	}
	return GamePanel({
		Name = "AdminBar",
		Size = UDim2.new(1, 0, 0, 100),
		AnchorPoint = Vector2.new(0.5, 1),
		Position = UDim2.new(0.5, 0, 1, -110),
		BackgroundTransparency = 0.5,
		Layout = Layout.HorizontalSet(10),
		Content = {
			Buttons = adminButtons,
		},
	})
end
return {
	AdminBar = AdminBar,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="420">
                <Properties>
                  <string name="Name">EventButtons</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--[[
	*
	 * @file EventButtons.tsx
	 * @module EventButtons
	 * @layer Client/UI/Organisms
	 * @description Contains buttons for various game events like spawning manifestations, increasing attributes, and creating gems
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 * @author Trembus
	 * @license MIT
	 * @since 0.2.0
	 * @lastUpdated 2025-06-25 by Trembus – Initial creation
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local _atoms = TS.import(script, script.Parent.Parent.Parent, "atoms")
local GamePanel = _atoms.GamePanel
local GameButton = _atoms.GameButton
local _shared = TS.import(script, game:GetService("ReplicatedStorage"), "TS")
local GameImages = _shared.GameImages
local Network = _shared.Network
local Layout = TS.import(script, script.Parent.Parent.Parent, "tokens").Layout
--================================================ Network Definitions =============================================
local SpawnManifestationEvent = Network.Client:Get("SpawnManifestation")
local IncreaseAttributeEvent = Network.Client:Get("IncreaseAttribute")
local AddGemEvent = Network.Client:Get("AddGem")
--================================================ UI Components ==================================================
local EventButtons = function()
	local container = GamePanel({
		Name = "EventButtons",
		Size = UDim2.fromOffset(100, 400),
		DragEnabled = true,
		Scrolling = true,
		Layout = Layout.VerticalScroll(3),
		Content = {
			SpawnManifestationButton = GameButton({
				Name = "SpawnManifestationButton",
				Image = GameImages.Currency.Tombs,
				OnClick = function()
					local formId = "exampleForm"
					local abilityId = "exampleAbility"
					local bonusId = "exampleBonus"
					SpawnManifestationEvent:SendToServer(formId, abilityId, bonusId)
				end,
			}),
			IncreaseAttributeButton = GameButton({
				Name = "IncreaseAttributeButton",
				Image = GameImages.Attributes.Dexterity,
				OnClick = function()
					local attributeKey = "str"
					local amount = 1
					IncreaseAttributeEvent:SendToServer(attributeKey, amount)
				end,
			}),
			CreateGemButton = GameButton({
				Name = "CreateGemButton",
				Image = GameImages.Gems.Colorable,
				OnClick = function()
					local gemId = "exampleGem"
					AddGemEvent:SendToServer(gemId)
				end,
			}),
		},
	})
	return container
end
return {
	EventButtons = EventButtons,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="421">
                <Properties>
                  <string name="Name">HUDMenuBar</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        HUDMenuBar.ts
	 * @module      HUDMenuBar
	 * @layer       Client/Organisms
	 * @description Horizontal container of HUD menu buttons.
	 
]]
local ForValues = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").ForValues
local Layout = TS.import(script, script.Parent.Parent.Parent, "tokens").Layout
local GamePanel = TS.import(script, script.Parent.Parent.Parent, "atoms").GamePanel
local HUDMenuButton = TS.import(script, script.Parent.Parent.Parent, "molecules").HUDMenuButton
local _assets = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets")
local GameImages = _assets.GameImages
local MenuButtonImageMap = _assets.MenuButtonImageMap
local ScreenOrder = TS.import(script, script.Parent.Parent.Parent.Parent, "states").ScreenOrder
local HUDMenuBar = function(props)
	local HUDMenuButtons = ForValues(props.ScreenStateKeys, function(value)
		local _object = {
			ScreenKey = value,
			Name = `{value}Button`,
		}
		local _left = "LayoutOrder"
		local _condition = ScreenOrder[value]
		if _condition == nil then
			_condition = 0
		end
		_object[_left] = _condition
		local _left_1 = "Image"
		local _condition_1 = MenuButtonImageMap[value]
		if _condition_1 == nil then
			_condition_1 = GameImages.MenuButtonImage
		end
		_object[_left_1] = _condition_1
		return HUDMenuButton(_object)
	end)
	local container = GamePanel({
		Name = "HUDMenuBar",
		Size = UDim2.new(0, 380, 0, 56),
		BackgroundTransparency = 0.5,
		Layout = Layout.HorizontalSet(5),
		Content = {
			Buttons = HUDMenuButtons,
		},
	})
	return container
end
return {
	HUDMenuBar = HUDMenuBar,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="422">
                <Properties>
                  <string name="Name">StatusPanel</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Fusion = _fusion
local ForValues = _fusion.ForValues
local Padding = TS.import(script, script.Parent.Parent.Parent, "tokens").Padding
local _binding = Fusion
local New = _binding.New
local Children = _binding.Children
local Value = _binding.Value
local Computed = _binding.Computed
local Spring = _binding.Spring
local ForPairs = _binding.ForPairs
local OnEvent = _binding.OnEvent
-- ==== Atoms ================================================================
local StatusIcon = function(icon)
	return New("ImageLabel")({
		BackgroundTransparency = 1,
		Image = icon,
		Size = UDim2.fromScale(0.2, 1),
		[Children] = { New("UICorner")({}), New("UIAspectRatioConstraint")({}) },
	})
end
local StatusText = function(display)
	return New("TextLabel")({
		BackgroundTransparency = 1,
		FontFace = Font.new("rbxasset://fonts/families/Merriweather.json"),
		RichText = true,
		Size = UDim2.fromOffset(200, 50),
		Text = display,
		TextColor3 = Color3.fromRGB(244, 244, 244),
		TextSize = 17,
		TextStrokeTransparency = 0,
		[Children] = { New("UIFlexItem")({
			FlexMode = Enum.UIFlexMode.Shrink,
		}) },
	})
end
local Badge = function(count, toggle)
	return New("ImageButton")({
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.fromOffset(120, 0),
		Size = UDim2.fromOffset(32, 24),
		AutoButtonColor = true,
		BackgroundTransparency = 1,
		Image = "rbxassetid://8672979592",
		[OnEvent("Activated")] = toggle,
		[Children] = { New("TextLabel")({
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.fromScale(0.5, 0.5),
			BackgroundTransparency = 1,
			Font = Enum.Font.GothamBlack,
			TextColor3 = Color3.fromRGB(255, 255, 255),
			TextSize = 18,
			Text = Computed(function()
				return tostring(count:get())
			end),
		}) },
	})
end
-- ==== Molecule =============================================================
local StatusRow = function(effect)
	local display = Computed(function()
		return `{effect.meta.displayName} (<font color="#FF7800">{effect.startTime - tick()}</font>s)`
	end)
	return New("Frame")({
		Name = effect.meta.displayName,
		Size = UDim2.fromScale(1, 0.2),
		AutomaticSize = Enum.AutomaticSize.Y,
		BackgroundColor3 = Color3.fromRGB(242, 255, 161),
		BackgroundTransparency = 0.7,
		BorderSizePixel = 0,
		[Children] = { StatusIcon(effect.meta.iconId), StatusText(display), Padding(2), New("UIListLayout")({
			FillDirection = Enum.FillDirection.Horizontal,
			SortOrder = Enum.SortOrder.LayoutOrder,
			ItemLineAlignment = Enum.ItemLineAlignment.Center,
			HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly,
		}) },
	})
end
-- ==== Organism =============================================================
local StatusPanel = function(statusArray)
	local expanded = Value(false)
	-- Sizes (animated)
	local height = Spring(Computed(function()
		return if expanded:get() then 200 else 20
	end), 40, 1)
	local clipDescendants = Computed(function()
		return not expanded:get()
	end)
	-- Derived values
	local count = Computed(function()
		return #statusArray:get()
	end)
	-- Toggle helper
	local toggle = function()
		return expanded:set(not expanded:get())
	end
	return New("Frame")({
		Size = Computed(function()
			return UDim2.fromOffset(120, height:get())
		end),
		AnchorPoint = Vector2.new(1, 0),
		Position = Computed(function()
			return UDim2.fromScale(1, 0.5)
		end),
		Name = "StatusPanel",
		BackgroundTransparency = 1,
		ClipsDescendants = clipDescendants,
		[Children] = { New("ScrollingFrame")({
			Name = "StatusList",
			Size = UDim2.fromScale(1, 1),
			BackgroundTransparency = 1,
			ScrollBarThickness = 4,
			AutomaticCanvasSize = Enum.AutomaticSize.Y,
			ScrollingDirection = Enum.ScrollingDirection.Y,
			Visible = expanded,
			[Children] = { ForValues(statusArray, function(effect)
				return StatusRow(effect)
			end), New("UIListLayout")({
				FillDirection = Enum.FillDirection.Vertical,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}) },
		}), Badge(count, toggle) },
	})
end
return {
	StatusPanel = StatusPanel,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="423">
              <Properties>
                <string name="Name">CharacterInfoCard</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local GamePanel = TS.import(script, script.Parent.Parent, "atoms").GamePanel
local ResourceBar = TS.import(script, script.Parent, "ResourceBar").ResourceBar
local Layout = TS.import(script, script.Parent.Parent, "tokens").Layout
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local AvatarBust = TS.import(script, script.Parent.Parent, "molecules", "AvatarBust").AvatarBust
local CharacterInfoCard = function()
	-- Avatar Bust 
	local Avatar = AvatarBust(Players.LocalPlayer.UserId)
	local AvatarWidth = Avatar.Size.X.Offset
	-- Resource Bars 
	local ResourceBarContainer = GamePanel({
		Name = "ResourceBars",
		Size = UDim2.new(1, -AvatarWidth, 1, 0),
		Layout = Layout.VerticalSet(),
		LayoutOrder = 2,
		Content = {
			HealthBar = ResourceBar("Health"),
			ManaBar = ResourceBar("Mana"),
			StaminaBar = ResourceBar("Stamina"),
		},
		BackgroundColor3 = Color3.fromRGB(30, 30, 30),
		BorderSizePixel = 0,
	})
	-- Organism 
	local organism = GamePanel({
		Name = "CharacterInfoCard",
		Size = UDim2.new(0, 300, 0, 105),
		BackgroundTransparency = 0.5,
		BorderSizePixel = 0,
		Layout = Layout.HorizontalSet(0),
		LayoutOrder = 0,
		Content = {
			Avatar = AvatarBust(Players.LocalPlayer.UserId),
			ResourceBars = ResourceBarContainer,
		},
	})
	return organism
end
return {
	CharacterInfoCard = CharacterInfoCard,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="424">
              <Properties>
                <string name="Name">CollapsibleStatusPanel</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--[[
	*
	 * @file CollapsibleStatusPanel.ts
	 * @description This file defines the CollapsibleStatusPanel component, which is used to display a
	 * collapsible panel for showing the status of various game elements. It includes a header with a
	 * title and a button to toggle the panel's visibility, as well as a content area that
	 * displays the status information.
	 * @remarks This component is part of the game's user interface and is designed to be used in
	 * conjunction with other UI components. It is built using the Roblox UI framework and follows
	 * best practices for performance and usability.
	 
]]
local _fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Children = _fusion.Children
local New = _fusion.New
local Value = _fusion.Value
local Layout = TS.import(script, script.Parent.Parent, "tokens").Layout
local StatusRowItem = function(statusEffect)
	local currentTIme = os.time()
	local startTime = statusEffect.startTime
	local timeRemaining = Value(statusEffect.meta.duration - startTime)
	local container = New("Frame")({
		Size = UDim2.new(1, 0, 0, 30),
		BackgroundColor3 = Color3.new(0.2, 0.2, 0.2),
		BackgroundTransparency = 0.5,
		[Children] = {
			Layout = Layout.HorizontalScroll(),
			StatusIcon = New("ImageLabel")({
				Name = "StatusIcon",
				Size = UDim2.new(0, 30, 0, 30),
				BackgroundTransparency = 1,
				Image = statusEffect.meta.iconId,
			}),
			Label = New("TextLabel")({
				Name = "Status Description",
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Text = statusEffect.meta.description,
			}),
		},
	})
	return container
end
return {
	StatusRowItem = StatusRowItem,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="425">
              <Properties>
                <string name="Name">ResourceBar</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        ResourceBars.ts                     ◄────── must match filename
	 * @module      ResourceBars                        ◄────── public import name
	 * @layer       Client/Organisms
	 * @description Composite organism that shows the
	 *              player's Health, Mana & Stamina.
	 *
	 * ╭───────────────────────────────────────────────╮
	 * │  Soul Steel · Coding Guide                   │
	 * │  Fusion v4 · Strict TS · ECS                 │
	 * ╰───────────────────────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-06-25 by Luminesa – Comment revamp
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
-- -------------- Imports ----------------------------------------------------- //
local GamePanel = TS.import(script, script.Parent.Parent, "atoms").GamePanel
local BarMeter = TS.import(script, script.Parent.Parent, "molecules").BarMeter
local PlayerState = TS.import(script, script.Parent.Parent.Parent, "states", "PlayerState").default
local ResourceMeta = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "Resources").ResourceMeta
-- -------------- Local helpers --------------------------------------------- //
local function ResourceBar(resourceKey)
	local playerState = PlayerState:getInstance()
	local state = playerState.Resources[resourceKey]
	local meta = ResourceMeta[resourceKey]
	local resourceBarContainer = GamePanel({
		Name = `{resourceKey}BarContainer`,
		Size = UDim2.fromScale(1, 0.3),
		LayoutOrder = meta.layoutOrder,
		Content = {
			FillBar = BarMeter({
				ProgressState = state.Percent,
				MaxValue = state.Max,
				Gradient = meta.gradient,
				Size = UDim2.fromScale(1, 1),
				Text = meta.displayName,
			}),
		},
	})
	return resourceBarContainer
end
return {
	ResourceBar = ResourceBar,
}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="426">
            <Properties>
              <string name="Name">screens</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, script, "CharacterScreen") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "GemForgeScreen") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "InventoryScreen") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "PlayerHUDScreen") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "QuestsScreen") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "SettingsScreen") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "ShopScreen") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "TeleportScreen") or {} do
	exports[_k] = _v
end
return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="427">
              <Properties>
                <string name="Name">CharacterScreen</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        CharacterScreen.ts
	 * @module      CharacterScreen
	 * @layer       Client/UI/Screens
	 * @description UI screen for viewing the player's character details.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-07-01 by Codex – Initial stub
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local GameWindow = TS.import(script, script.Parent.Parent, "molecules").GameWindow
local Key = "Character"
local CharacterScreen = function()
	return GameWindow({
		Name = `{Key}Screen`,
		ScreenKey = Key,
		Content = {},
	})
end
return {
	CharacterScreen = CharacterScreen,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="428">
              <Properties>
                <string name="Name">GemForgeScreen</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        GemForgeScreen.ts
	 * @module      GemForgeScreen
	 * @layer       Client/UI/Screens
	 * @description UI screen for forging manifestation gems.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-07-01 by Codex – Reconstructed screen
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local GameWindow = TS.import(script, script.Parent.Parent, "molecules").GameWindow
local GamePanel = TS.import(script, script.Parent.Parent, "atoms").GamePanel
local _tokens = TS.import(script, script.Parent.Parent, "tokens")
local Layout = _tokens.Layout
local Padding = _tokens.Padding
local Key = "GemForge"
local GemSlot = function(slotKey)
	local container = GamePanel({
		Name = `{Key}_{slotKey}Slot`,
		Size = UDim2.new(1, 0, 0, 100),
		Padding = Padding(5),
		Layout = Layout.HorizontalScroll(),
		BackgroundTransparency = 0,
		Content = {},
	})
	return container
end
local GemSlotContainer = function()
	local SubPanel = GamePanel({
		Name = `{Key}_SlotPanel`,
		Size = UDim2.new(0.5, 0, 1, 0),
		Padding = Padding(5),
		Layout = Layout.VerticalScroll(),
		BackgroundTransparency = 0.5,
		Content = {
			FormSlot = GemSlot("FORM"),
			AbilitySlot = GemSlot("ABILITY"),
			PhysicalSlot = GemSlot("PHYSICAL"),
			SummonSlot = GemSlot("SUMMON"),
		},
	})
	return SubPanel
end
local GemForgeScreen = function()
	return GameWindow({
		ScreenKey = Key,
		Name = `{Key}Screen`,
		Content = {
			SlotContainer = GemSlotContainer(),
		},
	})
end
return {
	GemForgeScreen = GemForgeScreen,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="429">
              <Properties>
                <string name="Name">InventoryScreen</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        InventoryScreen.ts
	 * @module      InventoryScreen
	 * @layer       Client/UI/Screens
	 * @description UI screen for managing the player's inventory.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-07-01 by Codex – Initial stub
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local GameWindow = TS.import(script, script.Parent.Parent, "molecules").GameWindow
local Key = "Inventory"
local InventoryScreen = function()
	return GameWindow({
		Name = `{Key}Screen`,
		ScreenKey = Key,
		Content = {},
	})
end
return {
	InventoryScreen = InventoryScreen,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="430">
              <Properties>
                <string name="Name">PlayerHUDScreen</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        PlayerHUDScreen.ts
	 * @module      PlayerHUDScreen
	 * @layer       Client/UI/Screens
	 * @description Primary heads-up display shown during gameplay.
	 
]]
local _atoms = TS.import(script, script.Parent.Parent, "atoms")
local GamePanel = _atoms.GamePanel
local GameScreen = _atoms.GameScreen
local _organisms = TS.import(script, script.Parent.Parent, "organisms")
local HUDMenuBar = _organisms.HUDMenuBar
local AbilityBarClass = _organisms.AbilityBarClass
local CharacterInfoCard = TS.import(script, script.Parent.Parent, "organisms").CharacterInfoCard
local _tokens = TS.import(script, script.Parent.Parent, "tokens")
local Layout = _tokens.Layout
local Padding = _tokens.Padding
local SCREEN_KEYS = TS.import(script, script.Parent.Parent.Parent, "states").SCREEN_KEYS
local AdminBar = TS.import(script, script.Parent.Parent, "organisms", "ButtonBars", "AdminBar").AdminBar
local Value = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").Value
local StatusPanel = TS.import(script, script.Parent.Parent, "organisms", "ButtonBars", "StatusPanel").StatusPanel
local PlayerState = TS.import(script, script.Parent.Parent.Parent, "states", "PlayerState").default
-- =============================================== Player HUD Screen ============================================= 
local _object = {
	CharacterInfoCard = CharacterInfoCard(),
}
local _left = "HUDMenuBar"
local _object_1 = {}
local _left_1 = "ScreenStateKeys"
local _array = {}
local _length = #_array
table.move(SCREEN_KEYS, 1, #SCREEN_KEYS, _length + 1, _array)
_object_1[_left_1] = _array
_object[_left] = HUDMenuBar(_object_1)
_object.CurrencyInfo = nil
local HudProps = _object
local PlayerHUDScreen = function()
	-- HUD Container 
	local HUDContainer = GamePanel({
		Name = "HUDContainer",
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundTransparency = 1,
		Padding = Padding(10),
		Content = {
			LeftPanel = GamePanel({
				Layout = Layout.VerticalScroll(5),
				Name = "LeftPanel",
				Size = UDim2.new(0.5, 0, 1, 0),
				BackgroundTransparency = 1,
				Content = {
					CharacterInfoCard = HudProps.CharacterInfoCard,
					MenuBar = HudProps.HUDMenuBar,
				},
			}),
			AbilityBar = AbilityBarClass.new():getBar(),
			AdminBar = AdminBar(Value(false)),
			StatusPanel = StatusPanel(PlayerState:getInstance().StatusEffects),
		},
	})
	-- Screen 
	return GameScreen({
		Name = "PlayerHUDScreen",
		Content = HUDContainer,
	})
end
return {
	PlayerHUDScreen = PlayerHUDScreen,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="431">
              <Properties>
                <string name="Name">QuestsScreen</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local GameWindow = TS.import(script, script.Parent.Parent, "molecules").GameWindow
local Key = "Quests"
local QuestsScreen = function()
	return GameWindow({
		Name = `{Key}Screen`,
		ScreenKey = Key,
		Content = {},
	})
end
return {
	QuestsScreen = QuestsScreen,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="432">
              <Properties>
                <string name="Name">SettingsScreen</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        SettingsScreen.ts
	 * @module      SettingsScreen
	 * @layer       Client/UI/Screens
	 * @description UI screen for adjusting player settings.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-07-01 by Codex – Initial stub
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local ForPairs = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").ForPairs
local _molecules = TS.import(script, script.Parent.Parent, "molecules")
local GameWindow = _molecules.GameWindow
local SettingListItem = _molecules.SettingListItem
local SettingsState = TS.import(script, script.Parent.Parent.Parent, "states").SettingsState
local SETTING_KEYS = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "definitions", "ProfileDefinitions", "Settings").SETTING_KEYS
local Layout = TS.import(script, script.Parent.Parent, "tokens").Layout
local Key = "Settings"
local SettingsScreen = function()
	local state = SettingsState:getInstance()
	local _array = {}
	local _length = #_array
	table.move(SETTING_KEYS, 1, #SETTING_KEYS, _length + 1, _array)
	local keys = _array
	local items = ForPairs(keys, function(index, key)
		return key, SettingListItem({
			SettingKey = key,
			Size = UDim2.new(1, 0, 0, 50),
			Value = state.Settings[key],
			LayoutOrder = index,
			OnChanged = function(val)
				return state:set(key, val)
			end,
		})
	end)
	return GameWindow({
		Name = `{Key}Screen`,
		ScreenKey = Key,
		Content = {
			Layout = Layout.VerticalSet(2),
			SettingItems = items,
		},
	})
end
return {
	SettingsScreen = SettingsScreen,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="433">
              <Properties>
                <string name="Name">ShopScreen</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        ShopScreen.ts
	 * @module      ShopScreen
	 * @layer       Client/UI/Screens
	 * @description UI screen for purchasing items from the shop.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-07-01 by Codex – Initial stub
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local GameWindow = TS.import(script, script.Parent.Parent, "molecules").GameWindow
local Key = "Shop"
local ShopScreen = function()
	return GameWindow({
		Name = `{Key}Screen`,
		ScreenKey = Key,
		Content = {},
	})
end
return {
	ShopScreen = ShopScreen,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="434">
              <Properties>
                <string name="Name">TeleportScreen</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        TeleportScreen.ts
	 * @module      TeleportScreen
	 * @layer       Client/UI/Screens
	 * @description UI screen for teleporting to different locations.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Codex
	 * @license      MIT
	 * @since        0.2.1
	 * @lastUpdated  2025-07-01 by Codex – Initial stub
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
local GameWindow = TS.import(script, script.Parent.Parent, "molecules").GameWindow
local Key = "Teleport"
local TeleportScreen = function()
	return GameWindow({
		Name = `{Key}Screen`,
		ScreenKey = Key,
		Content = {},
	})
end
return {
	TeleportScreen = TeleportScreen,
}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="435">
            <Properties>
              <string name="Name">tokens</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/ui/style/index.ts
	 * @module      StyleIndex
	 * @layer       Client/Style
	 * @description Barrel index file for the UI style tokens
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 *
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.2.0
	 * @lastUpdated  2025-06-23 by Trembus – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 
]]
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets", "gradients") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "layouts") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "padding") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "TS", "constants", "sizes") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "stroke") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "text") or {} do
	exports[_k] = _v
end
return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="436">
              <Properties>
                <string name="Name">audio</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
-- ================================================ Audio Tokens ================================ 
local _object = {}
local _left = "ZombieTheme"
local _object_1 = {}
local _left_1 = "BackgroundMusic"
local _exp = Instance.new("Sound")
_exp.SoundId = "rbxassetid://123456"
_object_1[_left_1] = (_exp.SoundId)
local _left_2 = "SuccessClick"
local _exp_1 = Instance.new("Sound")
_exp_1.SoundId = "rbxassetid://123456"
_object_1[_left_2] = (_exp_1.SoundId)
local _left_3 = "ErrorClick"
local _exp_2 = Instance.new("Sound")
_exp_2.SoundId = "rbxassetid://123456"
_object_1[_left_3] = (_exp_2.SoundId)
local _left_4 = "Damaged"
local _exp_3 = Instance.new("Sound")
_exp_3.SoundId = "rbxassetid://123456"
_object_1[_left_4] = (_exp_3.SoundId)
_object[_left] = _object_1
local _left_5 = "RobotTheme"
local _object_2 = {}
local _left_6 = "BackgroundMusic"
local _exp_4 = Instance.new("Sound")
_exp_4.SoundId = "rbxassetid://123456"
_object_2[_left_6] = (_exp_4.SoundId)
local _left_7 = "SuccessClick"
local _exp_5 = Instance.new("Sound")
_exp_5.SoundId = "rbxassetid://123456"
_object_2[_left_7] = (_exp_5.SoundId)
local _left_8 = "ErrorClick"
local _exp_6 = Instance.new("Sound")
_exp_6.SoundId = "rbxassetid://123456"
_object_2[_left_8] = (_exp_6.SoundId)
local _left_9 = "Damaged"
local _exp_7 = Instance.new("Sound")
_exp_7.SoundId = "rbxassetid://123456"
_object_2[_left_9] = (_exp_7.SoundId)
_object[_left_5] = _object_2
local AudioTokens = _object
return {
	AudioTokens = AudioTokens,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="437">
              <Properties>
                <string name="Name">color</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TextColors = {
	ZombieTheme = {
		TextDefault = Color3.new(0.65, 0.99, 0.09),
		TextStroke = Color3.new(0.11, 0, 0),
		TextHover = Color3.new(1, 1, 1),
		TextDisabled = Color3.new(0.5, 0.5, 0.5),
	},
	RobotTheme = {
		TextDefault = Color3.new(1, 1, 1),
		TextStroke = Color3.new(0.11, 0, 0),
		TextHover = Color3.new(1, 1, 1),
		TextDisabled = Color3.new(0.5, 0.5, 0.5),
	},
}
local PanelBackgroundColors = {
	ZombieTheme = {
		BackgroundColor = Color3.new(0, 0.08, 0.01),
		BackgroundHoverColor = Color3.new(0.04, 0.47, 0.38),
	},
	RobotTheme = {
		BackgroundColor = Color3.new(0.1, 0.1, 0.1),
		BackgroundHoverColor = Color3.new(0.2, 0.2, 0.2),
	},
}
local FillbarColors = {
	ZombieTheme = {
		Health = Color3.new(0.02, 0.16, 0.12),
		Mana = Color3.new(0.16, 0.93, 0.36),
		Stamina = Color3.new(0.15, 0.18, 0.01),
	},
	RobotTheme = {
		Health = Color3.new(0.41, 0.12, 0.4),
		Mana = Color3.new(0.1, 0.1, 0.8),
		Stamina = Color3.new(0.1, 0.8, 0.1),
	},
}
return {
	TextColors = TextColors,
	PanelBackgroundColors = PanelBackgroundColors,
	FillbarColors = FillbarColors,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="438">
              <Properties>
                <string name="Name">image</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local BorderImage = TS.import(script, script.Parent.Parent, "atoms", "Image").BorderImage
-- =============================================== Image Tokens ================================ 
local ImageTokens = {
	ZombieTheme = {
		BorderImage = BorderImage.GothicMetal(),
	},
	RobotTheme = {
		BorderImage = BorderImage.RedThick(),
	},
}
return {
	ImageTokens = ImageTokens,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="439">
              <Properties>
                <string name="Name">layouts</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        layouts.ts
	 * @module      Layout
	 * @layer       Style
	 * @description Provides pre-configured layout components for UI organization.
	 *
	 * ╭───────────────────────────────────╮
	 * │  Soul Steel · Coding Guide        │
	 * │  Fusion v4 · Strict TS · ECS      │
	 * ╰───────────────────────────────────╯
	 *
	 * @author      Copilot
	 * @license     MIT
	 * @since       0.1.0
	 * @lastUpdated 2025-06-23 by Copilot – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 *
	 * @remarks
	 *   Uses Fusion to create UIListLayout and UIGridLayout instances.
	 
]]
local New = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").New
local Layout = {
	VerticalSet = function(padding)
		return New("UIListLayout")({
			Name = "VerticalSet",
			FillDirection = Enum.FillDirection.Vertical,
			SortOrder = Enum.SortOrder.LayoutOrder,
			HorizontalAlignment = Enum.HorizontalAlignment.Center,
			VerticalAlignment = Enum.VerticalAlignment.Center,
			HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly,
			VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly,
			Padding = if padding ~= 0 and padding == padding and padding then UDim.new(0, padding) else nil,
		})
	end,
	VerticalScroll = function(padding)
		return New("UIListLayout")({
			Name = "VerticalList",
			FillDirection = Enum.FillDirection.Vertical,
			SortOrder = Enum.SortOrder.LayoutOrder,
			HorizontalAlignment = Enum.HorizontalAlignment.Left,
			VerticalAlignment = Enum.VerticalAlignment.Top,
			Padding = if padding ~= 0 and padding == padding and padding then UDim.new(0, padding) else nil,
		})
	end,
	HorizontalSet = function(padding)
		return New("UIListLayout")({
			Name = "HorizontalSet",
			FillDirection = Enum.FillDirection.Horizontal,
			SortOrder = Enum.SortOrder.LayoutOrder,
			HorizontalAlignment = Enum.HorizontalAlignment.Center,
			VerticalAlignment = Enum.VerticalAlignment.Center,
			Padding = if padding ~= 0 and padding == padding and padding then UDim.new(0, padding) else nil,
		})
	end,
	HorizontalScroll = function(padding)
		return New("UIListLayout")({
			Name = "HorizontalList",
			FillDirection = Enum.FillDirection.Horizontal,
			SortOrder = Enum.SortOrder.LayoutOrder,
			HorizontalAlignment = Enum.HorizontalAlignment.Left,
			VerticalAlignment = Enum.VerticalAlignment.Center,
			Padding = if padding ~= 0 and padding == padding and padding then UDim.new(0, padding) else nil,
		})
	end,
	Grid = function(padding, cellSize)
		return New("UIGridLayout")({
			Name = "GridLayout",
			CellSize = cellSize or UDim2.fromOffset(100, 100),
			SortOrder = Enum.SortOrder.LayoutOrder,
			HorizontalAlignment = Enum.HorizontalAlignment.Left,
			VerticalAlignment = Enum.VerticalAlignment.Top,
			FillDirection = Enum.FillDirection.Horizontal,
			CellPadding = if padding ~= 0 and padding == padding and padding then UDim2.new(0, padding, 0, padding) else nil,
		})
	end,
}
local function getLayoutStyle(style, padding, cellSize)
	if Layout[style] then
		return Layout[style](padding, cellSize)
	else
		warn(`Layout style "{style}" not found. Using default layout.`)
		return New("UIListLayout")({
			Name = "DefaultLayout",
			FillDirection = Enum.FillDirection.Vertical,
			SortOrder = Enum.SortOrder.LayoutOrder,
			HorizontalAlignment = Enum.HorizontalAlignment.Center,
			VerticalAlignment = Enum.VerticalAlignment.Center,
			HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly,
			VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly,
			Padding = if padding ~= 0 and padding == padding and padding then UDim.new(0, padding) else nil,
		})
	end
end
return {
	getLayoutStyle = getLayoutStyle,
	Layout = Layout,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="440">
              <Properties>
                <string name="Name">padding</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local Padding = function(amount)
	return Fusion.New("UIPadding")({
		Name = "Padding",
		PaddingLeft = UDim.new(0, amount),
		PaddingRight = UDim.new(0, amount),
		PaddingTop = UDim.new(0, amount),
		PaddingBottom = UDim.new(0, amount),
	})
end
return {
	Padding = Padding,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="441">
              <Properties>
                <string name="Name">stroke</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        stroke.ts
	 * @module      Stroke
	 * @layer       Style
	 * @description Provides UI stroke utilities for creating borders and outlines on UI elements.
	 *
	 * ╭───────────────────────────────────╮
	 * │  Soul Steel · Coding Guide        │
	 * │  Fusion v4 · Strict TS · ECS      │
	 * ╰───────────────────────────────────╯
	 *
	 * @author      Copilot
	 * @license     MIT
	 * @since       0.1.0
	 * @lastUpdated 2025-06-23 by Copilot – Initial creation
	 *
	 * @dependencies
	 *   @rbxts/fusion ^0.4.0
	 *
	 * @remarks
	 *   Uses Fusion to create UIStroke instances.
	 
]]
local New = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").New
local Stroke = function(props)
	return New("UIStroke")({
		Name = "Stroke",
		Thickness = props.Thickness or 1,
		Color = props.Color or Color3.new(1, 1, 1),
		ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
	})
end
return {
	Stroke = Stroke,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="442">
              <Properties>
                <string name="Name">text</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
local Value = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src").Value
local createAudio = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "assets", "audio").createAudio
local ImageTokens = TS.import(script, script.Parent, "image").ImageTokens
local _color = TS.import(script, script.Parent, "color")
local FillbarColors = _color.FillbarColors
local PanelBackgroundColors = _color.PanelBackgroundColors
local TextColors = _color.TextColors
--[[
	*
	 * @file        theme.ts
	 * @module      Theme
	 * @layer       Client/Style
	 * @description Shared color palette and theme tokens.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
-- =============================================== Color Tokens ================================ 
local StrokeColors = {
	ZombieTheme = {
		StrokeDefault = Color3.new(0.11, 0, 0),
		StrokeHover = Color3.new(0.24, 0.13, 0.01),
	},
	RobotTheme = {
		StrokeDefault = Color3.new(0.11, 0, 0),
		StrokeHover = Color3.new(0.24, 0.13, 0.01),
	},
}
local PlayerTheme
local TextToken = function()
	return {
		Font = PlayerTheme.TextTheme.Font,
		TextColor = PlayerTheme.TextTheme.TextColor,
		TextHoverColor = PlayerTheme.TextTheme.TextHoverColor,
		TextDisabledColor = PlayerTheme.TextTheme.TextDisabledColor,
	}
end
-- ================================================ Text Tokens ================================ 
local TextTokens = {
	ZombieTheme = {
		Font = Font.fromName("Oswald", Enum.FontWeight.Regular, Enum.FontStyle.Normal),
		FontHover = Font.fromName("LuckiestGuy", Enum.FontWeight.Bold, Enum.FontStyle.Italic),
		TextHoverColor = TextColors.ZombieTheme.TextHover,
		TextDisabledColor = TextColors.ZombieTheme.TextDisabled,
		TextDefaultColor = Color3.new(0.65, 0.99, 0.09),
		TextStrokeColor = Color3.new(0.11, 0, 0),
		TextHover = Color3.new(1, 1, 1),
		TextDisabled = Color3.new(0.5, 0.5, 0.5),
	},
	RobotTheme = {
		Font = Font.fromName("Oswald", Enum.FontWeight.Regular, Enum.FontStyle.Normal),
		FontHover = Font.fromName("LuckiestGuy", Enum.FontWeight.Bold, Enum.FontStyle.Italic),
		TextHoverColor = TextColors.ZombieTheme.TextHover,
		TextDisabledColor = TextColors.ZombieTheme.TextDisabled,
		TextDefaultColor = Color3.new(0.65, 0.99, 0.09),
		TextStrokeColor = Color3.new(0.11, 0, 0),
		TextHover = Color3.new(1, 1, 1),
		TextDisabled = Color3.new(0.5, 0.5, 0.5),
	},
}
-- =============================================== Theme State ============================= 
local THEME_KEYS = { "RobotTheme", "ZombieTheme" }
local createTheme = function(theme)
	local isZombie = theme == "ZombieTheme"
	return {
		TextTheme = {
			Font = Value(if isZombie then TextTokens.ZombieTheme.Font else TextTokens.RobotTheme.Font),
			TextColor = Value(if isZombie then TextTokens.ZombieTheme.TextDefaultColor else TextTokens.RobotTheme.TextDefaultColor),
			TextHoverColor = Value(if isZombie then TextTokens.ZombieTheme.TextHover else TextTokens.RobotTheme.TextHover),
			TextDisabledColor = Value(if isZombie then TextTokens.ZombieTheme.TextDisabled else TextTokens.RobotTheme.TextDisabled),
		},
		PanelTheme = {
			BackgroundColor = Value(if isZombie then PanelBackgroundColors.ZombieTheme.BackgroundColor else PanelBackgroundColors.RobotTheme.BackgroundColor),
			BackgroundHoverColor = Value(if isZombie then PanelBackgroundColors.ZombieTheme.BackgroundHoverColor else PanelBackgroundColors.RobotTheme.BackgroundHoverColor),
			StrokeColor = Value(if isZombie then StrokeColors.ZombieTheme.StrokeDefault else StrokeColors.RobotTheme.StrokeDefault),
		},
		ResourceBars = {
			BorderImage = Value(if isZombie then ImageTokens.ZombieTheme.BorderImage else ImageTokens.RobotTheme.BorderImage),
			HealthBarColor = Value(if isZombie then FillbarColors.ZombieTheme.Health else FillbarColors.RobotTheme.Health),
			ManaBarColor = Value(if isZombie then FillbarColors.ZombieTheme.Mana else FillbarColors.RobotTheme.Mana),
			StaminaBarColor = Value(if isZombie then FillbarColors.ZombieTheme.Stamina else FillbarColors.RobotTheme.Stamina),
		},
		Audio = {
			BackgroundMusic = Value(createAudio(theme, "BackgroundMusic")),
			SuccessClick = Value(createAudio(theme, "SuccessClick")),
			ErrorClick = Value(createAudio(theme, "ErrorClick")),
			Damaged = Value(createAudio(theme, "Damaged")),
		},
	}
end
local ZombieTheme = createTheme("ZombieTheme")
local RobotTheme = createTheme("RobotTheme")
PlayerTheme = ZombieTheme
return {
	StrokeColors = StrokeColors,
	TextToken = TextToken,
	TextTokens = TextTokens,
	THEME_KEYS = THEME_KEYS,
	createTheme = createTheme,
	ZombieTheme = ZombieTheme,
	RobotTheme = RobotTheme,
	PlayerTheme = PlayerTheme,
}
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="443">
        <Properties>
          <string name="Name">Theme</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, script, "ThemeKey") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script.Parent, "TS", "states", "ThemeState") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "hooks") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "tokens") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "types") or {} do
	exports[_k] = _v
end
return exports
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="444">
          <Properties>
            <string name="Name">ThemeKey</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        ThemeKey.ts
	 * @module      ThemeKey
	 * @layer       Shared
	 * @description Enumeration of available themes.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
-- =============================================== Theme Enumeration ======================= 
local ThemeKey = {
	CyberGothic = "CyberGothic",
	SolarDrift = "SolarDrift",
}
local DEFAULT_THEME = ThemeKey.SolarDrift
return {
	ThemeKey = ThemeKey,
	DEFAULT_THEME = DEFAULT_THEME,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="445">
          <Properties>
            <string name="Name">hooks</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        hooks.ts
	 * @module      ThemeHooks
	 * @layer       Client
	 * @description Helper hooks for consuming theme tokens.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
local Fusion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "fusion", "src")
local ThemeState = TS.import(script, script.Parent.Parent, "TS", "states", "ThemeState").ThemeState
local _binding = Fusion
local Computed = _binding.Computed
local function useToken(key)
	return Computed(function()
		return ThemeState.tokens:get().colours[key]
	end)
end
local function useFont()
	return Computed(function()
		return ThemeState.tokens:get().fonts
	end)
end
local function useImage(key)
	return Computed(function()
		return ThemeState.tokens:get().images[key]
	end)
end
return {
	useToken = useToken,
	useFont = useFont,
	useImage = useImage,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="446">
          <Properties>
            <string name="Name">tokens</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, script, "base") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "cyberGothic") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "solarDrift") or {} do
	exports[_k] = _v
end
return exports
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="447">
            <Properties>
              <string name="Name">base</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        base.ts
	 * @module      BaseTokens
	 * @layer       Shared
	 * @description Global tokens that never vary between themes.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
-- =============================================== Base Tokens ============================ 
local base = {}
return {
	base = base,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="448">
            <Properties>
              <string name="Name">cyberGothic</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        cyberGothic.ts
	 * @module      CyberGothicTokens
	 * @layer       Shared
	 * @description Token table for the CyberGothic theme.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
-- =============================================== Token Table ============================= 
local cyberGothic = {
	colours = {
		panelBg = Color3.fromRGB(16, 16, 16),
		panelBorder = Color3.fromRGB(0, 255, 153),
		textPrimary = Color3.fromRGB(0, 255, 153),
		textSecondary = Color3.fromRGB(179, 255, 230),
	},
	fonts = {
		family = Enum.Font.Arcade,
		weightNormal = 400,
		weightBold = 700,
	},
	images = {
		panelBorderSlice = "rbxassetid://1234567890",
	},
}
return {
	cyberGothic = cyberGothic,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="449">
            <Properties>
              <string name="Name">solarDrift</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        solarDrift.ts
	 * @module      SolarDriftTokens
	 * @layer       Shared
	 * @description Example token table for the SolarDrift theme.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
-- =============================================== Token Table ============================= 
local solarDrift = {
	colours = {
		panelBg = Color3.fromRGB(41, 13, 13),
		panelBorder = Color3.fromRGB(255, 175, 0),
		textPrimary = Color3.fromRGB(252, 222, 158),
		textSecondary = Color3.fromRGB(99, 99, 99),
	},
	fonts = {
		family = Enum.Font.SciFi,
		weightNormal = 400,
		weightBold = 700,
	},
	images = {
		panelBorderSlice = "rbxassetid://9876543210",
	},
}
return {
	solarDrift = solarDrift,
}
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="450">
          <Properties>
            <string name="Name">types</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        types.ts
	 * @module      ThemeTypes
	 * @layer       Shared
	 * @description Type contracts for theme design tokens.
	 *
	 * ╭───────────────────────────────╮
	 * │  Soul Steel · Coding Guide    │
	 * │  Fusion v4 · Strict TS · ECS  │
	 * ╰───────────────────────────────╯
	 
]]
-- =============================================== Token Groups ============================ 
return nil
]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="Workspace" referent="451">
    <Properties>
      <string name="Name">Workspace</string>
      <bool name="FilteringEnabled">true</bool>
      <bool name="NeedsPivotMigration">false</bool>
    </Properties>
  </Item>
</roblox>